{"version":3,"file":"rxdb-setup-webpack.js","mappings":"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AI,GAAG,EAAE,aAAa,IAAI,EAAE,IAAI,cAAc,IAAI,EAAE,IAAI,yEAAyE,EAAE,sBAAsB,IAAI,EAAE,IAAI,cAAc,IAAI,EAAE,IAAI,yEAAyE,EAAE;AACl/B;AACA;AACA,mCAAmC,EAAE,aAAa,EAAE,GAAG,EAAE,SAAS,GAAG;AACrE;AACA;AACA;AACA,iEAAiE,eAAe,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAyC;AACtD;AACA,aAAa,yCAAyC;AACtD;AACA,aAAa,0CAA0C;AACvD;AACA,cAAc,0CAA0C;AACxD;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE,0BAA0B,KAAK,oCAAoC,KAAK;AAC9G;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,cAAc,EAAE,+BAA+B,IAAI,GAAG,EAAE,eAAe,IAAI,GAAG,EAAE,aAAa,IAAI,gBAAgB,IAAI,GAAG,EAAE,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,gBAAgB,IAAI,GAAG,EAAE,gBAAgB,IAAI,GAAG,IAAI,SAAS,IAAI,gBAAgB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C,EAAE,qCAAqC,yBAAyB,EAAC;AACvG,wCAAuC,EAAE,qCAAqC,0BAA0B,EAAC;AACzG,2CAA0C,EAAE,qCAAqC,6BAA6B,EAAC;AAC/G,yBAAyB,mBAAO,CAAC,uFAA4B;AAC7D,mDAAkD,EAAE,qCAAqC,sCAAsC,EAAC;AAChI,kBAAkB,mBAAO,CAAC,yEAAqB;AAC/C,mDAAkD,EAAE,qCAAqC,+BAA+B,EAAC;AACzH;;;;;;;;;;ACjDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,wBAAwB,GAAG,mBAAmB,GAAG,qBAAqB,GAAG,iBAAiB,GAAG,iBAAiB,GAAG,kBAAkB,GAAG,WAAW,GAAG,SAAS,GAAG,WAAW,GAAG,aAAa,GAAG,YAAY,GAAG,kBAAkB,GAAG,mBAAmB;AAC1Q;AACA;AACA;AACA,mBAAmB;AACnB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,EAAE,EAAE,EAAE;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe,EAAE,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE,EAAE,WAAW;AAClC;AACA;AACA;AACA,4DAA4D,GAAG,EAAE,GAAG;AACpE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,kFAAkF,IAAI,WAAW,IAAI;AACrG;AACA,mBAAmB;AACnB;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA,qDAAqD,IAAI;AACzD;AACA,wBAAwB;AACxB;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;;;AC3Ja;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,UAAU,GAAG,WAAW,GAAG,WAAW,GAAG,eAAe,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,sBAAsB,GAAG,kBAAkB,GAAG,aAAa,GAAG,YAAY,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,mBAAmB,GAAG,WAAW,GAAG,iBAAiB,GAAG,WAAW,GAAG,SAAS;AACvS,eAAe,mBAAO,CAAC,+DAAQ;AAC/B,gBAAgB,mBAAO,CAAC,iEAAS;AACjC,aAAa,mBAAO,CAAC,+DAAQ;AAC7B,qCAAoC,EAAE,qCAAqC,oBAAoB,EAAC;AAChG,uCAAsC,EAAE,qCAAqC,sBAAsB,EAAC;AACpG,6CAA4C,EAAE,qCAAqC,4BAA4B,EAAC;AAChH,uCAAsC,EAAE,qCAAqC,sBAAsB,EAAC;AACpG,+CAA8C,EAAE,qCAAqC,8BAA8B,EAAC;AACpH,6CAA4C,EAAE,qCAAqC,4BAA4B,EAAC;AAChH,8CAA6C,EAAE,qCAAqC,6BAA6B,EAAC;AAClH,wCAAuC,EAAE,qCAAqC,uBAAuB,EAAC;AACtG,cAAc,mBAAO,CAAC,iEAAS;AAC/B,yCAAwC,EAAE,qCAAqC,yBAAyB,EAAC;AACzG,8CAA6C,EAAE,qCAAqC,8BAA8B,EAAC;AACnH,kDAAiD,EAAE,qCAAqC,kCAAkC,EAAC;AAC3H,4CAA2C,EAAE,qCAAqC,4BAA4B,EAAC;AAC/G,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,wDAAwD,SAAS;AACjE,kBAAkB,SAAS,EAAE,UAAU,EAAE,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,kBAAkB,UAAU,IAAI,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,IAAI;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,kBAAkB,UAAU,EAAE,QAAQ,IAAI,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,uCAAuC,WAAW;AAClD,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,kBAAkB,WAAW;AAC7B;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,sBAAsB,SAAS,EAAE,KAAK,GAAG,OAAO,EAAE,KAAK,GAAG,KAAK,EAAE,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc,EAAE,WAAW,EAAE,WAAW,EAAE,cAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,WAAW,UAAU,GAAG,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,sBAAsB;AACtB;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,IAAI;AAC/D,gDAAgD,IAAI,GAAG,EAAE;AACzD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,IAAI;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,SAAS,KAAK,WAAW;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ,QAAQ,GAAG,QAAQ,YAAY;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,OAAO;AACvG;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,qFAAqF,QAAQ,EAAE,IAAI,EAAE,OAAO;AAC5G;AACA;AACA,4DAA4D,EAAE;AAC9D;AACA;;;;;;;;;;ACxrBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,sBAAsB,GAAG,aAAa,GAAG,gBAAgB,GAAG,sBAAsB;AACvG,eAAe,mBAAO,CAAC,+DAAQ;AAC/B;AACA;AACA,qCAAqC,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qBAAqB,sBAAsB,sBAAsB;AAClE,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB,IAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,EAAE,WAAW;AACtC;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA,2CAA2C,0BAA0B,GAAG,UAAU;AAClF;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA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B;AAC/E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC,SAAS,aAAa;AACnF;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB,MAAM,sBAAsB;AAC9F;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F,gBAAgB,WAAW;AAC3B;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;;;;;;;;;;ACjPa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,mEAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;AC3Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,6DAAW;AACrC;AACA;AACA,gDAAgD,KAAK,UAAU,OAAO;AACtE;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,iBAAiB;AACjI,eAAe,mBAAO,CAAC,uDAAQ;AAC/B,cAAc,mBAAO,CAAC,gEAAiB;AACvC,iBAAiB,mBAAO,CAAC,0EAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC;AACA,sBAAsB;AACtB;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D,sCAAsC,OAAO;AAC7C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;AC1Ja;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB,2BAA2B;AAC7C,kBAAkB,2BAA2B;AAC7C,iBAAiB,0BAA0B;AAC3C,kBAAkB,2BAA2B;AAC7C;AACA;AACA,iBAAiB,qDAAqD;AACtE,kBAAkB,WAAW;AAC7B,gBAAgB,WAAW;AAC3B,eAAe;AACf,oBAAoB;AACpB;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;ACzBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,oBAAoB,GAAG,YAAY,GAAG,eAAe,GAAG,oBAAoB,GAAG,4BAA4B,GAAG,sBAAsB,GAAG,gBAAgB,GAAG,2BAA2B,GAAG,yBAAyB,GAAG,sBAAsB,GAAG,wBAAwB,GAAG,sBAAsB,GAAG,4BAA4B,GAAG,sBAAsB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,cAAc;AACzb,kBAAkB,mBAAO,CAAC,mEAAW;AACrC,eAAe,mBAAO,CAAC,uEAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,IAAI;AACzD;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA,+BAA+B,aAAa,EAAE,WAAW,EAAE,oCAAoC;AAC/F;AACA,sBAAsB;AACtB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB,IAAI;AACtB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,8BAA8B,qDAAqD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kEAAkE,IAAI,cAAc,MAAM;AAC1F,uCAAuC,MAAM,gFAAgF,IAAI,KAAK,0CAA0C,GAAG,IAAI,KAAK;AAC5L,SAAS;AACT,mEAAmE,IAAI;AACvE;AACA;AACA;AACA;AACA,mDAAmD,IAAI,KAAK;AAC5D;AACA;AACA,SAAS;AACT,6DAA6D,gBAAgB;AAC7E;AACA,KAAK;AACL;AACA,kEAAkE,IAAI,cAAc,MAAM,yDAAyD,MAAM,oBAAoB,IAAI,IAAI,MAAM,IAAI,IAAI,IAAI,KAAK;AAC5M,mEAAmE,IAAI,2EAA2E,IAAI,IAAI,MAAM,IAAI,IAAI,IAAI,KAAK;AACjL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,kEAAkE,MAAM,EAAE,8BAA8B;AACxG;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,CAAC,WAAW,YAAY,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD,6CAA6C,UAAU;AACvD;AACA,4CAA4C,SAAS;AACrD,4CAA4C,SAAS,6CAA6C;AAClG;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,0BAA0B,IAAI;AA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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oCAAoC;AAChD;AACA,sEAAsE,cAAc;AACpF;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6CAA6C;AACvE;AACA;AACA,qCAAqC,qBAAqB,cAAc,IAAI;AAC5E;AACA;AACA,iDAAiD,cAAc;AAC/D,kDAAkD,qBAAqB;AACvE,qCAAqC,qBAAqB,iBAAiB,IAAI,IAAI,WAAW,IAAI,SAAS;AAC3G;AACA;AACA;AACA,YAAY,sDAAsD;AAClE;AACA;AACA,mCAAmC,wBAAwB,wFAAwF,gBAAgB,GAAG,wBAAwB;AAC9L;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA,uCAAuC,UAAU;AACjD;AACA,uCAAuC,UAAU;AACjD;AACA;AACA,YAAY,2CAA2C;AACvD,YAAY,QAAQ;AACpB;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB,MAAM,eAAe;AACpF;AACA;AACA;AACA,YAAY,qBAAqB,aAAa,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,EAAE,4BAA4B,uBAAuB;AAC/F;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,sDAAsD,eAAe,iBAAiB,QAAQ;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS,gBAAgB,+BAA+B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,sCAAsC,YAAY,oBAAoB,kDAAkD;AACxH;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iGAAiG;AAC5I;AACA;AACA;AACA;AACA;AACA,4EAA4E,yBAAyB,GAAG;AACxG,4CAA4C,kBAAkB,GAAG,WAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mCAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK,EAAE,qEAAqE;AACnH,uCAAuC,MAAM,KAAK,KAAK;AACvD;AACA;AACA;AACA;AACA,gCAAgC,aAAa,EAAE,IAAI,8BAA8B,UAAU;AAC3F;AACA;AACA,eAAe;AACf;;;;;;;;;;ACvgBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,uBAAuB,GAAG,uBAAuB,GAAG,wBAAwB;AAC3G,kBAAkB,mBAAO,CAAC,oEAAY;AACtC,gBAAgB,mBAAO,CAAC,0DAAU;AAClC,eAAe,mBAAO,CAAC,6EAAyB;AAChD,iBAAiB,mBAAO,CAAC,4DAAW;AACpC;AACA,YAAY,yCAAyC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB,GAAG,QAAQ;AACtD;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB;AACxB;AACA;AACA,YAAY,gDAAgD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,GAAG,aAAa,mBAAmB,kDAAkD,EAAE;AAC5M;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO,EAAE,oEAAoE;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,YAAY,gBAAgB;AAC5B,qEAAqE,cAAc,GAAG,sBAAsB;AAC5G;AACA;AACA,YAAY,MAAM;AAClB,6CAA6C,KAAK;AAClD;AACA,iEAAiE,yBAAyB,a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;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,gBAAgB,aAAa;AAC7B,gDAAgD,SAAS,yCAAyC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,aAAa;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA,6CAA6C,KAAK,gBAAgB,YAAY;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B,mDAAmD,UAAU,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qCAAqC,KAAK;AAChD;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,EAAE,gBAAgB,EAAE,UAAU;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAA2C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA;AACA;AACA;AACA,gCAAgC,IAAI,WAAW,IAAI,IAAI,eAAe;AACtE;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,iBAAiB,SAAS,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA,uCAAuC,KAAK;AAC5C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,4DAA4D,SAAS;AACrE;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzmBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA,cAAc,mBAAO,CAAC,gEAAiB;AACvC;AACA,kBAAe;AACf;;;;;;;;;;ACNa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA;;;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY,mBAAO,CAAC,kDAAU;AAC9B;AACA,kBAAe;AACf;;;;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;ACVa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,eAAe,mBAAO,CAAC,mEAAoB;AAC3C;AACA,gBAAgB,UAAU,OAAO,mDAAmD,KAAK;AACzF,eAAe,UAAU,OAAO,wBAAwB,SAAS,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA,qDAAqD,KAAK;AAC1D;AACA,wBAAwB,mBAAmB;AAC3C,qCAAqC,KAAK,KAAK,aAAa;AAC5D;AACA;AACA,2DAA2D,KAAK,KAAK,aAAa,IAAI;AACtF;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAqD;AACjF;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B;AAC/B,kBAAe;AACf;;;;;;;;;;AChDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,6DAAS;AAChC,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,gBAAgB,mBAAO,CAAC,qEAAqB;AAC7C,eAAe,mBAAO,CAAC,mEAAoB;AAC3C;AACA;AACA,eAAe,QAAQ,wBAAwB,sBAAsB,2BAA2B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW,MAAM,uBAAuB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,KAAK,MAAM,EAAE;AACrG;AACA;AACA;AACA;AACA;AACA,wGAAwG,+BAA+B,QAAQ,IAAI;AACnJ;AACA;AACA;AACA;AACA,gDAAgD,KAAK,GAAG,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;ACzGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,mEAAoB;AAC3C;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iCAAiC;AAC5E;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,6DAAS;AAChC;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAyC;AACtD;AACA,kBAAe;AACf;;;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,eAAe,mBAAO,CAAC,mEAAoB;AAC3C;AACA,gBAAgB,UAAU,YAAY;AACtC,sDAAsD,KAAK;AAC3D,sDAAsD,KAAK,mBAAmB,KAAK;AACnF,eAAe,UAAU,YAAY,4CAA4C,eAAe,KAAK,uBAAuB,eAAe,IAAI,iBAAiB,KAAK;AACrK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK;AAC9D,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK,KAAK,IAAI;AACzD;AACA,2CAA2C,MAAM,KAAK,KAAK,KAAK,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA,2CAA2C,OAAO,KAAK,IAAI;AAC3D;AACA;AACA,2CAA2C,OAAO,IAAI,IAAI;AAC1D;AACA;AACA;AACA,+CAA+C,OAAO,KAAK,IAAI;AAC/D;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;AC9Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,4BAA4B,GAAG,aAAa;AACzE,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,eAAe,mBAAO,CAAC,mEAAoB;AAC3C,eAAe,mBAAO,CAAC,6DAAS;AAChC,aAAa;AACb,gBAAgB,UAAU,6BAA6B;AACvD;AACA,+CAA+C,cAAc,EAAE,MAAM,gBAAgB,UAAU;AAC/F,KAAK;AACL,eAAe,UAAU,8CAA8C,wBAAwB,YAAY,SAAS;AACpH,uBAAuB,gBAAgB;AACvC,iBAAiB,UAAU;AAC3B,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uCAAuC,aAAa,MAAM,iDAAiD;AAC3G;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA,2CAA2C,2BAA2B;AACtE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,kBAAe;AACf;;;;;;;;;;ACpFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,e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e,QAAQ,wBAAwB,kBAAkB,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,gDAAgD,UAAU,KAAK,MAAM;AACrE;AACA,8DAA8D,QAAQ,IAAI,EAAE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;AC3Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,6DAAS;AAChC,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,eAAe,mBAAO,CAAC,mEAAoB;AAC3C,eAAe,mBAAO,CAAC,mEAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,MAAM,kBAAkB,KAAK;AAC7F;AACA;AACA;AACA;AACA;AACA,2CAA2C,iCAAiC,QAAQ,IAAI;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,uDAAuD,MAAM,GAAG,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;AC1Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,yEAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,iFAAwB;AACnD,eAAe,mBAAO,CAAC,6DAAS;AAChC,eAAe,mBAAO,CAAC,mEAAoB;AAC3C,+BAA+B,mBAAO,CAAC,uGAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;ACrDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,eAAe,mBAAO,CAAC,mEAAoB;AAC3C;AACA;AACA,eAAe,QAAQ,wBAAwB,gBAAgB,qBAAqB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;ACrCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,mEAAoB;AAC3C;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA,gDAAgD,QAAQ;AACxD,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;ACZa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,qBAAqB,GAAG,kBAAkB,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,2BAA2B,GAAG,wBAAwB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,mBAAmB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,8BAA8B;AAChV,kBAAkB,mBAAO,CAAC,4EAAoB;AAC9C,eAAe,mBAAO,CAAC,gEAAiB;AACxC,gBAAgB,mBAAO,CAAC,kEAAkB;AAC1C,eAAe,mBAAO,CAAC,gEAAiB;AACxC;AACA,YAAY,gBAAgB;AAC5B;AACA,wBAAwB,qCAAqC,KAAK,GAAG;AACrE;AACA,KAAK;AACL;AACA,8BAA8B;AAC9B,4BAA4B,iBAAiB,QAAQ;AACrD,uJAAuJ,SAAS,IAAI,KAAK;AACzK;AACA,wBAAwB;AACxB;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB;AACnB;AACA,+BAA+B,iBAAiB,QAAQ,KAAK,IAAI,SAAS;AAC1E;AACA,qBAAqB;AACrB;AACA,qCAAqC,KAAK,EAAE,sCAAsC;AAClF,+CAA+C,MAAM,KAAK,mCAAmC;AAC7F;AACA,sBAAsB;AACtB;AACA,qCAAqC,KAAK,EAAE,sCAAsC;AAClF;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,wBAAwB;AACxB,4BAA4B,wBAAwB,0CAA0C,MAAM;AACpG,2DAA2D,WAAW,IAAI,KAAK,IAAI,aAAa,EAAE,WAAW;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc,IAAI,sBAAsB;AAC7E,2DAA2D,KAAK,QAAQ,QAAQ,IAAI,KAAK,yBAAyB,KAAK,GAAG,KAAK;AAC/H;AACA,wBAAwB;AACxB;AACA,sBAAsB,WAAW,QAAQ;AACzC;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,kCAAkC,4EAA4E,GAAG,QAAQ,IAAI,EAAE;AAC/H,KAAK;AACL;AACA,kBAAkB;AAClB;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,qBAAqB;AACrB;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,8CAA8C,OAAO,KAAK,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;AClIa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;ACTa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,6DAAM;AAC3B,cAAc,mBAAO,CAAC,+DAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,MAAM,qBAAqB;AAC3B;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;ACfa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,mBAAmB;AACrC,oBAAoB,mBAAO,CAAC,6EAAyB;AACrD,eAAe,mBAAO,CAAC,6DAAS;AAChC,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,gBAAgB,mBAAO,CAAC,qEAAqB;AAC7C,kBAAkB,mBAAO,CAAC,+DAAe;AACzC,eAAe,mBAAO,CAAC,mEAAoB;AAC3C;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC,gBAAgB,mDAAmD;AACnE,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,gDAAgD,IAAI,UAAU;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,MAAM;AAClB;AACA,uCAAuC,mBAAmB;AAC1D,8BAA8B,4BAA4B,UAAU,EAAE;AACtE;AACA,mBAAmB;AACnB;AACA,YAAY,UAAU;AACtB,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8CAA8C;AAC7F,iCAAiC;AACjC;AACA;AACA,SAAS;AACT,yCAAyC,GAAG,aAAa,mBAAmB;AAC5E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD,gEAAgE,yBAAyB,aAAa,MAAM,IAAI,wBAAwB,UAAU,KAAK,KAAK;AAC5J,+DAA+D,wBAAwB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,OAAO;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,OAAO;AAC1E;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,kBAAe;AACf;;;;;;;;;;ACzHa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,gBAAgB,mBAAO,CAAC,2FAAwB;AAChD,kBAAkB,mBAAO,CAAC,+DAAe;AACzC,oBAAoB,mBAAO,CAAC,6EAAyB;AACrD,eAAe,mBAAO,CAAC,mEAAoB;AAC3C;AACA,gBAAgB,UAAU,uBAAuB;AACjD,kBAAkB,QAAQ;AAC1B,2BAA2B,QAAQ;AACnC,eAAe,UAAU,4BAA4B,wBAAwB,SAAS,WAAW,SAAS,QAAQ,cAAc,KAAK;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK,EAAE,oCAAoC;AACpG,0CAA0C,KAAK,gEAAgE,kDAAkD;AACjK;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK,MAAM,SAAS;AACnE;AACA;AACA;AACA,+BAA+B,sDAAsD;AACrF;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,QAAQ;AAC7H;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,QAAQ;AAC1E;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;ACvGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA,CAAC,iBAAiB,kBAAkB,kBAAkB;AACtD;;;;;;;;;;ACRa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,kEAAQ;AAC/B,qBAAqB,mBAAO,CAAC,8EAAc;AAC3C,qBAAqB,mBAAO,CAAC,8EAAc;AAC3C,iBAAiB,mBAAO,CAAC,sEAAU;AACnC,mBAAmB,mBAAO,CAAC,oEAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;AChBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD;AACA,gBAAgB,YAAY,8CAA8C,WAAW;AACrF,eAAe,YAAY,wBAAwB,UAAU,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D,gBAAgB,uCAAuC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,+DAA+D,KAAK,GAAG,WAAW;AAClF;AACA;AACA;AACA,8CAA8C,MAAM,mBAAmB,MAAM,iEAAiE,KAAK,uDAAuD,KAAK;AAC/M;AACA;AACA;AACA;AACA,2CAA2C,YAAY,MAAM,OAAO;AACpE;AACA;AACA;AACA,2CAA2C,KAAK,iBAAiB,OAAO,GAAG,KAAK,MAAM,OAAO,GAAG,KAAK;AACrG,0CAA0C,OAAO,GAAG,KAAK;AACzD,8DAA8D,QAAQ,kBAAkB,YAAY,IAAI,OAAO,QAAQ,KAAK;AAC5H,2CAA2C,QAAQ,KAAK,QAAQ,cAAc,OAAO,MAAM,UAAU,MAAM,UAAU;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO,+BAA+B,cAAc;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB,EAAE,mCAAmC;AACrG;AACA,wDAAwD,gCAAgC;AACxF;AACA,0FAA0F,IAAI;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO,GAAG,KAAK;AACpE;AACA,yEAAyE,OAAO,GAAG,KAAK,yBAAyB,OAAO,QAAQ,KAAK;AACrI;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;AC3Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,uEAAU;AACnC;AACA,kBAAe;AACf;;;;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,0BAA0B;AACtD,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;;;;;;;;;ACjBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,eAAe,mBAAO,CAAC,mEAAoB;AAC3C,gBAAgB,mBAAO,CAAC,qEAAqB;AAC7C;AACA;AACA,eAAe,YAAY,wBAAwB,gBAAgB,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA,+CAA+C,0CAA0C,GAAG,KAAK,IAAI,WAAW;AAChH;AACA;AACA,yCAAyC,QAAQ,MAAM,KAAK;AAC5D;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;ACxBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,eAAe,mBAAO,CAAC,mEAAoB;AAC3C,gBAAgB,mBAAO,CAAC,qEAAqB;AAC7C;AACA;AACA,eAAe,YAAY,wBAAwB,iBAAiB,YAAY;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,SAAS,GAAG,KAAK,IAAI,EAAE;AAChG;AACA;AACA;AACA;AACA,sCAAsC,SAAS,GAAG,KAAK,IAAI,QAAQ,GAAG,EAAE;AACxE,sCAAsC,MAAM,MAAM,IAAI;AACtD;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;AC/Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,mBAAO,CAAC,qFAAe;AAC7C,qBAAqB,mBAAO,CAAC,mFAAc;AAC3C,sBAAsB,mBAAO,CAAC,qFAAe;AAC7C,kBAAkB,mBAAO,CAAC,6EAAW;AACrC,0BAA0B,mBAAO,CAAC,6FAAmB;AACrD,mBAAmB,mBAAO,CAAC,+EAAY;AACvC,qBAAqB,mBAAO,CAAC,mFAAc;AAC3C,sBAAsB,mBAAO,CAAC,qFAAe;AAC7C,gBAAgB,mBAAO,CAAC,yEAAS;AACjC,eAAe,mBAAO,CAAC,uEAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kDAAkD;AACxD,MAAM,4CAA4C;AAClD;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;AChCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD;AACA,cAAc,qBAAqB;AACnC;AACA,mDAAmD,MAAM,OAAO,YAAY;AAC5E,KAAK;AACL,eAAe,YAAY,wBAAwB,SAAS,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA,0CAA0C,KAAK,UAAU,IAAI,EAAE,WAAW;AAC1E,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,eAAe,mBAAO,CAAC,mEAAoB;AAC3C,qBAAqB,mBAAO,CAAC,+EAA0B;AACvD;AACA,cAAc,qBAAqB;AACnC;AACA,mDAAmD,MAAM,OAAO,YAAY;AAC5E,KAAK;AACL,eAAe,YAAY,wBAAwB,SAAS,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA,oEAAoE,KAAK,+BAA+B,mDAAmD,GAAG,KAAK;AACnK,0CAA0C,KAAK,EAAE,IAAI,EAAE,WAAW;AAClE,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;AC1Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD;AACA;AACA,eAAe,wCAAwC;AACvD,eAAe,wCAAwC;AACvD,wBAAwB,uCAAuC;AAC/D,wBAAwB,uCAAuC;AAC/D;AACA;AACA,gBAAgB,qBAAqB,mCAAmC,qBAAqB,EAAE,WAAW;AAC1G,eAAe,qBAAqB,wBAAwB,cAAc,oBAAoB,WAAW,YAAY;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C,0CAA0C,MAAM,EAAE,oBAAoB,EAAE,YAAY,WAAW,KAAK;AACpG,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;AC1Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD;AACA,cAAc,qBAAqB;AACnC;AACA,mDAAmD,MAAM,OAAO,YAAY;AAC5E,KAAK;AACL,eAAe,YAAY,wBAAwB,SAAS,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA,sDAAsD,KAAK,WAAW,IAAI,EAAE,WAAW;AACvF,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD;AACA,gBAAgB,YAAY,+CAA+C,WAAW;AACtF,eAAe,YAAY,wBAAwB,cAAc,YAAY;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA,sDAAsD,IAAI,MAAM,IAAI,SAAS,KAAK;AAClF,kCAAkC,KAAK,eAAe,IAAI;AAC1D,2CAA2C,YAAY,YAAY,KAAK,IAAI,KAAK,GAAG,WAAW,IAAI,QAAQ;AAC3G,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;ACzBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,6DAAS;AAChC,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD;AACA,gBAAgB,YAAY,+CAA+C,WAAW;AACtF,eAAe,YAAY,wBAAwB,WAAW,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA,+DAA+D,WAAW,IAAI,EAAE;AAChF,2CAA2C,OAAO,QAAQ,KAAK;AAC/D,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,6DAAS;AAChC,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,eAAe,mBAAO,CAAC,mEAAoB;AAC3C;AACA,gBAAgB,UAAU,mBAAmB,wDAAwD,gBAAgB;AACrH,eAAe,UAAU,mBAAmB,wBAAwB,mBAAmB,iBAAiB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA,sDAAsD,YAAY,uBAAuB,WAAW;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,aAAa;AACb;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;AC9Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,6FAAiC;AAC5D,kBAAkB,mBAAO,CAAC,+EAAuB;AACjD,eAAe,mBAAO,CAAC,mEAAoB;AAC3C,gBAAgB,mBAAO,CAAC,qEAAqB;AAC7C;AACA,gBAAgB,UAAU,QAAQ,mEAAmE,GAAG,MAAM,GAAG;AACjH,eAAe,UAAU,QAAQ,wBAAwB,KAAK,EAAE,OAAO,GAAG;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAyD;AACzE;AACA;AACA;AACA;AACA,uEAAuE,YAAY;AACnF;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA,4BAA4B,MAAM;AAClC;AACA,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,uCAAuC,EAAE,EAAE,GAAG;AAC9C,kDAAkD,KAAK,GAAG,EAAE;AAC5D;AACA;AACA,sDAAsD,MAAM,kCAAkC,MAAM;AACpG;AACA,mDAAmD,QAAQ,GAAG,KAAK;AACnE,sDAAsD,QAAQ,GAAG,KAAK;AACtE;AACA;AACA,iBAAiB;AACjB,8CAA8C,QAAQ,GAAG,KAAK,MAAM,EAAE;AACtE,aAAa;AACb;AACA;AACA;AACA;AACA,oDAAoD,EAAE,EAAE,GAAG,qCAAqC,GAAG,IAAI,IAAI,EAAE,EAAE,GAAG,oCAAoC,IAAI,GAAG,KAAK,GAAG,EAAE,KAAK,KAAK,GAAG,EAAE;AACtL;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5CiD;AACI;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAmB;AAC9C,oBAAoB,2BAA2B;AAC/C;AACA;AACA,sBAAsB,kEAAe;AACrC;AACA;AACA;AACA;AACA,+BAA+B,6DAAmB;AAClD,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA,sBAAsB,kEAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrDoD;AAC7C;AACP;AACA;AACA;AACA;AACA,0BAA0B,gEAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO,6BAA6B;AAC7B;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO,mCAAmC;AACnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrDO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8CAA8C,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5GqF;AAClC;AACI;;AAEvD;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAuB;AACxC,gBAAgB,gEAAY;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACO;AACP,YAAY,oEAAuB;AACnC,eAAe,gEAAY;AAC3B;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,WAAW,4DAAsB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,2DAAqB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,2DAAqB;AAC9F;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM,mDAAS;AACf;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChQ0C;;AAE1C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,iBAAiB,2CAAS;AAC1B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzCwC;AACgC;;AAExE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe,qDAAW;AAC1B;AACA;AACA,8BAA8B;AAC9B,sBAAsB;;AAEtB,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,UAAU,kEAAQ;AAClB;AACA;AACA,SAAS,yBAAyB;AAClC,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2EAAiB;AAC5B;AACA;;;;;;;;;;;;;;;;;ACxFiH;AACzC;AACF;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAW;;AAE1B;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAqB;AACpC;AACA;;AAEA;AACA,kBAAkB;AAClB,oBAAoB;AACpB,8BAA8B;AAC9B,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+CAAK;AAClB;AACA;AACA,aAAa,+CAAK;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAiB;AAC9B;AACA,6BAA6B,+CAAK;AAClC;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,eAAe,2EAAiB;AAChC,OAAO;AACP;AACA;AACA,6BAA6B,+CAAK;AAClC;AACA,SAAS;AACT,OAAO,yBAAyB;AAChC;AACA;AACA;AACA,iBAAiB,kEAAQ;AACzB;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2EAAiB;AAC5B;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,WAAW,2DAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,aAAa,+CAAK;AAClB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,4DAAkB,SAAS,+EAAqB;AAChE;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;;;;AC5RmD;AACO;AACK;AACR;AACvD;;AAEA;AACA,eAAe,4DAAY;AAC3B;AACA,mEAAe,EAAE,wEAAkB;AAC5B;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,gEAAc;AAC3B;AACA;AACA;AACA,KAAK;AACL,4EAA4E;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyG;AAClG,mBAAmB,kDAAK;AACc;AACW;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACO;AACP,YAAY,oEAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAW;AACvB;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB,uDAAY;AAC5B;AACA,yBAAyB,2DAAqB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,WAAW,+CAAK;AAChB,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,gDAAgD;AAChD,+CAA+C;AAC/C,mEAAmE;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAqB;;AAEhD;AACA,sCAAsC,2DAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK,GAAG;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,2DAAqB;AAChC,GAAG;AACH;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA,GAAG;AACH,QAAQ,mDAAS;AACjB;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxVA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;AACW;AACe;AAChE,mBAAmB,kDAAK;AAC/B;AACO;;AAEP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,+CAAK;AACT;AACA;AACA,eAAe,qDAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP,YAAY,oEAAuB;AACnC;AACA;AACA;AACA,aAAa,qDAAW;;AAExB;AACA;AACA;AACA,YAAY;AACZ;AACA,iBAAiB,uDAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,sCAAsC;AACtC,yDAAyD;AACzD,mFAAmF;;AAEnF;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACrJ0E;AACnE,mBAAmB,kDAAK;AACxB;AACA;AACP;AACA,UAAU,sDAAK;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA,WAAW,2DAAqB;AAChC,IAAI;AACJ;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC7DmD;AAC5C,mBAAmB,kDAAK;AACxB;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;AACH;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvDO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACO;AACP;AACA;AACO;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACO;AACP;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,cAAc,WAAW;AACzB,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA,cAAc,mBAAmB;AACjC,cAAc,eAAe;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,cAAc,SAAS;AACvB,cAAc;AACd;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,UAAU;AACxB,cAAc,WAAW;AACzB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc;AACd;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;;AAEA;;AAEA,2BAA2B;;;AAG3B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY;AACZ;;;AAGA;AACA,wBAAwB;;AAExB,8DAA8D;;AAE9D;AACA;;AAEA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;;;ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,KAA4D;AAChE,IAAI,CACoG;AACxG,CAAC,uBAAuB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,OAAO;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,qBAAM;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,cAAc,2EAA2E;AACzF,cAAc,6DAA6D;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,mDAAmD,2BAA2B,IAAI,0BAA0B,oBAAoB;AACxM,uEAAuE,oBAAoB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gBAAgB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,KAAK;AACL;AACA;AACA,kCAAkC,kCAAkC;AACpE,yCAAyC,4BAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,uBAAuB;AAC1F;AACA;AACA;AACA;AACA,2DAA2D,2CAA2C,IAAI;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;AACA;AACA,4EAA4E,eAAe;AAC3F,aAAa;AACb,4EAA4E,4BAA4B;AACxG,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,0DAA0D,6CAA6C;AACvG;AACA,iBAAiB;AACjB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8CAA8C,2DAA2D;AACzG,aAAa;AACb,SAAS;AACT;AACA,+BAA+B,aAAa;AAC5C,oCAAoC;AACpC,SAAS;AACT,uBAAuB,mBAAmB,uBAAuB;AACjE;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C,oCAAoC;AACpC,SAAS;AACT;AACA,+BAA+B,yBAAyB;AACxD,oCAAoC;AACpC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,uDAAuD,sBAAsB,sCAAsC,sBAAsB,sBAAsB,uCAAuC;AACrQ,4CAA4C,yCAAyC,IAAI;AACzF,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,uDAAuD,wBAAwB;AAC9I;AACA;AACA;AACA,qBAAqB,IAAI;AACzB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,mBAAmB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iDAAiD,qCAAqC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAyD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,mDAAmD;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD,wDAAwD,mDAAmD;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2FAA2F,gBAAgB;AAC3G,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,2EAA2E;AACzG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oEAAoE,IAAI,+CAA+C;AACtK;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8BAA8B;AACtE,2CAA2C,sCAAsC;AACjF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,0CAA0C;AAClG,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB,6CAA6C;AACnF;AACA;AACA;AACA;AACA,qEAAqE,yBAAyB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,6BAA6B;AACjH,8BAA8B,iBAAiB,iDAAiD;AAChG;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA,qBAAqB;AACrB,4DAA4D;AAC5D;AACA,iBAAiB;AACjB;AACA;AACA,oDAAoD,OAAO;AAC3D,gFAAgF,sCAAsC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iFAAiF;AAC5H,aAAa,wBAAwB,iFAAiF;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,2BAA2B,iFAAiF,IAAI;AAC/K,uCAAuC,iFAAiF;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+DAA+D,2BAA2B,2CAA2C,IAAI;AACzI,uCAAuC,4EAA4E;AACnH;AACA;AACA;AACA,+DAA+D,2BAA2B,oDAAoD,IAAI;AAClJ,uCAAuC,4EAA4E;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2BAA2B,mCAAmC,sCAAsC,IAAI;AACzH,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uFAAuF;AAClI;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uFAAuF;AAClI;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,6DAA6D,mBAAmB;AAChF,oEAAoE,uBAAuB;AAC3F;AACA;AACA,2CAA2C,0CAA0C;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gBAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qEAAqE,gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2CAA2C,0CAA0C;AACrF,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,qFAAqF,mBAAmB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,mCAAmC,sBAAsB;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qCAAqC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,6BAA6B,mBAAmB,0BAA0B;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,mCAAmC;AAC7F;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,wEAAwE,sBAAsB,mBAAmB,kBAAkB,UAAU,iBAAiB,gBAAgB,UAAU;AACxL,8EAA8E,sBAAsB;AACpG;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,sCAAsC;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,8CAA8C;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B,oCAAoC;AACnF;AACA;AACA;AACA,mDAAmD,SAAS,eAAe;AAC3E,4CAA4C,eAAe;AAC3D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uDAAuD,wBAAwB,4CAA4C,aAAa;AACxI;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yCAAyC;AACzC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wDAAwD,cAAc;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,8CAA8C;AACjG;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB,kDAAkD,IAAI,qBAAqB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB,mDAAmD,IAAI;AAChH;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uBAAuB,uCAAuC;AAChH,uDAAuD,qDAAqD;AAC5G;AACA,wDAAwD,eAAe,YAAY;AACnF;AACA,iIAAiI,uBAAuB;AACxJ;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,wBAAwB;AAC7F;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD,2BAA2B;AAC3B;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA,aAAa;AACb,4DAA4D,kBAAkB;AAC9E,4DAA4D,kBAAkB;AAC9E;AACA;AACA;AACA;AACA,sEAAsE,6EAA6E;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,wDAAwD;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iEAAiE;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,2BAA2B;AACtF;AACA;AACA;AACA;AACA,2DAA2D,6CAA6C;AACxG;AACA;AACA;AACA;AACA,2DAA2D,8CAA8C;AACzG;AACA;AACA;AACA;AACA,2DAA2D,oDAAoD;AAC/G;AACA;AACA;AACA;AACA,2DAA2D,uCAAuC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,+BAA+B;AACjG;AACA;AACA,kEAAkE,oBAAoB;AACtF;AACA;AACA;AACA;AACA;AACA,kEAAkE,6BAA6B;AAC/F;AACA;AACA;AACA;AACA;AACA,kEAAkE,6BAA6B,4BAA4B,IAAI;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,kDAAkD;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0BAA0B;AACpE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kFAAkF,4CAA4C;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,kCAAkC;AAClC;AACA,6CAA6C,4CAA4C;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAA+C;AAChF,iCAAiC;AACjC;AACA,iCAAiC,gDAAgD;AACjF,iCAAiC;AACjC;AACA;AACA;AACA;AACA,4DAA4D,wFAAwF;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA;AACA,4DAA4D,gCAAgC;AAC5F;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,0CAA0C;AAC1C,0CAA0C;AAC1C;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,8CAA8C;AAC3H,sEAAsE,8CAA8C;AACpH;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,4CAA4C,yBAAyB;AACrE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,iBAAiB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8CAA8C,gEAAgE,mBAAmB,+DAA+D;AAChM;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,6BAA6B;AAC9F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,kCAAkC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2FAA2F,gCAAgC;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B,sCAAsC;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kFAAkF;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wDAAwD;AACjH;AACA;AACA;AACA,0FAA0F,oBAAoB;AAC9G;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,oDAAoD,qBAAqB,eAAe;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA,+DAA+D,iBAAiB,6BAA6B;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kBAAkB;AACvE;AACA;AACA,qDAAqD,kBAAkB;AACvE;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,mCAAmC;AAChG;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gEAAgE,wCAAwC;AACxG;AACA,0CAA0C,sCAAsC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC,SAAS;AACT;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gCAAgC;AAC5F;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+BAA+B;AAC9E;AACA,kEAAkE,oEAAoE;AACtI;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,kDAAkD,oCAAoC;AACtF;AACA;AACA;AACA;AACA,kDAAkD,wEAAwE;AAC1H;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,2CAA2C,gBAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,sCAAsC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gCAAgC;AAC5F;AACA;AACA;AACA,yBAAyB;AACzB,gEAAgE,sCAAsC;AACtG;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iGAAiG,uBAAuB;AACxH;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iFAAiF,0BAA0B;AAC3G;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wDAAwD;AACtE,cAAc,6BAA6B;AAC3C,yCAAyC,8BAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mDAAmD,2CAA2C;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,2CAA2C;AAChH;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,0BAA0B;AAC1B;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mBAAmB;AAC9D,8CAA8C,6BAA6B;AAC3E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,YAAY;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,SAAS,wBAAwB,mCAAmC;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qEAAqE,IAAI,MAAM;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,8CAA8C,mCAAmC;AACjF;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA,gCAAgC,4CAA4C;AAC5E;AACA;AACA;AACA;AACA;AACA,gCAAgC,4CAA4C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,4EAA4E,uDAAuD;AACnI;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mBAAmB;AACxE;AACA;AACA;AACA,sEAAsE,gBAAgB;AACtF;AACA;AACA,kDAAkD,uBAAuB;AACzE;AACA;AACA,mEAAmE,yCAAyC;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,iCAAiC;AACvG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,kCAAkC;AAC5F;AACA;AACA;AACA,kEAAkE,8BAA8B;AAChG;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,2CAA2C,+BAA+B,+BAA+B,+BAA+B;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D,4DAA4D,sEAAsE;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,sEAAsE;AACtE;AACA,gIAAgI;AAChI,qDAAqD,qBAAqB;AAC1E;AACA;AACA,4DAA4D,WAAW;AACvE,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,oBAAoB;AAC/E;AACA,gOAAgO;AAChO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,+BAA+B;AACpF;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA,2BAA2B;AAC3B;AACA,iDAAiD,YAAY,4BAA4B,aAAa,sFAAsF;AAC5L;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,sDAAsD,+CAA+C;AACrG,uBAAuB;AACvB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,4BAA4B,eAAe;AACjF;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,6BAA6B;AAChH;AACA;AACA;AACA,mFAAmF,6BAA6B;AAChH;AACA;AACA;AACA,mFAAmF,6BAA6B;AAChH;AACA;AACA;AACA,mFAAmF,0BAA0B;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,UAAU,YAAY,eAAe;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,oDAAoD,iBAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,iCAAiC;AACjC,sEAAsE,2CAA2C;AACjH;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,qDAAqD,sCAAsC,iCAAiC,gBAAgB;AAC5I;AACA;AACA,wDAAwD,4CAA4C;AACpG;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,0FAA0F,YAAY,mDAAmD;AACzJ;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,uBAAuB;AACvB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,8BAA8B,2DAA2D;AACzF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0CAA0C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA,2BAA2B;AAC3B,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,6GAA6G,sEAAsE;AACnL,yDAAyD,YAAY;AACrE;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,YAAY;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,+CAA+C;AACvH;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,2BAA2B;AACnH,gGAAgG,qCAAqC;AACrI,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,oGAAoG;AACpG;AACA,6BAA6B;AAC7B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6CAA6C;AAC3F,kDAAkD,wDAAwD;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,UAAU,eAAe;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,yDAAyD;AACzD;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,yDAAyD;AACzD,qDAAqD;AACrD;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,+CAA+C,8BAA8B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,6DAA6D,8BAA8B;AAC3F;AACA;AACA,iEAAiE,8BAA8B;AAC/F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,2BAA2B;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,gDAAgD,2BAA2B;AAC3E;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,uFAAuF,2BAA2B;AAClH;AACA;AACA,sCAAsC,oEAAoE;AAC1G;AACA;AACA;AACA,4DAA4D,2BAA2B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,oEAAoE,uDAAuD;AAC3H;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA,oEAAoE,sBAAsB;AAC1F;AACA;AACA;AACA;AACA,gGAAgG,+BAA+B;AAC/H;AACA,yGAAyG,gBAAgB;AACzH;AACA,uFAAuF,gBAAgB;AACvG;AACA;AACA;AACA,uGAAuG,4CAA4C;AACnJ;AACA;AACA;AACA;AACA;AACA,mHAAmH,+BAA+B;AAClJ,yGAAyG,gBAAgB;AACzH;AACA,uFAAuF,gBAAgB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,4CAA4C;AAC3J;AACA;AACA;AACA,uGAAuG,gBAAgB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,4CAA4C;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,mBAAmB;AACtG;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+JAA+J,qBAAqB;AACpL;AACA,kFAAkF,UAAU;AAC5F;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,yCAAyC,GAAG;AAC5C;AACA;AACA,iEAAiE,uEAAuE;AACxI,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,OAAO;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,yDAAyD;AACzD,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2BAA2B;AAC3B;AACA,mBAAmB;AACnB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,sFAAsF,+BAA+B;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wBAAwB;AACtD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iGAAiG;AACjG;AACA;AACA;AACA,2CAA2C,mEAAmE;AAC9G,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,qDAAqD,0BAA0B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,8CAA8C,sBAAsB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,0CAA0C;AAC3G;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA,+BAA+B,6EAA6E;AAC5G,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,gCAAgC;AACnG,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,YAAY;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,4CAA4C;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,4CAA4C;AACjH;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,2DAA2D;AACjH,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA,+CAA+C,YAAY;AAC3D;AACA,SAAS;AACT;AACA,qCAAqC,YAAY;AACjD;AACA;AACA,aAAa,6CAA6C,eAAe;AACzE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B;AAC/B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD,yCAAyC,uCAAuC,GAAG;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,2BAA2B;AACzF;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC,oCAAoC;AACvE;AACA,SAAS;AACT;;AAEA;AACA,sCAAsC,YAAY;AAClD;;AAEA;AACA,sCAAsC,eAAe;AACrD;;AAEA;AACA,sCAAsC,uBAAuB;AAC7D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,sCAAsC,kBAAkB;;AAExD;;AAEA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClzLA;AACA;AACA;AACqC;AACrC;AACA,oEAAoE,2CAAM;AAC1E,IAAI,kDAAa;AACjB,+EAA+E,kDAAa,EAAE,MAAM,aAAa;AACjH;AACA,QAAQ;AACR,kEAAkE;AAEA;AAClE,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACb4C;AAC1D;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+EAAkB;AACtB;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9HqV;AAC/S;AACtC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,aAAa;AACb,eAAe;AACf,cAAc;AACd,mBAAmB;AACnB,kBAAkB;AAClB,yBAAyB;AACzB,yBAAyB;AACzB,0BAA0B;AAC1B,wBAAwB;AACxB,kBAAkB;AAClB,mBAAmB;AACnB,eAAe;AACf,wBAAwB;AACxB,yCAAyC;AACzC,qBAAqB;AACrB,iBAAiB;AACjB;AACA;;;;;;;;;;;;;;;;;;;AC3CyF;AACxB;AAC1D,yGAAyG,QAAQ,8FAA8F,IAAI;AAC1N;AACO;AACP;AACA,oBAAoB,iFAAwB;AAC5C;AACA;AACA;AACO;AACP,WAAW,6EAAoB,iBAAiB,yEAA2B;AAC3E;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbgD;AACwB;AAClB;AACpB;AACR;AACS;AAC5B;AACP,qBAAqB,6DAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6BAA6B,mEAAY;AACzC,WAAW,gEAAiB;AAC5B;AACO;AACP;AACA,WAAW,8DAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACO;AACP,eAAe,8DAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CmS;AAC/P;AACpC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY;AACZ,YAAY;AACZ,YAAY;AACZ,YAAY;AACZ,aAAa;AACb,WAAW;AACX,mBAAmB;AACnB,mBAAmB;AACnB,YAAY;AACZ,WAAW;AACX,qBAAqB;AACrB,eAAe;AACf,wBAAwB;AACxB,sBAAsB;AACtB,uBAAuB;AACvB,qBAAqB;AACrB,eAAe;AACf,gBAAgB;AAChB;AACO;AACP,OAAO,wDAAQ;AACf,OAAO,wDAAQ;AACf,OAAO,wDAAQ;AACf,OAAO,wDAAQ;AACf,OAAO,yDAAS;AAChB,OAAO,uDAAO;AACd,OAAO,+DAAe;AACtB,OAAO,+DAAe;AACtB,OAAO,wDAAQ;AACf,OAAO,uDAAO;AACd,QAAQ,iEAAiB;AACzB,QAAQ,2DAAW;AACnB,QAAQ,oEAAoB;AAC5B,QAAQ,kEAAkB;AAC1B,QAAQ,mEAAmB;AAC3B,QAAQ,iEAAiB;AACzB,QAAQ,2DAAW;AACnB,QAAQ,4DAAY;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzFsD;AAC/C;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA,2BAA2B,qDAAW;AACtC,0BAA0B,qDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,qDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iBAAiB,qDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iBAAiB,qDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvKO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,2BAA2B;AAC3B;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACzIa;;AAEb;;;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,UAAU;AAC/B;;AAEA,qBAAqB,UAAU;AAC/B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC7CY;;AAEZ,QAAQ,kGAAkG,EAAE,mBAAO,CAAC,yDAAa;AACjI,gBAAgB,mBAAO,CAAC,6DAAe;;AAEvC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,gBAAgB;AAC5D;AACA,+BAA+B,wCAAwC;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+EAA+E,8BAA8B;AAC7G,IAAI;AACJ,+DAA+D,8BAA8B;AAC7F;;AAEA;AACA;AACA,+EAA+E,8BAA8B;AAC7G,IAAI;AACJ,+DAA+D,8BAA8B;AAC7F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,aAAa,8BAA8B,QAAQ;;AAElF;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAsB;AACtB,sBAAsB;;;;;;;;;;;AC9SV;;AAEZ,2BAA2B,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,GAAG;AAC1E,mCAAmC,KAAK,sBAAsB,aAAa,EAAE;;AAE7E;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,GAAG,iCAAiC;AACpE;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,OAAO,GAAG,mBAAmB;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,mBAAmB,GAAG,IAAI;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3LY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC7BY;;AAEZ,QAAQ,MAAM,EAAE,mBAAO,CAAC,iEAAe;;AAEvC,8CAA8C,EAAE,gBAAgB,EAAE,wBAAwB,EAAE;;AAE5F;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA,aAAa;AACb,IAAI;AACJ,aAAa;AACb;AACA;;AAEA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,wBAAwB;AACxB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,IAAI;AACJ,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,mBAAmB,oBAAoB;AACvC,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnPa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxFgB;AACc;AACsB;AACpD;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAW;AAC/B;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,eAAe,2CAAI;AACnB;AACA;AACA,eAAe,iDAAc,uBAAuB,4CAAS;AAC7D;AACA,SAAS,8CAAO;AAChB;AACA;AACA;AACA,qBAAqB,kDAAW;AAChC,QAAQ,6CAAM;AACd;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAc,wBAAwB,4CAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;;;;;;;;AC3Cc;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,sBAAsB;AACtB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK;AACb;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6CAAM;AACV,MAAM,iDAAU,QAAQ,iDAAU;AAClC,UAAU,KAAK;AACf;AACA;AACA,IAAI,6CAAM;AACV;AACA,SAAS,MAAM,sBAAsB,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2CAA2C;AACrD;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAU;AACjC;AACA;AACA;AACA,MAAM,+CAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA;AACA;AACA;AACA,MAAM,6CAAM,CAAC,0CAAG,2CAA2C,KAAK;AAChE;AACA,MAAM;AACN;AACA;AACA,+BAA+B,8CAAO;AACtC;AACA,MAAM,8CAAO;AACb;AACA;AACA,MAAM,+CAAQ;AACd;AACA;AACA;AACA,UAAU,iDAAU;AACpB,QAAQ,6CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,6CAAM,oCAAoC,SAAS;AACrD,OAAO,8CAAO;AACd;AACA;AACA;AACA,EAAE,6CAAM,CAAC,8CAAO,8CAA8C,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAAG;AACd;AACA;AACA,YAAY,8CAAO;AACnB;AACA;AACA,gBAAgB,+CAAQ;AACxB;AACA;AACA,iBAAiB,4CAAK;AACtB;AACA;AACA,UAAU,SAAS,+CAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,eAAe,4CAAK;AACpB,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWE;;;;;;;;;;;;;;;;;;;;;;ACnVc;AACsB;AACc;AACI;AACN;AACA;AACV;AACxC,oBAAoB,KAAK,oEAAO,qEAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAAI;AACvB;AACA,eAAe,iDAAc,+BAA+B,4CAAS;AACrE;AACA,UAAU,0CAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAQ;AAC7B;AACA,eAAe,iDAAc,gCAAgC,4CAAS;AACtE;AACA;AACA;AACA;AACA,qBAAqB,2CAAI;AACzB;AACA,WAAW,6CAAM;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;;AChJ2C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,cAAc;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,mBAAmB;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB;AACA,eAAe,eAAe;AAC9B;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAS,8CAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,gBAAgB,6CAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD,MAAM;AACN,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,eAAe,SAAS;AACxB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjPe;AACgB;AAqBhB;AACjB;AACA;AACA,mBAAmB;AACnB;AACA;AACA,kBAAkB,8CAAO;AACzB,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mDAAY;AAC7B;AACA;AACA;AACA;AACA,MAAM,8CAAO;AACb,MAAM,4CAAK,OAAO,4CAAK;AACvB,MAAM,8CAAO;AACb,yBAAyB,8CAAO,WAAW,8CAAO,gCAAgC,8CAAO;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4CAAK;AACX,SAAS,mDAAY,EAAE,kDAAW;AAClC;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA,SAAS,kDAAW;AACpB;AACA;AACA;AACA;AACA,cAAc,kDAAW;AACzB,uBAAuB,+CAAQ,OAAO,6CAAM;AAC5C,4BAA4B,8CAAO;AACnC;AACA;AACA,OAAO,8CAAO,aAAa,8CAAO;AAClC;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAQ;AAChB;AACA,MAAM,SAAS,+CAAQ;AACvB;AACA,MAAM;AACN,mCAAmC,8CAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iDAAU;AACnB;AACA;AACA,MAAM,8CAAO,QAAQ,8CAAO;AAC5B;AACA;AACA;AACA,mBAAmB;AACnB,yBAAyB,SAAS;AAClC;AACA,sBAAsB,yCAAK;AAC3B,oCAAoC,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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,sCAAsC,EAAE,IAAI;AACtD,UAAU,sCAAsC,EAAE,IAAI;AACtD,UAAU,kDAAkD;AAC5D,UAAU,yDAAyD;AACnE,UAAU,oDAAoD;AAC9D,UAAU,gDAAgD;AAC1D,UAAU,mDAAmD;AAC7D,UAAU,6CAA6C,EAAE,IAAI;AAC7D,UAAU,4CAA4C;AACtD,UAAU,uDAAuD;AACjE,UAAU,0DAA0D;AACpE;AACA;AACA;AACA;AACA,GAAG;AACH,UAAU,kDAAkD,EAAE;AAC9D;AACA,CAAC;AACD;AACA;AACA,MAAM,4CAAK;AACX;AACA;AACA,4DAA4D,iBAAiB;AAC7E,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA,cAAc,6CAAU,cAAc,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,6CAAM;AACZ,YAAY,mDAAY;AACxB,MAAM,6CAAM;AACZ,MAAM,+CAAQ;AACd;AACA,iBAAiB,6CAAM;AACvB;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgCE;;;;;;;;;;;;;;;;;ACjO2C;AACP;AACtC;AACA,eAAe,mDAAY;AAC3B,SAAS,kDAAO;AAChB;AAGE;;;;;;;;;;;;;;;;;ACR2C;AAWxB;AACrB;AACA,UAAU,kDAAkD,EAAE,mDAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAa;AACpC,EAAE,qDAAU;AACZ,EAAE,qDAAU;AACZ;AACA;AACA,aAAa,uDAAY;AACzB;AACA,aAAa,0DAAe;AAC5B;AACA,aAAa,wDAAa;AAC1B;AACA,aAAa,uDAAY;AACzB;AACA,aAAa,sDAAW;AACxB;AACA,aAAa,uDAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yDAAkB;AAC1D;AACA;AACA;AACA,wCAAwC,yDAAkB;AAC1D;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;ACrD2C;AAMxB;AACrB;AACA;AACA,4BAA4B,qDAAU;AACtC;AACA;AACA,eAAe,mDAAY;AAC3B,uBAAuB,wDAAa;AACpC,eAAe,yDAAkB,4BAA4B,QAAQ;AACrE,6BAA6B,yDAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,uDAAgB;AACvE,8CAA8C,uDAAgB;AAC9D;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;;AClD2C;AACW;AAOnC;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,EAAE;AAC5B,GAAG;AACH;AACA;AACA;AACA,eAAe,mDAAY;AAC3B,+BAA+B,kDAAW;AAC1C;AACA;AACA,MAAM,4CAAK;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA,kBAAkB,qDA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AC3B,YAAY,2CAAQ;AACpB;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;AChB2C;AACa;AAC1D;AACA,eAAe,mDAAY;AAC3B,EAAE,6CAAM;AACR,IAAI,8CAAO,qBAAqB,0CAAO;AACvC;AACA;AACA,cAAc,2CAAQ;AACtB;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;ACxB2C;AACwB;AACrE;AACA,eAAe,mDAAY;AAC3B,MAAM,4CAAK;AACX,EAAE,6CAAM;AACR,IAAI,8CAAO,qBAAqB,0CAAO;AACvC;AACA;AACA,SAAS,mDAAY;AACrB;AAGE;;;;;;;;;;;;;;;;;ACb2C;AACa;AAC1D;AACA,eAAe,mDAAY;AAC3B,EAAE,6CAAM;AACR,IAAI,8CAAO,qBAAqB,0CAAO;AACvC;AACA;AACA;AACA;AACA,cAAc,2CAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;ACtB2C;AAC2B;AACxE;AACA,eAAe,mDAAY;AAC3B,MAAM,4CAAK;AACX,EAAE,6CAAM,CAAC,8CAAO;AAChB,gBAAgB,wCAAK;AACrB,SAAS,6CAAM,CAAC,8CAAO;AACvB;AAGE;;;;;;;;;;;;;;;;;;ACX2C;AACW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mDAAY;AAC1B;AACA,MAAM,4CAAK;AACX,qBAAqB,4CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mDAAY;AAC1B,OAAO,+CAAQ;AACf;AACA;AACA,IAAI,6CAAM;AACV;AACA;AACA;AACA,IAAI,6CAAM;AACV;AACA;A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AY;AAC9B,UAAU,4CAAK,SAAS,8CAAO,oBAAoB,8CAAO;AAC1D,QAAQ,6CAAM;AACd,WAAW,4CAAK;AAChB;AACA;AACA;AACA,QAAQ;AACR,QAAQ,6CAAM;AACd,UAAU,8CAAO,qBAAqB,8CAAO;AAC7C;AACA;AACA,sBAAsB,sDAAe;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA,SAAS,4CAAK;AACd,IAAI,6CAAM;AACV;AACA;AACA;AACA,WAAW,2CAAI;AACf;AACA,WAAW,mDAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS,2CAAI;AACb;AACA;AACA,GAAG;AACH;AAGE;;;;;;;;;;;;;;;;;;ACzEwC;AACR;AASd;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,wCAAwC,SAAS;AACjD,EAAE,6CAAM;AACR;AACA,uEAAuE,YAAY;AACnF;AACA;AACA,IAAI,6CAAM;AACV;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mDAAY;AAC1B,IAAI,6CAAM;AACV,sBAAsB,+CAAQ;AAC9B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,QAAQ,4CAAK;AACb,QAAQ,4CAAK;AACb,WAAW,8CAAO;AAClB,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2CAAI;AACb,4BAA4B;AAC5B,YAAY,yBAAyB;AACrC;AACA,sBAAsB,mDAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,8CAAO;AACjB;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,8CAAO;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI,6CAAM;AACV,MAAM,4CAAK,SAAS,4CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,6CAAM;AACR;AACA;AACA;AACA,YAAY,sDAAe;AAC3B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6CAAM,4BAA4B,KAAK,IAAI,IAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;ACnrBgC;AACqB;AACvD;AACA,EAAE,6CAAM;AACR,IAAI,+CAAQ,WAAW,8CAAO;AAC9B;AACA;AACA,SAAS,2CAAI;AACb;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;;;;;ACf0C;AACF;AACD;AAWrB;AACkC;AACvB;AAC/B,qCAAqC;AACrC;AACA,UAAU,qBAAqB;AAC/B;AACA,IAAI,6CAAM,CAAC,8CAAU;AACrB,IAAI,6CAAM;AACV;AACA;AACA;AACA,IAAI;AACJ,IAAI,6CAAM;AACV,MAAM,+CAAQ;AACd;AACA;AACA;AACA,MAAM,8CAAO;AACb,IAAI,6CAAM;AACV;AACA;AACA;AACA,IAAI,6CAAM;AACV,oBAAoB,2CAAQ,kBAAkB,yCAAM;AACpD;AACA;AACA,IAAI,6CAAM;AACV,2BAA2B,2CAAQ;AACnC;AACA;AACA;AACA;AACA,IAAI,6CAAM;AACV,MAAM,8CAAO;AACb;AACA;AACA;AACA,eAAe,4CAAK,eAAe,iBAAiB;AACpD,qBAAqB,iDAAc;AACnC;AACA,WAAW,+CAAQ,yBAAyB,kEAAQ;AACpD;AACA,QAAQ,sCAAsC;AAC9C;AACA;AACA;AACA,gCAAgC,8CAAU;AAC1C;AACA,cAAc,8CAAO;AACrB,QAAQ,4CAAK;AACb,QAAQ,+CAAQ;AAChB,MAAM,6CAAM;AACZ;AACA;AACA;AACA,MAAM,SAAS,6CAAM;AACrB,MAAM,6CAAM;AACZ;AACA;AACA;AACA,MAAM;AACN,MAAM,6CAAM;AACZ;AACA;AACA;AACA;AACA,4BAA4B,2CAAI;AAChC;AACA;AACA,QAAQ,4CAAK;AACb;AACA,aAAa;AACb,GAAG;AACH,8BAA8B,2CAAQ;AACtC;AACA;AACA,yBAAyB,8CAAO;AAChC;AACA;AACA;AACA;AACA;AACA,0BAA0B,2CAAI;AAC9B;AACA;AACA;AACA,QAAQ,8CAAO;AACf;AACA,eAAe,8CAAO;AACtB;AACA,MAAM,6CAAM;AACZ,2BAA2B,2CAAQ;AACnC;AACA;AACA;AACA,IAAI,6CAAM,CAAC,+CAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,aAAa;AACb,GAAG;AACH,+BAA+B,6CAAM;AACrC;AACA;AACA,6BAA6B,2CAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,SAAS;AACT,iBAAiB;AACjB;AACA;AACA,MAAM;AACN,aAAa;AACb,GAAG;AACH,SAAS,6CAAM;AACf;AAGE;;;;;;;;;;;;;;;;;ACtL4C;AACF;AAC5C;AACA;AACA;AACA;AACA,iBAAiB,mDAAU;AAC3B;AACA,wBAAwB,iDAAc;AACtC,OAAO;AACP;AACA;AACA,GAAG;AACH;AAGE;;;;;;;;;;;;;;;;;;;;;;AChBuC;AACU;AACQ;AACR;AACZ;AACE;AACY;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AACA,eAAe;AACf,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6CAAU;AACxD;AACA;AACA;AACA,gBAAgB,kDAAW;AAC3B,iBAAiB,kDAAW;AAC5B,SAAS;AACT;AACA;AACA;AACA;AACA,MAAM,6CAAM;AACZ;AACA,WAAW,gCAAgC,GAAG,iCAAiC;AAC/E;AACA,MAAM,6CAAM;AACZ;AACA,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA;AACA,qBAAqB,2CAAI;AACzB;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA,eAAe,sDAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2CAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,wBAAwB,+CAAQ;AAChC,wBAAwB,+CAAQ;AAChC,gBAAgB;AAChB;AACA,wBAAwB,+CAAQ;AAChC,wBAAwB,+CAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,6CAAM;AACjB,GAAG;AACH;AAGE;;;;;;;;;;;;;;;AC9LF;AACA;AACA;AAGE;;;;;;;;;;;;;;;;ACGkB;AACpB;AACA,MAAM,8CAAO,eAAe,+CAAQ;AACpC,YAAY,0CAAO;AACnB;AACA,MAAM,+CAAQ,mBAAmB,+CAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAO;AAC5B;AACA,iBAAiB,8CAAO;AACxB;A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AAGE;;;;;;;;;;;;;;;;;ACZqC;AACS;AAChD;AACA,EAAE,6CAAM;AACR,IAAI,8CAAO;AACX;AACA;AACA,wCAAwC,yCAAK;AAC7C;AACA;AAGE;;;;;;;;;;;;;;;;;;;;;;ACZoB;AACA;AACA;AACD;;;;;;;;;;;;;;;;;ACH2B;AACrB;AAC3B;AACA,EAAE,6CAAM;AACR,IAAI,8CAAO;AACX;AACA;AACA,YAAY,wCAAG;AACf;AACA;AAGE;;;;;;;;;;;;;;;;;ACZqC;AACG;AAC1C;AACA;AACA,uBAAuB,gDAAS;AAChC,oBAAoB,yCAAK;AACzB;AACA;AAGE;;;;;;;;;;;;;;;;;ACVqC;AACS;AAChD;AACA,EAAE,6CAAM,CAAC,8CAAO;AAChB,wCAAwC,yCAAK;AAC7C;AACA;AAGE;;;;;;;;;;;;;;;;;;;;;ACTwD;AACnB;AACuB;AACV;AACpD;AACA,QAAQ,qEAAc;AACtB,OAAO,qEAAc;AACrB,QAAQ,qEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,+DAAW;AAClB;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAK;AAC1B,qBAAqB,8CAAO;AAC5B;AACA;AACA;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAO;AACnB;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAU;AAC1B;AACA;AACA;AACA;AACA;AAKE;;;;;;;;;;;;;;;;;;AC3EoC;AACC;AACA;AACvC;AACA;AACA,SAAS,mDAAQ;AACjB;AACA;AACA;AACA;AACA,qBAAqB,mDAAK;AAC1B;AACA;AACA;AACA,4BAA4B,+CAAQ;AACpC;AACA;AACA;AACA;AACA,6CAA6C,+CAAQ;AACrD;AACA;AACA;AACA,8CAA8C,+CAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;;AC/CiC;AACS;AACL;AACvC;AACA,SAAS,mDAAQ;AACjB;AACA;AACA;AACA,qBAAqB,wDAAK;AAC1B,sBAAsB,mBAAmB;AACzC,YAAY,4CAAK;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;;ACnBgD;AAChB;AAC0C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAS;AAC/B,oBAAoB,kDAAW;AAC/B;AACA;AACA;AACA;AACA,IAAI,6CAAM;AACV,MAAM,+CAAQ;AACd,2CAA2C,gCAAgC;AAC3E;AACA;AACA;AACA;AACA,QAAQ,6CAAM;AACd;AACA;AACA;AACA,uCAAuC,aAAa;AACpD,QAAQ;AACR;AACA,QAAQ;AACR,QAAQ,6CAAM,EAAE,iDAAU,wCAAwC,MAAM;AACxE;AACA,UAAU,gDAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kDAAW;AAC5B,IAAI,6CAAM,mCAAmC,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,2CAAM;AACrB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AAGE;;;;;;;;;;;;;;;AC5FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB,EAAE,GAAG,sBAAsB,cAAc;AAC/E;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe,IAAI;AACjD;AACA;AACA,sDAAsD;AACtD;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AA0CE;;;;;;;;;;;;;;;;;AC5jBF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;ACrEA;AACA;AACA;;AAEwC;AAC4C;;AAEpF;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sDAAM;AAC1D;AACA;AACA,QAAQ,kFAAyB;AACjC;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,sEAAa;AACnB;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5I8D;AAC0E;AACvF;;AAEjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,QAAQ,kFAAyB;AACjC;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0EAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8EAAY;AACrB;AACA;AACA;AACA,aAAa,kFAAyB;AACtC;AACA,GAAG;AACH;AACA;AACA;AACA,aAAa,kFAAyB;AACtC;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAY;AAC1C;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA,2BAA2B,4EAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA,4BAA4B,4EAAmB;AAC/C,WAAW;AACX;AACA,OAAO;AACP;AACA,QAAQ,kFAAyB;AACjC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC3NiE;AACY;AACQ;AACU;AACxF;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACO;AACA;AACP,SAAS,2EAAkB;AAC3B;AACA,+BAA+B,wEAAmB,oCAAoC,8DAAK;AAC3F;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAAc;AACtC,2BAA2B,uEAAc;AACzC;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA,2BAA2B,0FAAqC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oEAAmB;AACxC;AACA;AACA,MAAM;AACN;AACA,MAAM,0DAAS;AACf;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvGA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACzHuF;AACiE;AACtE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uEAAc;AACpB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,8DAAK;AACf,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA,sBAAsB,+FAAwC;AAC9D;AACA;AACA,kBAAkB,0EAAiB;AACnC;AACA,KAAK;;AAEL;AACA;AACA;AACA,kBAAkB,0EAAiB;AACnC,uBAAuB,sEAAwB;AAC/C;AACA;AACA,iBAAiB,2EAAkB;AACnC;AACA;AACA;AACA;AACA;AACA,wCAAwC,uEAAc;AACtD,UAAU,uEAAc;AACxB,SAAS;AACT,QAAQ;AACR;AACA,sBAAsB,0EAA4B;AAClD;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA,sBAAsB,kFAAyB;AAC/C;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,6BAA6B,4EAAmB;AAChD;AACA,iBAAiB,4EAAmB;AACpC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AChCuD;AACa;AACqC;AAClD;;AAEvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2EAAkB;AAC1C;AACA,WAAW,2EAAkB;AAC7B;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,0BAA0B,iFAA2B;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uFAA8B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAS;AACvB,mBAAmB,kEAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iDAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAc,8BAA8B,sDAAM;AAC9D;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,0CAA0C,mDAAG,8EAA8E,wDAAQ;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG,mDAAG;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACvNA;AACA;AACA;AACA;AACA;AAC0C;AAC8B;AAC5B;AACU;AACJ;AACD;AACE;AACQ;;AAE3D;AACA;AACA;AACA;AACA,YAAY,mDAAQ;AACpB,cAAc,0DAAmB;AACjC,WAAW,qDAAW;AACtB,gBAAgB,+DAAgB;AAChC,cAAc,2DAAc;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP,EAAE,yDAAc;AAChB;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,4DAAc;AACxB;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB,0DAAY;AAC9B;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK;AACb;AACA;AACA,QAAQ,4CAAK;AACb;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;;ACvF+C;AACI;AAC5C;AACP;AACA;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,+DAAc;AAC/E;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;;;;ACtC+C;AACyC;AACjF;AACP;AACA,UAAU,wDAAU;AACpB;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAU;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA,UAAU,wDAAU;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA,UAAU,wDAAU;AACpB;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,iFAA2B;AAC/C;AACA;AACA,wBAAwB,oEAAc;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvH+D;AACN;;AAEzD;AACA;AACA,YAAY,iBAAiB;AAC7B;AACO;AACP;AACA;AACA,UAAU,4DAAc;AACxB;AACA,KAAK;AACL;AACA,yBAAyB,kEAAmB;;AAE5C;AACA;AACA,UAAU,wDAAU;AACpB;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,UAAU,4DAAc;AACxB;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;;;ACrC+D;AACuB;;AAEtF;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAc;AAC1B;AACA,OAAO;AACP;AACA;AACA,YAAY,4DAAc;AAC1B;AACA,OAAO;AACP;AACA;AACA,YAAY,4DAAc;AAC1B;AACA;AACA,OAAO;AACP;AACA,QAAQ,6EAAsB,kBAAkB,2EAAoB;AACpE,YAAY,wDAAU;AACtB;AACA,OAAO;AACP;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL,GAAG;AACH;AACA;;;;;;;;;;;;;;;;;;;;;;AC9C+D;AACE;AACT;;AAExD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,UAAU,4DAAc;AACxB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,4DAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA,UAAU,wDAAU;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA,2BAA2B,kEAAiB;AAC5C;AACA,UAAU,wDAAU;AACpB;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,0DAAS;AAChE;AACA,YAAY,wDAAU;AACtB;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wDAAU;AACxB;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACO;AACP,sBAAsB,iEAAY;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,4DAAc;AAC1B;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC7KA;AACA;AACA;AACA;AAC+C;AACgD;AAC0B;AAC3D;;AAE9D;AACA;AACA;AACA;AACA,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAU;AACpB;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACO;AACP,oBAAoB,iFAA2B;AAC/C;AACA;;AAEA;AACA;AACA,YAAY,wDAAU;AACtB;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA,OAAO;AACP;;AAEA;AACA;AACA,YAAY,wDAAU;AACtB;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,wDAAU;AAC1B;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA,eAAe;AACf;AACA;AACA;AACA,kBAAkB,wDAAU;AAC5B;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,wDAAU;AACxB;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,wDAAU;AACxB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wDAAU;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA,OAAO;AACP;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,wBAAwB,2EAAqB;AAC7C;AACA;AACA,uBAAuB,2EAAqB;AAC5C;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iFAA2B;AAC/C;AACA;AACA,UAAU,wDAAU;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,UAAU,wDAAU;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,SAAS,iEAAQ;AACjB;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACO;AACP;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;AACA;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;;AAEA;AACA;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;;AAEA;AACA;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wDAAU;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc,wDAAU;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc,wDAAU;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc,wDAAU;AACxB;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,QAAQ,2EAAoB;AAC5B,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA,SAAS,6EAAoB;AAC7B,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,cAAc,wDAAU;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,kBAAkB,wDAAU;AAC5B;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6EAAoB;AAC7C;AACA,yBAAyB,2EAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,2EAAqB;AACzF;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,kBAAkB,wDAAU;AAC5B;AACA;AACA;AACA,aAAa;AACb;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,cAAc,sEAAa;AAC3B;AACA;AACA,iBAAiB;AACjB;AACA,GAAG;AACH;AACA;AACA,gBAAgB,oEAAW;AAC3B;AACA,GAAG;AACH;AACA,0CAA0C;AAC1C,+CAA+C;AAC/C,UAAU,wDAAU;AACpB,aAAa,iEAAQ;AACrB;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,QAAQ,6EAAoB;AAC5B,MAAM,sEAAa;AACnB,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA,yDAAyD;AACzD,oBAAoB,oEAAW,wBAAwB;AACvD;AACA,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,UAAU,wDAAU;AACpB;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oEAAW;AACjC;AACA,cAAc,wDAAU;AACxB;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;ACtdqF;AACrF;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,+DAAc;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,yDAAY;AACpF;AACA,eAAe,mEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtF0D;AACJ;AAC4B;;AAElF;AACA;AACA;AACA;AACO;AACP;AACA,6BAA6B,+DAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA,6BAA6B,2DAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,4EAA2B,CAAC,0DAAa;AACjE;AACA;AACO;AACP;AACA;AACA;AACA,yDAAyD,0DAAa;AACtE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;;AAEyE;AAClE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,oBAAoB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oKAAoK;AACpK,yMAAyM;AACzM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,iFAA4B;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4JAA4J;AAC5J;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpPqD;AACL;AAC0B;AACC;AACsB;AAClB;AAChC;AACW;AACkB;AACV;AAChC;AACQ;AACT;AACjC;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,SAAS,mEAAU;AACnB;AACO;AACA;AACP;AACA;AACA;AACA,IAAI,+EAAwB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,8DAAc;AACzB;AACA;AACA;AACA,yBAAyB,8DAAc;AACvC;AACA;AACA,GAAG;AACH;AACA;AACA,aAAa,yDAAW;AACxB,KAAK;AACL;AACA;AACA;AACA,gBAAgB,wDAAU;AAC1B;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,QAAQ,mFAAyB;AACjC;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,mFAAyB;AACjC,QAAQ,sEAAuB;AAC/B;AACA,gBAAgB,wDAAU;AAC1B;AACA,WAAW;AACX;AACA;AACA,gBAAgB,wDAAU;AAC1B;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,yEAAqB;AAC7B;AACA,KAAK;AACL;AACA;AACA,QAAQ,+DAAc;AACtB;AACA,KAAK;AACL;AACA;AACA,QAAQ,2DAAU;AAClB;AACA,KAAK;AACL;AACA;AACA,QAAQ,gEAAe;AACvB;AACA,KAAK;AACL;AACA;AACA,QAAQ,kEAAc;AACtB;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ,8DAAe;AACvB,QAAQ,8DAAe;AACvB,QAAQ,8DAAe;;AAEvB;AACA;AACA,UAAU,wFAAwB;AAClC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5I+D;AACD;AACF;;AAE5D;AACA;AACA;AACA;AACA;AACO;AACP,MAAM,2EAAoB;AAC1B,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,qEAAY;AAClB;AACA,YAAY,wDAAU;AACtB;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA,UAAU,4DAAc;AACxB;AACA,KAAK;AACL;;AAEA;AACA,MAAM,qEAAY;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAU;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AChFA;AACA;AACA;;AAEyD;AACyD;AACrC;AAC7E;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP,SAAS,mEAAkB,8DAA8D,uEAAoB;AAC7G;;AAEA;AACA;AACA;AACO;AACP,yBAAyB,0FAA4B;;AAErD;AACA;AACA;AACA;AACA;AACA,IAAI,6FAA+B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA,WAAW,iEAAoB;AAC/B,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACrF+B;AACkG;AAG1F;AACvC,WAAW,0DAAK;AAC+B;AAC/C;AACA;AACA;AACA;AACO;AACP;AACO;;AAEP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAO;AAC9B,0BAA0B,yCAAO;AACjC,uBAAuB,yCAAO;AAC9B,wBAAwB,yCAAO;AAC/B,qBAAqB,yCAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,oEAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAc;AACtB;AACA;AACA;AACA;AACA,0BAA0B,uEAAc;AACxC;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,mCAAmC,oEAAW;AAC9C;AACA;AACA,8BAA8B,uEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA,8BAA8B,wDAAU;AACxC;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,eAAe;AACf;AACA;AACA,yBAAyB,0EAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ,uEAAc;AACtB;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,UAAU,wDAAU;AACpB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjM6E;AAC/B;AAC8C;AACE;AACvB;AACP;AAC4B;AAC7C;AACxC;AACP;AACA,EAAE,uDAAW,CAAC,+EAAwB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,oEAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sDAAsD,4CAAM;AAC5D;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,wDAAwD,4CAAM;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4EAAyB;AACzD;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,uBAAuB,wDAAU;AACjC;AACA,OAAO;AACP;AACA;AACA,yBAAyB,8EAA2B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,oFAAoF,4CAAM;AAC1F,4DAA4D,4CAAM,8BAA8B,4CAAM;AACtG;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN,yBAAyB,4EAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,+BAA+B,4EAAyB;AACxD;AACA,6CAA6C,uEAAc;AAC3D;AACA,aAAa;AACb;AACA,WAAW;AACX,yDAAyD,4CAAM,gDAAgD,yCAAG;AAClH,SAAS;AACT,6CAA6C;AAC7C;AACA,+BAA+B,4EAAyB;AACxD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,iDAAe;AAC1C;AACA;AACA,sBAAsB,0CAAO;AAC7B;AACA;AACA;AACA;AACA,oCAAoC,sGAAqC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2EAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,qDAAc,uBAAuB,4CAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACkC;AACG;AACJ;AAClC;AACA;AACoD;AACpD;;;;;;;;;;;;;;;;;;;AC9MiF;AACD;AACzE;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI,QAAQ,uKAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAW;AACvB,iCAAiC,yFAAyB;AAC1D;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4DAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAkB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/ImD;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,sBAAsB,oDAAc,wBAAwB,4CAAM,wBAAwB,4CAAM,oCAAoC,yCAAG;AACvI;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;;AAEiF;AACV;AAC8H;AACmB;AACzK;AAC6G;AAChC;AAC9E;AACa;AACN;AACA;AAC9C;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAO;AAC3B;AACA,gBAAgB,yCAAO;AACvB;AACA,iBAAiB,yCAAO;AACxB;AACA,oBAAoB,iDAAe;AACnC;AACA,kBAAkB,iDAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kGAAkC,oCAAoC,oEAAa;AAClH;AACA;AACA;AACA;AACA,KAAK;AACL,4BAA4B,2EAAkB;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kFAA0B;AAChC;;AAEA;AACA,8EAA8E,oEAAgB;AAC9F,8EAA8E,oEAAgB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,0DAAY;AAC3B,KAAK,GAAG,+FAA+B;AACvC;AACA,oCAAoC,0FAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,4CAAM,qBAAqB,+CAAQ;AACvG;AACA;AACA;AACA,sBAAsB,mEAAS;AAC/B,4BAA4B,6EAAqB;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,8BAA8B,yDAAU;AACxC;AACA,wBAAwB,iEAAO,gBAAgB,0EAAgB;AAC/D;AACA,eAAe;AACf;AACA,oBAAoB,kEAAU,kBAAkB,wEAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mEAAS;AACnC,gCAAgC,6EAAqB;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAmB;AACnC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wFAAgC;AACrE;AACA,yCAAyC,wFAAgC;AACzE;AACA;AACA;AACA,WAAW;AACX,6CAA6C,yEAAmB;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAU;AAChC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd,+CAA+C,yDAAU;AACzD;AACA,wBAAwB,iEAAO,gBAAgB,0EAAgB;AAC/D;AACA,eAAe;AACf;AACA,oBAAoB,kEAAU,kBAAkB,wEAAc;AAC9D;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAmB;AACnC;AACA;AACA,WAAW;AACX,0BAA0B,6EAAqB,qCAAqC,wEAAc;AAClG;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK,GAAG,oDAAa;AACrB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,oGAAoC;AAChD,YAAY,+FAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA,IAAI,wEAAc;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oGAAoC,CAAC,wEAAc;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oGAAoC,CAAC,wEAAc;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+FAA+B,CAAC,wEAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAqB;AAClC;AACA,2CAA2C,mEAAS;AACpD;AACA,YAAY,0FAA0B;AACtC;AACA;AACA,oBAAoB,wEAAc,2DAA2D,wEAAc;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wEAAc;AACxB;AACA;AACA,UAAU,oGAAoC;AAC9C;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,EAAE,wDAAW,CAAC,gFAAwB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,yDAAU;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uGAAuG,0EAAoB;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;;;;;;;;ACjcyD;AACuB;AAChF;AACO;AACA;AACP;AACA;AACA,IAAI;AACJ,UAAU,kEAAS;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iBAAiB,kEAAS;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,yFAAmC;AAC7D;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrF8B;AACoF;AACnB;AACxF;AACA;AACA;AACA;AACP;AACA;AACO;AACP;AACA,cAAc,mEAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAS;AACjC;AACA,wBAAwB,wCAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,UAAU,0DAAS;AACnB;AACA;AACA,cAAc,4DAAW;AACzB;AACA;AACA,IAAI,4DAAW;AACf,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA,MAAM,0DAAS;AACf;AACA;AACA,cAAc,4DAAW;AACzB;AACA,IAAI,4DAAW;AACf,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iFAA2B;AAC9C;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,wDAAO;AAC3B;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH,2FAA2F;;AAE3F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAO;AACxB;AACA;AACA;AACA;AACA;AACA,sBAAsB,2EAAqB;AAC3C;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,SAAS,4DAAW;AACpB;AACA;;;;;;;;;;;;;;;;;;;;AChP8D;AACgB;AAC8B;AACrG;AACP,YAAY,wDAAS;AACrB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,6BAA6B,wDAAS;AACtC;AACA,IAAI;AACJ;AACA;AACA;AACO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oEAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,mEAAqB;AACpD;AACA;AACA,mDAAmD,8EAA4B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oEAAkB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,yBAAyB,sEAAiB;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mEAAqB;AACpD;AACA;AACA,mDAAmD,8EAA4B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtJ0D;AACkB;AACS;AACvB;AACf;AACxC;AACP;AACA,gBAAgB,mEAAqB;AACrC,uBAAuB,sEAAY;AACnC;AACA;AACA;AACA;AACA,IAAI,8FAAuC;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAU;AAC1B;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,WAAW,yFAA0B;AACrC;AACA;AACA,CAAC;AACM,wCAAwC;AAC/C;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACtC+B;AACyC;AAC2E;AACzF;AACc;AACmB;AACN;AACtC;AAC/C,iBAAiB,oDAAG;AACpB;AACO;AACP;AACA,wBAAwB,yCAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iFAA2B;AAClD;AACA;AACA;AACA;AACA,uCAAuC,+DAAc;AACrD;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wDAAU;AACxB;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2EAAoB;AACtC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,oBAAoB,8EAAuB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,yCAAyC,oEAAkB;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,oEAAkB;AAChC;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,cAAc,oEAAkB;AAChC;AACA,SAAS;AACT,OAAO;AACP;AACA,mGAAmG,oEAAkB;AACrH,KAAK;AACL,kBAAkB,+DAAc;AAChC;AACA,sBAAsB,+DAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAW;AACtC;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,2DAAU;AACrB;AACA;AACA;AACA,yBAAyB,2DAAU;AACnC;AACA;AACA;AACA;AACA,MAAM;AACN,0BAA0B,2DAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,oEAAkB;AAC/B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAY;AACxB,KAAK;AACL;AACA;AACA;AACA,CAAC;AACM;AACP,kBAAkB,sEAAoB;AACtC;AACA,QAAQ,8FAAgC,CAAC,mEAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9NO;AACP;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA,6BAA6B,IAAI;AACjC;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC7J8C;AAC9C;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB;AACzB;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP,YAAY,2DAAS;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;;;;ACtF4C;;AAE5C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kBAAkB,yDAAO;AACzB,GAAG;AACH;AACA,+LAA+L,qBAAqB,sCAAsC,8CAA8C;AACxS;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;ACLO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxBO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACvSO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB;AACzB;;AAEA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP,wBAAwB;;AAExB;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/NO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACO;AACP,wCAAwC;AACxC;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzDsD;AACF;AACO;AACpD;AACA;AACP,wBAAwB,oEAAqB;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAiB,mBAAmB,+DAAiB,gCAAgC,iEAAiB,CAAC,+DAAiB;AAChI;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;ACvGO;AACA;AACP;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;ACJA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACsB;AACkD;AACxE;AACO;AACP;AACA,cAAc,gCAAG;AACjB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACO,gCAAgC,iFAA6B;AACpE;;;;;;;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;;AAEiG;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2EAAkB;AAChC;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACA;;AAEP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,8BAA8B,4DAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;;AAEP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE,iEAAQ;AACV,cAAc,2EAAkB;AAChC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClGiE;AACtB;AACmB;AACvD;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2EAAqB;AAC1C;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;AACA;AACA;AACO;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAAqB;AAC5C;AACA,uBAAuB,8EAAqB;AAC5C;AACA,sBAAsB,8EAAqB;AAC3C;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACvS6E;AACwB;AACyB;AACvH;AACP,wBAAwB,yFAAmC;AAC3D;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,eAAe,iFAAwB;AACvC,cAAc,2EAAkB;AAChC;AACA,kBAAkB,yFAAmC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAgB;AAClD;AACA,2BAA2B,4DAAG;AAC9B,sBAAsB,uEAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yBAAyB,+FAAwC;AACjE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ,oCAAoC,uEAAc;AAClD,0BAA0B,uEAAc;AACxC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9F+F;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,aAAa,kEAAS;AACtB,YAAY,2EAAkB;AAC9B,oBAAoB,kEAAS;AAC7B,KAAK;AACL,4BAA4B,4DAAG;AAC/B,uBAAuB,uEAAc;AACrC;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvCsD;AACqB;AACpE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kEAAS,CAAC,uFAAgC,KAAK,uFAAgC;AAC1F,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBwD;AACZ;AACyD;AACoE;AACnG;AACkB;AACZ;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8BAA8B,oEAAoB;AAClD;AACA,YAAY,6DAAa;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uEAAc;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,8CAAQ;AAClE;AACA;AACA;AACA;AACA,YAAY,oDAAc,6BAA6B,4CAAM;AAC7D;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,IAAI,oDAAc,4BAA4B,4CAAM;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oEAAoB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uEAAgB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,sEAAa;AACnB,uBAAuB,uEAAgB;AACvC,KAAK;AACL,6CAA6C,uEAAc;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yEAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAoB;AACnC;AACA;AACA;AACA;AACA;AACA,oFAAoF,wEAAqB;AACzG;AACA;AACA;AACA;AACA,oDAAoD,8DAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uKAAuK,6EAAmB;AAC1L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kEAAe;AACzD;AACA,mBAAmB,yEAAoB;AACvC;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,mBAAmB,mEAAS;AAC5B,0GAA0G;AAC1G,kBAAkB,4EAAkB;AACpC,YAAY;AACZ;AACA,mBAAmB,6DAAG;AACtB,aAAa;AACb,kBAAkB,4EAAkB;AACpC;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,6EAAmB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,wEAAc;AAC/G;AACA;AACA,yCAAyC,kEAAe;AACxD,SAAS;AACT,OAAO;AACP;AACA;AACA,0BAA0B,+FAAwC;AAClE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAU;AACtC;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,oDAAoD,iFAAqC;AACzF;AACA,sCAAsC,yDAAU;AAChD;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAa;AACrB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACtUsG;AAC3B;AACpE;AACP,gCAAgC;AAChC,sFAAsF;AACtF,uDAAuD,gCAAgC;AACvF,WAAW,4DAAG;AACd,KAAK;AACL,qCAAqC,2EAAkB;AACvD,GAAG;AACH;AACA,mBAAmB,uEAAc;AACjC;AACA;AACA;AACO;AACP,YAAY,kEAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mBAAmB,8DAAK;AACxB,uBAAuB,uFAAgC;AACvD;AACA;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;;AAEiG;AAC5B;AAC8B;AAChD;AACU;AACwC;AAC5C;AAC2B;AACjB;AACvB;AACZ;AACA;AACF;AACK;AACJ;AACH;AACkB;AACvC;AACP,UAAU,kEAAS;AACnB,uBAAuB,0EAA8B;AACrD,uBAAuB,0EAA8B;AACrD,6BAA6B,gEAAgB;AAC7C;AACA,iBAAiB,iFAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAe;AACnC,kBAAkB,iDAAe;AACjC;AACA,kBAAkB,iDAAe;AACjC,gBAAgB,iDAAe;AAC/B,OAAO;AACP;AACA,kBAAkB,0CAAO;AACzB,gBAAgB,0CAAO;AACvB,OAAO;AACP,6BAA6B,0CAAO;AACpC,iBAAiB,0CAAO;AACxB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,iDAAe;AAC/B,cAAc,iDAAe;AAC7B,KAAK;AACL;AACA,YAAY,0EAAoB;AAChC,UAAU,0EAAoB;AAC9B,KAAK;AACL,qBAAqB,0EAAoB;AACzC;AACA;AACA,EAAE,0EAA0B;AAC5B,EAAE,sEAAwB;AAC1B;AACA;AACO;AACP,SAAS,qDAAc,CAAC,oDAAa,gCAAgC,6CAAM,yCAAyC,6CAAM,4BAA4B;AACtJ;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0EAA8B;AAC3C;AACA,oBAAoB,iFAA2B;AAC/C;AACA,sDAAsD,+CAAQ;AAC9D;AACA;AACA;AACA,wBAAwB,8DAAkB;AAC1C;AACA,4BAA4B,iGAAiC,wBAAwB,8DAAK;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,aAAa,gFAAwB;AACrC;AACA;AACA;AACA,0BAA0B,8DAAkB;AAC5C;AACA,8BAA8B,iGAAiC,wBAAwB,8DAAK;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAkB;AACxC,WAAW;AACX,UAAU;AACV,yBAAyB,8DAAkB;AAC3C,UAAU,iCAAiC,8DAAkB,yCAAyC,wEAAc;AACpH;AACA;AACA,sBAAsB,8DAAkB;AACxC,WAAW;AACX,UAAU;AACV,yBAAyB,8DAAkB;AAC3C;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,kBAAkB,yDAAU;AAC5B;AACA;AACA,aAAa;AACb,YAAY;AACZ,2BAA2B,8DAAkB,CAAC,wEAAc;AAC5D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnN6H;AAC9D;AACqB;AAC7E;AACA;AACP,+BAA+B,2EAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6EAAuB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,yFAAmC;AACnD;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACO;AACP;AACA,2BAA2B,2EAAoB;AAC/C;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,UAAU,2EAAkB;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAG;AACzB,eAAe,yFAAmC;AAClD,iBAAiB,uEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClH8C;AACiF;AACU;AACnE;AAChB;AACkC;AACZ;AACQ;AACxC;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8BAA8B,oEAAoB;AAClD;AACA,YAAY,6DAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,yBAAyB,0EAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH,8DAA8D,4CAAM;AACpE;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA,EAAE,oDAAc,4BAA4B,4CAAM;AAClD;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,6DAA6D,oEAAoB;AACjF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+EAAwB;AACnD;AACA,kBAAkB;AAClB;AACA,uBAAuB,uEAAgB;AACvC,wDAAwD,uEAAc;AACtE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uEAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,sEAAa;AACvB;AACA,WAAW;AACX;AACA,qBAAqB,uEAAgB;AACrC;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wEAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAkB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAA6D,4EAAmB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kEAAe;AACtD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAU;AACnC;AACA;AACA;AACA;AACA,yCAAyC,iGAAiC,8CAA8C,+DAAK;AAC7H,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iDAAiD,iFAAqC;AACtF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAoB;AACrC;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA,+CAA+C,kEAAe,QAAQ,uEAAc;AACpF;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAU;AACpC;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,wBAAwB,+FAAwC;AAChE;AACA;AACA;AACA,WAAW;AACX;AACA,qDAAqD,iFAAqC;AAC1F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1XA;AACA;AACA;AACA;;AAEiD;AAC4B;AACtE;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,MAAM,sEAAa;AACnB,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;AACP,SAAS,2EAAkB;AAC3B;AACA;AACA;AACA;AACA,gCAAgC,0DAAY;AAC5C,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtGwH;AACzC;AAC9B;AAC2B;AACd;AACb;AACN;;AAE3C;AACA;AACA;AACA;AACO;AACP,SAAS,kEAAS;AAClB,SAAS,4EAAsB;AAC/B;AACA,WAAW,oEAAc;AACzB;AACA,eAAe,iFAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2EAAkB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yFAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,0DAAY;AAC3B,KAAK;AACL;AACA;AACA,YAAY,8DAAmB;AAC/B;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA,qBAAqB,2EAAoB;AACzC;AACA,2BAA2B,4DAAG;AAC9B,sBAAsB,uEAAc;AACpC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA,UAAU,wDAAU;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClI8D;AACjB;AAC6K;AACvD;AACnG;AACL;AACiB;AACO;AAChB;AACF;AACgC;AACwC;AAC1E;AACF;AACZ;AAC2C;AACnB;AACzE;AACA;AACA;AACO;AACA;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yGAAyG,0BAA0B,cAAc,kBAAkB,cAAc,2BAA2B,0EAA6B,cAAc,oBAAoB,qGAAsB;AACjS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,4CAAM;AACzD,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iFAA4B;AAC/E;AACA;AACA;AACA,kCAAkC,iFAA4B;AAC9D,cAAc,wDAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,2BAA2B,gFAAyB;AACpD,qCAAqC,wEAAqB,sEAAsE,0EAAyB;AACzJ,mCAAmC,8CAAQ,oBAAoB,uFAAiC;AAChG,6CAA6C,0CAAG;AAChD,8BAA8B,iFAAuB;AACrD;AACA,yBAAyB,yDAAa,gDAAgD,4CAAM,yBAAyB,0CAAG;AACxH;AACA,8BAA8B,0FAAwB;AACtD;AACA,aAAa,qFAAmB;AAChC,KAAK;AACL,4EAA4E,4CAAM;AAClF;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,0EAAoB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,wFAA6B;AACjC,UAAU,uEAAa;AACvB;;AAEA;AACA;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,IAAI,wFAA6B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wFAA6B;AACjC;AACA;AACA,IAAI,iFAA0B;AAC9B,uBAAuB,wEAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2EAA2B;AAC1C,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wFAA6B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qFAA0B;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,MAAM;AACN;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA,yBAAyB,qFAA0B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+FAAwC;AAChE,wBAAwB,2EAA2B;AACnD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wFAA6B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,mEAAS;AAC9B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB,+FAAwC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,wFAA6B;AACjC;AACA;AACA;AACA,oBAAoB,qFAA0B;AAC9C;AACA;AACA,cAAc,wDAAU;AACxB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,wBAAwB,2EAAiB;AACzC,0BAA0B,wEAAc;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,wFAA6B;AACjC;AACA,IAAI,iFAA0B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,wFAA6B;AACjC,kBAAkB,qFAA0B;AAC5C;AACA;AACA,YAAY,wDAAU;AACtB;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,cAAc,0EAAoB;AAClC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,wFAA6B;AACjC,IAAI,0DAAc;AAClB;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB,+DAAgB;AACjC;AACA,gBAAgB,4DAAa;AAC7B;AACA;AACA;AACA,IAAI,wFAA6B;AACjC,IAAI,0DAAc;AAClB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc,4DAAa;AAC3B;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP,MAAM;AACN;AACA,mBAAmB,+DAAgB;AACnC;;AAEA;AACA;AACA,cAAc,wDAAU;AACxB;AACA,iBAAiB,mEAAS;AAC1B;AACA,cAAc,4DAAa;AAC3B;AACA;AACA;AACA;AACA,IAAI,wFAA6B;AACjC;AACA,iBAAiB,+DAAgB;AACjC;AACA,gBAAgB,4DAAa;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,wFAA6B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAa;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,uEAAa;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,UAAU,uEAAa;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAc;AAC1B;AACA;AACA,OAAO;AACP;AACA;AACA,YAAY,4DAAc;AAC1B;AACA;AACA,OAAO;AACP;AACA;AACA,YAAY,wDAAU;AACtB;AACA,OAAO;AACP;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0EAAoB;AACjC;;AAEA;AACA;AACA,WAAW,uEAAa;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,2EAAqB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+DAAmB;AAChC,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mFAAwB;AAClC;AACA,SAAS,8EAAY;AACrB;AACA;AACA,yBAAyB,4CAAM;AAC/B;AACA,GAAG;AACH;AACA;AACA,yBAAyB,4CAAM;AAC/B;AACA,GAAG;AACH;AACA;AACA,yBAAyB,4CAAM;AAC/B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,0BAA0B,iEAAO;AACjC;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,8BAA8B;AAC9B,0BAA0B;AAC1B;AACA,cAAc;AACd,cAAc;AACd,kBAAkB;AAClB,cAAc;AACd;AACA,2BAA2B,0EAA6B;AACxD,oBAAoB,qGAAsB;AAC1C,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2DAAY;AACzB;AACA,EAAE,0DAAc;AAChB,SAAS,4FAAiC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,gBAAgB,0EAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM,0DAAc;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3zBqE;AACgC;AACa;AACU;AACxE;AAC7C;AACA;AACA;AACA;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA,4BAA4B,6EAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP,SAAS,yFAAmC;AAC5C;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACO;AACP,4BAA4B,iEAAY;AACxC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB,oEAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,iFAAwB;AACnC,UAAU,2EAAkB;AAC5B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,WAAW,+FAAwC;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAAc;AAC5B,uBAAuB,sEAAwB;AAC/C;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA,WAAW,uEAAc;AACzB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,UAAU,wDAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,8BAA8B,wEAAiB;AAC/C,mBAAmB,8DAAK,CAAC,uEAAc;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,kEAAW;AACvB,kBAAkB,uEAAc;AAChC;AACA,OAAO;AACP,MAAM;AACN,WAAW,sEAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,UAAU,wDAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,8BAA8B,wEAAiB;AAC/C,mBAAmB,8DAAK,CAAC,uEAAc;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,kEAAW;AACvB,kBAAkB,uEAAc;AAChC;AACA,OAAO;AACP,MAAM;AACN,WAAW,sEAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7Q8D;AAChB;AACD;AAC0J;AAC5J;AACK;AACiB;AAClC;AACW;AACc;AAC2E;AACwF;AACtJ;AACpB;AACwB;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA;AACA;AACA,yBAAyB,wDAAS;AAClC,uBAAuB,iEAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yCAAO;AAClC;AACA,6CAA6C,wDAAQ,oBAAoB,sFAAiC;AAC1G,wBAAwB,0EAAqB;AAC7C,gCAAgC,0EAAqB;AACrD,mCAAmC,uDAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gFAAyB,mCAAmC,iFAAqB;;AAE5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gGAAgC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAU;AACtB;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB,qBAAqB,+FAA+B,CAAC,sFAAsB,gBAAgB,uFAA2B;AAC3J;AACA,YAAY,yDAAU;AACtB;AACA;AACA,OAAO;AACP;AACA,mBAAmB,2EAAoB;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAc;AACjC;;AAEA;AACA;AACA,cAAc,yDAAU;AACxB;AACA,SAAS;AACT;AACA,sCAAsC,sFAAsB;AAC5D;AACA,YAAY,+FAA+B,4BAA4B,uFAA2B;AAClG;AACA,iBAAiB,uFAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,eAAe,kFAAwB;AACvC,cAAc,4EAAkB;AAChC;AACA;AACA;AACA;AACA,OAAO;AACP,oCAAoC;AACpC;AACA;AACA;AACA,OAAO;;AAEP;AACA,qBAAqB,mEAAS;AAC9B;AACA;AACA,MAAM,0DAAc;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc,yDAAU;AACxB;AACA;AACA,SAAS;AACT;AACA,oBAAoB,wEAAc;AAClC;AACA;AACA;AACA;AACA,cAAc,yDAAU;AACxB;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAc;AAChC,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,6BAA6B,sEAAkB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,UAAU,uEAAa;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA;AACA;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,UAAU,uEAAa;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8EAAY;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA,UAAU,yDAAU;AACpB;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,wEAAqB;AACzC,YAAY,iFAAqB;AACjC;AACA;AACA;AACA,aAAa,2DAAY;AACzB,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,iBAAiB,uEAAiB;AAClC;AACA,CAAC;AACD,EAAE,0DAAc;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2DAAY;AACvB,cAAc,yDAAU;AACxB;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,gCAAgC,qEAAW;AAC3C;AACA;AACA,UAAU,+DAAmB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,8BAA8B,qEAAW;AACzC,yHAAyH;AACzH,6BAA6B,yFAAyB;AACtD;AACA;AACA;AACA,iEAAiE,mFAAwB;AACzF,QAAQ,+DAAmB;AAC3B;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC/kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwI;AAC5F;AACK;AACa;AAC9D;AACO;AACP;AACA;AACA,kBAAkB,0DAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACO;AACP,SAAS,2EAAkB,+CAA+C,4EAA2B;AACrG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,sEAA+B,oCAAoC,0DAAY;AAC3F;AACA,EAAE,yDAAc;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7E2F;AAC6F;AAC7I;AACC;AAC0B;AACrB;AACa;AACgD;AACxC;AAC/D;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAG;AAC3B,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sDAAM,yBAAyB,mDAAG,wDAAwD,sDAAM,oBAAoB,mDAAG,gBAAgB,mFAA8B,CAAC,uEAAc,iBAAiB,yDAAS,wDAAwD,oEAAoB,2CAA2C,mDAAG,qEAAqE,2DAAW,CAAC,+EAA0B;AAChe,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ,0DAAY;AACpB;AACA,cAAc,wDAAU;AACxB;AACA,SAAS;AACT;AACA;AACA,cAAc,wDAAU;AACxB;;AAEA;AACA;AACA,cAAc,wDAAU;AACxB;AACA,SAAS;AACT;AACA,sBAAsB,2EAAqB;AAC3C;AACA,cAAc,wDAAU;AACxB;AACA,SAAS;AACT;AACA;AACA,uBAAuB,mDAAG,SAAS,qEAAW,eAAe,oEAAoB;AACjF,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,oBAAoB,2EAAqB;AACzC;AACA;AACA,aAAa,0EAAoB;AACjC;AACA;AACA,YAAY,wDAAU;AACtB;AACA,OAAO;AACP;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,iBAAiB,mEAAS;AAC1B;AACA;AACA;AACA;AACA,aAAa,0DAAY;AACzB,MAAM;AACN,aAAa,0DAAY;AACzB;AACA,GAAG;AACH;AACA,WAAW,+DAAK;AAChB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uEAAa;AACvB,GAAG;AACH;AACA,UAAU,uEAAa;AACvB,GAAG;AACH;AACA,UAAU,uEAAa;AACvB,GAAG;AACH;AACA,UAAU,uEAAa;AACvB,GAAG;AACH;AACA,UAAU,uEAAa;AACvB,GAAG;AACH;AACA,UAAU,uEAAa;AACvB,GAAG;AACH;AACA,UAAU,uEAAa;AACvB,GAAG;AACH;AACA;AACA;AACA;AACA,wBAAwB,oFAA4B;AACpD;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,oFAA4B;AAClG,GAAG;AACH;AACA;AACA,kBAAkB,+DAAK;AACvB;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,cAAc,mEAAS;;AAEvB;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI,kFAA0B;AAC9B;AACA,yDAAyD,gGAAwC;AACjG,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAU;AACtC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM,kFAA0B;AAChC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,UAAU,wDAAU;AACpB;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,EAAE,0DAAc;AAChB;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA,MAAM,0DAAY;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS,4EAAkB;AAC3B,mBAAmB,qEAAW;;AAE9B;AACA;AACA,aAAa,0DAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mEAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAQ;AACrC,YAAY;AACZ;AACA,4BAA4B,kEAAQ;AACpC;AACA,UAAU;AACV;AACA,8BAA8B,kEAAQ;AACtC,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kEAAQ;AAClD;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACvX8D;AACI;AACI;AACtE;AACA;AACA;;AAEiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;AAEA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,EAAE,gFAAc;AAChB;AACA;AACA;AACA;AACA,SAAS,8EAAY;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC,cAAc,kFAAgB;AACxB;AACP;;AAEA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,EAAE,gFAAc;AAChB;AACA;AACA;AACA;AACA,SAAS,8EAAY;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC,cAAc,kFAAgB;AACxB;AACP;AACA;AACO;AACP;AACA;AACO;AACP,2BAA2B,0DAAY;AACvC;AACO;AACP,+BAA+B,0DAAY;AAC3C;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACrIqE;AACD;AACmE;AAC3E;AACjB;AACS;;AAEpD;AACA;AACA;AACA;AACO;AACP,mBAAmB,iFAA2B;AAC9C,eAAe,kEAAS;AACxB,6BAA6B,8DAAK;AAClC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gEAAO;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gEAAiB;AAClF,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yBAAyB,6EAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6EAAoB;AAC7C;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,IAAI;AACJ,8DAA8D,kFAAyB;AACvF;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAe;AACjC,KAAK;AACL,GAAG;AACH;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA,iDAAiD,mDAAmB,mBAAmB,mDAAmB;AAC1G;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;AACA,mBAAmB,iEAAa;AAChC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA,UAAU,wDAAU;AACpB;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,+DAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/OwD;AACpB;AACuB;AACW;AACuB;AAC7B;AACA;AACD;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,wDAAY,CAAC,oDAAY;AAC7B,WAAW;AACX,cAAc;AACd,KAAK;AACL,IAAI,wDAAY,CAAC,oDAAY;AAC7B,UAAU;AACV,SAAS;AACT,gBAAgB;AAChB,aAAa;AACb,SAAS;AACT,UAAU;AACV,SAAS;AACT,SAAS;AACT,UAAU;AACV,SAAS;AACT,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,SAAS;AACT,YAAY;AACZ,WAAW;AACX,WAAW;AACX,KAAK;AACL;AACA;AACA,aAAa,8CAAK;AAClB;AACA;;;;;;;;;;;;;;;;;;;AC/C8D;AACD;AACa;AAC/B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAG;AACnB;AACA;AACA,qBAAqB,0EAA2B;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,cAAc,wDAAU;AACxB;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,SAAS,8EAAY;AACrB;AACA;AACA,aAAa,kFAAyB;AACtC;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,aAAa,kFAAyB;AACtC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA,aAAa,kFAAyB;AACtC;AACA,GAAG;AACH,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzF8D;AAChB;AACuD;AAC4G;AACxI;AAC7B;AACY;AACG;AACuD;AAChD;AAClE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,yBAAyB,4DAAG;AAC5B;AACA;AACA,yBAAyB,iDAAe;AACxC;AACA;AACA,6BAA6B,0EAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA,yBAAyB,2EAAmB;AAC5C;AACA,MAAM;AACN;AACA;AACA,6BAA6B,2EAAmB;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wDAAU;AACxB;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA,gBAAgB,uEAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uEAAc;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mEAAU;AAC9B;AACA,aAAa,wEAAmB;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,yDAAc;AAClB,gBAAgB,iEAAY;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0EAA4B;AAC1C,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,WAAW,2EAAsB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,WAAW,2EAAsB;AACjC;AACA;AACA,WAAW,2EAAsB;AACjC;AACA;AACA,WAAW,2EAAsB;AACjC;AACA;AACA,WAAW,2EAAsB;AACjC;;AAEA;AACA;AACA;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,UAAU,uEAAa;AACvB;AACA;AACA,UAAU,uEAAa;AACvB;AACA,SAAS,8EAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAM;AACd;AACA;AACA;AACA;AACA,QAAQ,0DAAS;AACjB;AACA,QAAQ,yDAAQ;AAChB;AACA,QAAQ,oDAAG;AACX;AACA,QAAQ,4DAAW,CAAC,+EAA0B;AAC9C;AACA,QAAQ,qEAAoB;AAC5B,oCAAoC,uEAAc;AAClD;AACA,YAAY;AACZ;AACA;AACA,SAAS,GAAG,uDAAM;AAClB;AACA;AACA;AACA;AACA,QAAQ,oDAAG;AACX,iBAAiB,uEAAc;AAC/B,SAAS;AACT,kBAAkB,4CAAK;AACvB;AACA;AACA;AACA;AACA,4BAA4B,uDAAM;AAClC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,4BAA4B,wEAAmB;AAC/C,aAAa,kFAAyB,uBAAuB,oEAAe;AAC5E;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACM;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACO;AACP,EAAE,yDAAc;AAChB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,EAAE,yEAAuB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4DAAG;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0EAAqB;AAChC;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,4BAA4B,uEAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA,QAAQ;AACR;AACA,gCAAgC,sEAAmB;AACnD;AACA;AACA;AACA,UAAU;AACV;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kFAAwB;AACvD,oBAAoB;AACpB;AACA;AACA;AACA,KAAK;AACL;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ,uEAAa;AACrB;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtkB2C;AACuI;AAClL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA,4BAA4B,mEAAc;AAC1C;AACA,YAAY,iEAAQ;AACpB,YAAY,oEAAW;AACvB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAU;AACpB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACO;AACP;AACA;AACA,SAAS,uEAAc;AACvB;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAW;AAC3B;AACA,YAAY,wDAAU;AACtB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB,mEAAU;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP,cAAc,kEAAS;AACvB;AACA,yBAAyB,kEAAS;;AAElC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,sEAAa;AACf,uIAAuI;;AAEvI;AACA;AACA;AACA,kBAAkB,6EAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wEAAmB;AAClC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtS8D;AACwC;AAC3D;AACC;AACoJ;AAC/I;AAC1C;AACP;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iFAA2B;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA,OAAO;AACP;AACA,uBAAuB,oEAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA,WAAW,kEAAS;AACpB,cAAc,wDAAU;AACxB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2EAAqB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL,IAAI,kFAAyB;AAC7B;AACA;AACA;AACA,WAAW,yFAAmC;AAC9C;AACA,SAAS,8EAAY;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,aAAa,kFAAyB;AACtC;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,aAAa,kFAAyB;AACtC;AACA,GAAG;AACH,CAAC;AACM;AACP,iDAAiD,6EAAoB;AACrE;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,yDAAc;AAClB;AACA,sBAAsB,6EAAuB;AAC7C,kBAAkB,2EAAqB;AACvC,EAAE,0DAAY;AACd;AACA,EAAE,yDAAc;AAChB;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpKA;AACA;AACA;;AAEiD;AACN;AACyB;AACyJ;AACpK;AACgB;AAC7B;AACrC;AACA;AACA;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ,sBAAsB,iFAA2B;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA,gDAAgD,yCAAG,oEAAoE,4CAAM,cAAc,yCAAG,uBAAuB,uEAAc,qBAAqB,+CAAS,oBAAoB,+CAAS,UAAU,4CAAM;AAC9P;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB;AACzB;AACO;AACP;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,YAAY,wDAAU;AACtB;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAAc;AACtC,eAAe;AACf,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA,4BAA4B,uEAAc;AAC1C;AACA,QAAQ;AACR,cAAc,wDAAU;AACxB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,kEAAS;AACxB;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB;AACzB,WAAW,kEAAS;AACpB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,EAAE,0DAAY;AACd,oBAAoB,iFAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAG;AACpB,0BAA0B,qBAAqB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wEAAc;AACtC;AACA;AACA;AACA;AACA;AACA,MAAM,0DAAc;AACpB;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,uEAAc;AACnH;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,oBAAoB,wEAAc;AAClC,aAAa;AACb;AACA,SAAS;AACT;AACA,QAAQ,uEAAa;AACrB;AACA;AACA,QAAQ,uEAAa;AACrB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,+EAA+E,uEAAc;AAC7F,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,UAAU,wDAAU;AACpB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,UAAU,wDAAU;AACpB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,UAAU,wDAAU;AACpB;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACO;AACP,oBAAoB,iFAA2B;AAC/C,+CAA+C,yEAAmB;AAClE;AACA,SAAS,yEAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACO;AACP;AACA;AACA;AACA,oBAAoB,iFAA2B;AAC/C,cAAc,kEAAY;AAC1B;AACA;AACA,gBAAgB,qEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP,SAAS,4EAAkB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B;AACzD;AACA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qCAAqC,0EAAoB;AACzD;AACA;AACA,iBAAiB,kEAAY;AAC7B;AACA,YAAY,qEAAW;AACvB;AACA,YAAY,qEAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qEAAW;AAC7B;AACA,kBAAkB,qEAAW;AAC7B;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA,gBAAgB,qEAAW;AAC3B;AACA,gBAAgB,qEAAW;AAC3B;AACA,SAAS;AACT;AACA,gBAAgB,qEAAW;AAC3B;AACA;AACA,SAAS;AACT;AACA,gBAAgB,qEAAW;AAC3B;AACA,gBAAgB,qEAAW;AAC3B;AACA,SAAS;AACT;AACA,gBAAgB,qEAAW;AAC3B;AACA,gBAAgB,qEAAW;AAC3B;AACA,SAAS;AACT;AACA,gBAAgB,qEAAW;AAC3B,0BAA0B,uEAAc;AACxC,gBAAgB,qEAAW;AAC3B;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,gBAAgB,qEAAW;AAC3B;AACA,gBAAgB,qEAAW;AAC3B;AACA,SAAS;AACT;AACA,gBAAgB,qEAAW;AAC3B;AACA,gBAAgB,qEAAW;AAC3B;AACA,SAAS;AACT;AACA,gBAAgB,qEAAW;AAC3B;AACA,gBAAgB,qEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;AACY;AACU;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yCAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,0DAA0D,yDAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChHkC;AACE;AACpC;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,6CAAO;AACkB;AAC3B;;;;;;;;;;;;;;;;;ACnCO,2CAA2C,uDAAuD;AAClG;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACd0D;AACV;AACsB;AAC1B;AACV;AACa;AACI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,uDAAc;AAC3F,QAAQ,gEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAiB;AAC1C;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,eAAe,yDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qBAAqB,mBAAmB,qBAAqB,gBAAgB,wBAAwB;AAChJ,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;AACqB;AACtB;AACA;AACA,gFAAgF,2CAAM;AACtF;AACA;AACA,oBAAoB,4DAAU,gBAAgB,4DAAU,iBAAiB,4DAAU;AACnF;AACA;AACA,sCAAsC,mDAAU,2BAA2B,6DAAc;AACzF;AACA;;;;;;;;;;;;;;;;;ACrGkC;AACE;AACsC;AAC1E;AACA,IAAI,gDAAS;AACb;AACA,sCAAsC;AACtC,sCAAsC;AACtC,6CAA6C,qBAAqB,mFAAqB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uCAAuC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,6CAAO;AACgB;AACzB;;;;;;;;;;;;;;;;;;;;;ACzD4C;AACF;AACwB;AACO;AAC5B;AACM;AACnD;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kFAAuB;AAC7C;AACA;AACA;AACA;AACA,QAAQ,gEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAQ,0CAA0C,UAAU;AAC9F;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,gEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,gEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAkB;AACrC;AACA;AACA;AACA,mBAAmB,uDAAY;AAC/B;AACA,YAAY,0DAAS;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,mDAAU;AACO;AACnB;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wIAAwI,6DAAkB;AAC1J;AACA;AACA,CAAC;AAC2B;AAC5B;;;;;;;;;;;;;;;;;;;;;;;;;ACjKkC;AACa;AACe;AAC5B;AACiC;AAChC;AACkE;AACvC;AACX;AACnD;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wEAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yEAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yEAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,uDAAY;AACQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA,YAAY,4DAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2CAAM;AAC/B;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACyB;AAC1B;AACA,QAAQ,2CAAM;AACd,QAAQ,gEAAY;AACpB;AACA;AACA,QAAQ,gFAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2CAAM;AACtC,6BAA6B,uEAAe,0BAA0B,yDAAyD;AAC/H;AACO;AACP;AACA,UAAU,4CAAI;AACd;AACA,cAAc,4CAAI;AAClB;AACA;;;;;;;;;;;;;;;;;;;;ACvLwD;AACT;AACkB;AACpB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,+CAAQ,oDAAoD,sBAAsB;AAClI;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAU;AAC1B;AACA;AACA;AACA;AACA,0CAA0C,0EAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+CAAQ,uDAAuD,uBAAuB;AACnI;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0EAAmB;AAClE,yCAAyC,oDAAa,CAAC,oDAAa,KAAK,6CAAM,WAAW,6CAAM;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,0BAA0B,0EAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAS;AACrB;AACA;AACA;AACA;AACA,uBAAuB,0DAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACuB;AACjB;AACA;AACP;AACA,uCAAuC,4DAAU,kBAAkB,4DAAU,eAAe,4DAAU;AACtG;AACA;AACA,QAAQ,4DAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9IO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACP+C;AACD;AACvC;AACP;AACA;AACA,6BAA6B,uDAAc;AAC3C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAU;AACzC;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACvB2C;AACyB;AACtC;AACc;AACgB;AACG;AACX;AACuB;AACjB;AACnD;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,oBAAoB,wDAAY;AAChC,yBAAyB,6DAAiB;AAC1C,aAAa,gFAAoB;AACjC;AACA,eAAe,2CAAI;AACnB;AACA,qBAAqB,mDAAU;AAC/B;AACA,gCAAgC,OAAO,gEAAY;AACnD;AACA,YAAY,oDAAQ;AACpB,wCAAwC,wEAAgB;AACxD;AACO;AACP,qCAAqC,iBAAiB,oDAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2CAAI;AACrC;AACA,qCAAqC,uFAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,4BAA4B,YAAY;AACxC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,sEAAe;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrEmD;AACP;AACd;AACvB;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,WAAW,+DAAS,GAAG,2CAAI,OAAO,wDAAY;AAC9C;AACA;;;;;;;;;;;;;;;;ACV2C;AACpC,gBAAgB,mDAAU,yBAAyB,+BAA+B;AAClF;AACP;AACA;AACA;AACA,eAAe,mDAAU,yBAAyB,wCAAwC,+BAA+B,IAAI;AAC7H;AACA;;;;;;;;;;;;;;;;ACRmD;AACX;AACjC;AACP,uBAAuB,+DAAS,qBAAqB,qDAAS;AAC9D;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLwE;AACtB;AACJ;AACH;AACuB;AACR;AACwB;AAClC;AACwD;AACxD;AACoB;AACG;AAChE;AACP,yBAAyB,mDAAU;AACnC;AACA;AACA;AACA,YAAY,8EAAmB;AAC/B;AACA;AACA,YAAY,8DAAW;AACvB;AACA;AACA,YAAY,0DAAS;AACrB;AACA;AACA,YAAY,sEAAe;AAC3B;AACA;AACA,YAAY,4DAAU;AACtB;AACA;AACA,YAAY,gFAAoB;AAChC;AACA;AACA;AACA,UAAU,8FAAgC;AAC1C;AACO;AACP,eAAe,mDAAU;AACzB,sBAAsB,0DAAiB;AACvC,YAAY,4DAAU;AACtB;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,eAAe,mDAAU;AACzB,wBAAwB,wCAAwC;AAChE;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mBAAmB,+BAA+B;AAC3D,wBAAwB,6EAAoB;AAC5C,KAAK;AACL;AACO;AACP,eAAe,mDAAU;AACzB;AACA;AACA,kCAAkC,gDAAQ,8CAA8C,oBAAoB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,KAAK;AACL;AACO;AACP,eAAe,mDAAU;AACzB,kEAAkE,+BAA+B;AACjG,KAAK;AACL;AACO;AACP,6BAA6B,8FAAkC;AAC/D;AACA;AACA;AACA;AACA,WAAW,iDAAS;AACpB;AACA,eAAe,mDAAW;AAC1B;AACA;AACA;AACA,sCAAsC,qDAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;AC9IiD;AACT;AACR;AACuB;AACzB;AACvB;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,oBAAoB,wDAAY;AAChC,qBAAqB,qDAAS;AAC9B;AACA;AACA;AACA,YAAY,yCAAK;AACjB;AACA;AACA,gBAAgB,qDAAS;AACzB;AACA,gBAAgB,6DAAQ,aAAa,2CAAI;AACzC;AACA;;;;;;;;;;;;;;;;;ACtBkC;AACS;AACpC;AACP;AACA;AACA;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,mDAAU;AACkB;AAC9B;;;;;;;;;;;;;;;AC5DsC;AAC/B;AACP,WAAW,mDAAQ;AACnB;AACA;;;;;;;;;;;;;;;;;ACJ4C;AACL;AACyB;AACzD;AACP,kCAAkC,cAAc,oDAAQ;AACxD;AACA,WAAW,mDAAO;AAClB;AACA;AACA,yBAAyB,6EAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtBuC;AACyB;AACzD;AACP,WAAW,mDAAO;AAClB;AACA,yBAAyB,6EAAwB,gCAAgC,2EAA2E;AAC5J,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACRuC;AACyB;AACzD;AACP,WAAW,mDAAO;AAClB;AACA,yBAAyB,6EAAwB;AACjD;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;ACV8C;AACP;AACD;AACiB;AACb;AACnC;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,oBAAoB,wDAAY;AAChC,qBAAqB,qDAAS;AAC9B,WAAW,mDAAO;AAClB,QAAQ,mDAAQ,aAAa,sDAAI,CAAC,oDAAa,WAAW,6CAAM;AAChE,KAAK;AACL;AACA;;;;;;;;;;;;;;;;AChBsC;AACM;AACrC;AACP,iCAAiC;AACjC,WAAW,mDAAQ,CAAC,oDAAQ;AAC5B;AACA;;;;;;;;;;;;;;;;;ACNoD;AACM;AACM;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,QAAQ,gEAAS,oCAAoC,6EAAwB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sEAAe,8CAA8C,mCAAmC;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB,6EAAwB;AAC7C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5D4B;AACwB;AACb;AACW;AACF;AACzC;AACP,iCAAiC;AACjC,QAAQ,4DAAU;AAClB,0CAA0C,OAAO,yCAAG,oBAAoB,qCAAqC,EAAE,gEAAS,mBAAmB;AAC3I;AACA;AACA;AACA;AACA,WAAW,mDAAO,iCAAiC,OAAO,+DAAc,4CAA4C;AACpH;AACA;;;;;;;;;;;;;;;;ACf8C;AACd;AACzB;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,WAAW,yCAAK,eAAe,oDAAa,KAAK,6CAAM;AACvD;AACA;;;;;;;;;;;;;;;;;ACT0D;AACnB;AACyB;AACzD;AACP,4BAA4B;AAC5B,WAAW,mDAAO;AAClB,yBAAyB,6EAAwB,gCAAgC,OAAO,sEAAe,sCAAsC,gCAAgC,WAAW,gBAAgB,OAAO,sEAAe,sCAAsC,+BAA+B,WAAW,mBAAmB,OAAO,sEAAe,sCAAsC,+BAA+B,WAAW;AACva,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;ACT8C;AACM;AACf;AACU;AACR;AAChC;AACP,8BAA8B;AAC9B,0EAA0E,WAAW,6CAAO,MAAM;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC,uDAAc;AAC/C,6CAA6C,0BAA0B;AACvE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,gBAAgB,gEAAS;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAc;AACzC;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,WAAW,gEAAS,kBAAkB,oDAAa,KAAK,6CAAM;AAC9D;AACA;;;;;;;;;;;;;;;;ACpFiD;AACjB;AACzB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6CAAK;AAChB,iCAAiC,WAAW,yDAAa,sCAAsC;AAC/F;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;ACnB8C;AACF;AACL;AAChC;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,oBAAoB,wDAAY;AAChC,WAAW,mDAAO;AAClB,qBAAqB,0DAAM,8BAA8B,0DAAM;AAC/D,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACbuC;AAChC;AACP,4BAA4B;AAC5B,WAAW,mDAAO;AAClB,wDAAwD,sCAAsC;AAC9F,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;ACPoD;AACb;AACyB;AACzD;AACP,WAAW,mDAAO;AAClB;AACA;AACA;AACA,0CAA0C;AAC1C,yBAAyB,6EAAwB;AACjD;AACA;AACA;AACA,YAAY,gEAAS,0DAA0D,6EAAwB,qCAAqC,oHAAoH;AAChQ;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;ACvBgD;AACT;AACyB;AACpB;AACrC;AACP,sBAAsB,4DAAU;AAChC;AACA,cAAc;AACd;AACA;AACA,UAAU,mDAAO;AACjB;AACA;AACA;AACA,6BAA6B,6EAAwB;AACrD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,YAAY,oDAAQ;AACpB;AACA;;;;;;;;;;;;;;;ACvC2C;AACpC;AACP,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACjB2C;AACe;AACnD;AACP;AACA;AACA;AACA,eAAe,mDAAU;AACzB,QAAQ,sEAAe;AACvB;AACA,YAAY,sEAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;ACtB2C;AACsB;AACjB;AACU;AACnD;AACP,eAAe,mDAAU;AACzB;AACA,QAAQ,sEAAe;AACvB,6BAA6B,sDAAe;AAC5C,YAAY,sEAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,6BAA6B,OAAO,4DAAU;AAC9C,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;AC/BoD;AACD;AACI;AAChD;AACP,WAAW,gEAAS,aAAa,mEAAW,aAAa,+DAAS;AAClE;AACA;;;;;;;;;;;;;;;;;ACNoD;AACD;AACI;AAChD;AACP,WAAW,gEAAS,aAAa,mEAAW,aAAa,+DAAS;AAClE;AACA;;;;;;;;;;;;;;;;ACNgE;AACkB;AAC3E;AACP,WAAW,6EAAqB,CAAC,8FAAkC;AACnE;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACL0D;AACN;AACJ;AACM;AACU;AACE;AACpB;AACI;AACF;AACU;AACwB;AACd;AACM;AACnE;AACP;AACA,YAAY,8EAAmB;AAC/B,mBAAmB,uEAAkB;AACrC;AACA,YAAY,8DAAW;AACvB,mBAAmB,6DAAa;AAChC;AACA,YAAY,0DAAS;AACrB,mBAAmB,iEAAe;AAClC;AACA,YAAY,sEAAe;AAC3B,mBAAmB,6EAAqB;AACxC;AACA,YAAY,4DAAU;AACtB,mBAAmB,mEAAgB;AACnC;AACA,YAAY,iFAAoB;AAChC,mBAAmB,wFAA0B;AAC7C;AACA;AACA,UAAU,+FAAgC;AAC1C;AACA;;;;;;;;;;;;;;ACpCO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;ACN8C;AACvC;AACP;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA,uDAAuD,oDAAa,qBAAqB,6CAAM;AAC/F;AACA,wCAAwC,oDAAa,qBAAqB,6CAAM;AAChF,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;ACnBO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;ACPO,gCAAgC,+EAA+E;AACtH;;;;;;;;;;;;;;;ACDsD;AAC/C,iBAAiB,mEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;ACRsD;AAC/C,8BAA8B,mEAAgB;AACrD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;ACRsD;AAC/C,0BAA0B,mEAAgB;AACjD;AACA;AACA;AACA,2GAA2G,uCAAuC;AAClJ;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;ACX0C;AACE;AAC5C;AACA;AACA;AACO;AACP,WAAW,uDAAU;AACrB;AACO;AACP,WAAW,yDAAW;AACtB;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;ACdA;AACA;AACO;AACP;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrBO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVO;AACP,mDAAmD,6CAA6C,IAAI;AACpG;AACA;;;;;;;;;;;;;;;;ACHmC;AACnC;AACO;AACP,QAAQ,2CAAM;AACd;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,2CAAM;AACd;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3BO;AACP,4BAA4B;AAC5B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBO;AACP;AACA;AACA;;;;;;;;;;;;;;ACHO,kCAAkC,sEAAsE;AAC/G;;;;;;;;;;;;;;;ACD0C;AACnC;AACP,mCAAmC,uDAAU;AAC7C;AACA;;;;;;;;;;;;;;ACJO;AACP;AACA;AACA;;;;;;;;;;;;;;;;ACHuE;AAC7B;AACnC;AACP,WAAW,uDAAU,OAAO,0DAAiB;AAC7C;AACA;;;;;;;;;;;;;;;;ACLiE;AACvB;AACnC;AACP,WAAW,uDAAU,qDAAqD,sDAAe;AACz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qD,cAAc;AACnE;AACA;AACA;;AAEO;AACP,2CAA2C;AAC3C;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,MAAM,oBAAoB,YAAY;AAC5E,qBAAqB,8CAA8C;AACnE;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,SAAS,gBAAgB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;;AChZF;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5C0C;AACN;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6CAAO,GAAG,mDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;ACjDO;AACP;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA,6DAA6D,eAAe;AAC5E,kCAAkC,aAAa,gBAAgB,YAAY;AAC3E;AACA,8BAA8B;AAC9B;AACO,wBAAwB,wBAAwB,eAAe;AACtE;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACkE;AAClE,YAAY,mBAAmB;AAC2B;AACK;AACO;AACtE,8DAAW,CAAC,oEAAiB,GAAG;AACV;AACe;AACrC;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA,eAAe,mBAAmB;AAClC,CAAC,GAAG;AACJ,kDAAU,OAAO;AACjB;AACA;AACA;AACA,gBAAgB,oFAAyB;AACzC,aAAa,6EAAiB;AAC9B,CAAC;AACD,oBAAoB,mEAAgB;AACpC;AACA;AACA;AACA,CAAC;AACD;AACA;AACO,mBAAmB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gCAAgC;AACjD,cAAc,gCAAgC;AAC9C,gBAAgB,gBAAgB;AAChC,uBAAuB,iBAAiB;AACxC,qBAAqB,qCAAqC;AAC1D,qBAAqB,qCAAqC;AAC1D,qBAAqB,+CAA+C;AACpE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA,uBAAuB,uCAAuC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,uCAAuC;AACvC,yCAAyC;AACzC;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gCAAgC;AACtD,2BAA2B,gBAAgB;AAC3C,6BAA6B,qCAAqC;AAClE,6BAA6B;AAC7B,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD;AACA;AAIyC;AACzC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA,8DAA8D,QAAQ;AACtE;AACA;AACA;AACA,gEAAgE,UAAU;AAC1E;AACA;AACA;AACA,kCAAkC,gFAAe;AACjD;AACA;AACA;AACA,sCAAsC,+FAA8B,GAAG;AACvE,oBAAoB;AACpB;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,YAAY;AACZ;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,sCAAsC;AAC5C,MAAM,qCAAqC;AAC3C,MAAM,sCAAsC;AAC5C,MAAM,sCAAsC;AAC5C,MAAM,uCAAuC;AAC7C,MAAM,sCAAsC;AAC5C,MAAM,sCAAsC;AAC5C,MAAM,sCAAsC;AAC5C,MAAM,uCAAuC;AAC7C,MAAM;AACN;AACA;AACO;AACP,iBAAiB;AACjB;AACA;AACA;;;;;;;;SCnMA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;SAEA;SACA;;;;;UCzBA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,IAAI;UACJ;UACA;UACA,IAAI;UACJ;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,CAAC;UACD;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,EAAE;UACF;UACA,sGAAsG;UACtG;UACA;UACA;UACA;UACA;UACA;UACA;UACA,GAAG;UACH;UACA;UACA;UACA;UACA;UACA,GAAG;UACH;UACA,EAAE;UACF;UACA;;;;;UChEA;UACA;UACA;UACA;UACA;UACA,iCAAiC,WAAW;UAC5C;UACA;;;;;UCPA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,sDAAsD;UACtD,sCAAsC,iEAAiE;UACvG;UACA;UACA;UACA;UACA;UACA;;;;;UCzBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,EAAE;UACF;;;;;UCRA;UACA;UACA;UACA;UACA;;;;;UCJA;UACA;UACA;UACA;UACA,GAAG;UACH;UACA;UACA,CAAC;;;;;UCPD;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;UCNA;;UAEA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA,MAAM,2DAA2D;UACjE;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,MAAM,4BAA4B;UAClC;UACA;UACA;UACA;UACA;UACA;;UAEA;;UAEA;UACA;UACA;UACA,iCAAiC;;UAEjC;UACA;UACA;UACA,KAAK;UACL,eAAe;UACf;UACA;UACA;UACA;UACA,MAAM;UACN;UACA;UACA;UACA;UACA;UACA;;UAEA;;UAEA;;UAEA;;UAEA;;;;;SE1DA;SACA;SACA;SACA","sources":["./node_modules/@babel/runtime/helpers/esm/construct.js","./node_modules/@babel/runtime/helpers/esm/createClass.js","./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","./node_modules/@babel/runtime/helpers/esm/toPrimitive.js","./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","./node_modules/@babel/runtime/helpers/esm/typeof.js","./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","./node_modules/ajv-formats/dist/formats.js","./node_modules/ajv-formats/dist/index.js","./node_modules/ajv-formats/dist/limit.js","./node_modules/ajv/dist/ajv.js","./node_modules/ajv/dist/compile/codegen/code.js","./node_modules/ajv/dist/compile/codegen/index.js","./node_modules/ajv/dist/compile/codegen/scope.js","./node_modules/ajv/dist/compile/errors.js","./node_modules/ajv/dist/compile/index.js","./node_modules/ajv/dist/compile/names.js","./node_modules/ajv/dist/compile/ref_error.js","./node_modules/ajv/dist/compile/resolve.js","./node_modules/ajv/dist/compile/rules.js","./node_modules/ajv/dist/compile/util.js","./node_modules/ajv/dist/compile/validate/applicability.js","./node_modules/ajv/dist/compile/validate/boolSchema.js","./node_modules/ajv/dist/compile/validate/dataType.js","./node_modules/ajv/dist/compile/validate/defaults.js","./node_modules/ajv/dist/compile/validate/index.js","./node_modules/ajv/dist/compile/validate/keyword.js","./node_modules/ajv/dist/compile/validate/subschema.js","./node_modules/ajv/dist/core.js","./node_modules/ajv/dist/runtime/equal.js","./node_modules/ajv/dist/runtime/ucs2length.js","./node_modules/ajv/dist/runtime/uri.js","./node_modules/ajv/dist/runtime/validation_error.js","./node_modules/ajv/dist/vocabularies/applicator/additionalItems.js","./node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js","./node_modules/ajv/dist/vocabularies/applicator/allOf.js","./node_modules/ajv/dist/vocabularies/applicator/anyOf.js","./node_modules/ajv/dist/vocabularies/applicator/contains.js","./node_modules/ajv/dist/vocabularies/applicator/dependencies.js","./node_modules/ajv/dist/vocabularies/applicator/if.js","./node_modules/ajv/dist/vocabularies/applicator/index.js","./node_modules/ajv/dist/vocabularies/applicator/items.js","./node_modules/ajv/dist/vocabularies/applicator/items2020.js","./node_modules/ajv/dist/vocabularies/applicator/not.js","./node_modules/ajv/dist/vocabularies/applicator/oneOf.js","./node_modules/ajv/dist/vocabularies/applicator/patternProperties.js","./node_modules/ajv/dist/vocabularies/applicator/prefixItems.js","./node_modules/ajv/dist/vocabularies/applicator/properties.js","./node_modules/ajv/dist/vocabularies/applicator/propertyNames.js","./node_modules/ajv/dist/vocabularies/applicator/thenElse.js","./node_modules/ajv/dist/vocabularies/code.js","./node_modules/ajv/dist/vocabularies/core/id.js","./node_modules/ajv/dist/vocabularies/core/index.js","./node_modules/ajv/dist/vocabularies/core/ref.js","./node_modules/ajv/dist/vocabularies/discriminator/index.js","./node_modules/ajv/dist/vocabularies/discriminator/types.js","./node_modules/ajv/dist/vocabularies/draft7.js","./node_modules/ajv/dist/vocabularies/format/format.js","./node_modules/ajv/dist/vocabularies/format/index.js","./node_modules/ajv/dist/vocabularies/metadata.js","./node_modules/ajv/dist/vocabularies/validation/const.js","./node_modules/ajv/dist/vocabularies/validation/enum.js","./node_modules/ajv/dist/vocabularies/validation/index.js","./node_modules/ajv/dist/vocabularies/validation/limitItems.js","./node_modules/ajv/dist/vocabularies/validation/limitLength.js","./node_modules/ajv/dist/vocabularies/validation/limitNumber.js","./node_modules/ajv/dist/vocabularies/validation/limitProperties.js","./node_modules/ajv/dist/vocabularies/validation/multipleOf.js","./node_modules/ajv/dist/vocabularies/validation/pattern.js","./node_modules/ajv/dist/vocabularies/validation/required.js","./node_modules/ajv/dist/vocabularies/validation/uniqueItems.js","./node_modules/array-push-at-sort-position/dist/esm/index.js","./node_modules/binary-decision-diagram/dist/esm/src/minimal-string/minimal-string-to-simple-bdd.js","./node_modules/binary-decision-diagram/dist/esm/src/minimal-string/resolve-with-simple-bdd.js","./node_modules/binary-decision-diagram/dist/esm/src/minimal-string/string-format.js","./node_modules/binary-decision-diagram/dist/esm/src/util.js","./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js","./node_modules/broadcast-channel/dist/esbrowser/leader-election-util.js","./node_modules/broadcast-channel/dist/esbrowser/leader-election-web-lock.js","./node_modules/broadcast-channel/dist/esbrowser/leader-election.js","./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js","./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js","./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js","./node_modules/broadcast-channel/dist/esbrowser/methods/native.js","./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js","./node_modules/broadcast-channel/dist/esbrowser/options.js","./node_modules/broadcast-channel/dist/esbrowser/util.js","./node_modules/custom-idle-queue/dist/es/index.js","./node_modules/dexie/dist/dexie.js","./node_modules/dexie/import-wrapper.mjs","./node_modules/event-reduce-js/dist/esm/src/actions/action-functions.js","./node_modules/event-reduce-js/dist/esm/src/actions/index.js","./node_modules/event-reduce-js/dist/esm/src/bdd/bdd.generated.js","./node_modules/event-reduce-js/dist/esm/src/index.js","./node_modules/event-reduce-js/dist/esm/src/states/index.js","./node_modules/event-reduce-js/dist/esm/src/states/state-resolver.js","./node_modules/event-reduce-js/dist/esm/src/util.js","./node_modules/fast-deep-equal/index.js","./node_modules/fast-uri/index.js","./node_modules/fast-uri/lib/schemes.js","./node_modules/fast-uri/lib/scopedChars.js","./node_modules/fast-uri/lib/utils.js","./node_modules/json-schema-traverse/index.js","./node_modules/mingo/dist/esm/aggregator.js","./node_modules/mingo/dist/esm/core.js","./node_modules/mingo/dist/esm/cursor.js","./node_modules/mingo/dist/esm/lazy.js","./node_modules/mingo/dist/esm/operators/_predicates.js","./node_modules/mingo/dist/esm/operators/accumulator/_internal.js","./node_modules/mingo/dist/esm/operators/accumulator/accumulator.js","./node_modules/mingo/dist/esm/operators/accumulator/addToSet.js","./node_modules/mingo/dist/esm/operators/accumulator/avg.js","./node_modules/mingo/dist/esm/operators/accumulator/bottom.js","./node_modules/mingo/dist/esm/operators/accumulator/bottomN.js","./node_modules/mingo/dist/esm/operators/accumulator/count.js","./node_modules/mingo/dist/esm/operators/accumulator/covariancePop.js","./node_modules/mingo/dist/esm/operators/accumulator/covarianceSamp.js","./node_modules/mingo/dist/esm/operators/accumulator/first.js","./node_modules/mingo/dist/esm/operators/accumulator/firstN.js","./node_modules/mingo/dist/esm/operators/accumulator/index.js","./node_modules/mingo/dist/esm/operators/accumulator/last.js","./node_modules/mingo/dist/esm/operators/accumulator/lastN.js","./node_modules/mingo/dist/esm/operators/accumulator/max.js","./node_modules/mingo/dist/esm/operators/accumulator/maxN.js","./node_modules/mingo/dist/esm/operators/accumulator/median.js","./node_modules/mingo/dist/esm/operators/accumulator/mergeObjects.js","./node_modules/mingo/dist/esm/operators/accumulator/min.js","./node_modules/mingo/dist/esm/operators/accumulator/minN.js","./node_modules/mingo/dist/esm/operators/accumulator/percentile.js","./node_modules/mingo/dist/esm/operators/accumulator/push.js","./node_modules/mingo/dist/esm/operators/accumulator/stdDevPop.js","./node_modules/mingo/dist/esm/operators/accumulator/stdDevSamp.js","./node_modules/mingo/dist/esm/operators/accumulator/sum.js","./node_modules/mingo/dist/esm/operators/accumulator/top.js","./node_modules/mingo/dist/esm/operators/accumulator/topN.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/_internal.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/abs.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/add.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/ceil.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/divide.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/exp.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/floor.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/index.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/ln.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/log.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/log10.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/mod.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/multiply.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/pow.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/round.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/sqrt.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/subtract.js","./node_modules/mingo/dist/esm/operators/expression/arithmetic/trunc.js","./node_modules/mingo/dist/esm/operators/expression/array/arrayElemAt.js","./node_modules/mingo/dist/esm/operators/expression/array/arrayToObject.js","./node_modules/mingo/dist/esm/operators/expression/array/concatArrays.js","./node_modules/mingo/dist/esm/operators/expression/array/filter.js","./node_modules/mingo/dist/esm/operators/expression/array/first.js","./node_modules/mingo/dist/esm/operators/expression/array/firstN.js","./node_modules/mingo/dist/esm/operators/expression/array/in.js","./node_modules/mingo/dist/esm/operators/expression/array/index.js","./node_modules/mingo/dist/esm/operators/expression/array/indexOfArray.js","./node_modules/mingo/dist/esm/operators/expression/array/isArray.js","./node_modules/mingo/dist/esm/operators/expression/array/last.js","./node_modules/mingo/dist/esm/operators/expression/array/lastN.js","./node_modules/mingo/dist/esm/operators/expression/array/map.js","./node_modules/mingo/dist/esm/operators/expression/array/maxN.js","./node_modules/mingo/dist/esm/operators/expression/array/minN.js","./node_modules/mingo/dist/esm/operators/expression/array/nin.js","./node_modules/mingo/dist/esm/operators/expression/array/range.js","./node_modules/mingo/dist/esm/operators/expression/array/reduce.js","./node_modules/mingo/dist/esm/operators/expression/array/reverseArray.js","./node_modules/mingo/dist/esm/operators/expression/array/size.js","./node_modules/mingo/dist/esm/operators/expression/array/slice.js","./node_modules/mingo/dist/esm/operators/expression/array/sortArray.js","./node_modules/mingo/dist/esm/operators/expression/array/zip.js","./node_modules/mingo/dist/esm/operators/expression/bitwise/_internal.js","./node_modules/mingo/dist/esm/operators/expression/bitwise/bitAnd.js","./node_modules/mingo/dist/esm/operators/expression/bitwise/bitNot.js","./node_modules/mingo/dist/esm/operators/expression/bitwise/bitOr.js","./node_modules/mingo/dist/esm/operators/expression/bitwise/bitXor.js","./node_modules/mingo/dist/esm/operators/expression/bitwise/index.js","./node_modules/mingo/dist/esm/operators/expression/boolean/and.js","./node_modules/mingo/dist/esm/operators/expression/boolean/index.js","./node_modules/mingo/dist/esm/operators/expression/boolean/not.js","./node_modules/mingo/dist/esm/operators/expression/boolean/or.js","./node_modules/mingo/dist/esm/operators/expression/comparison/cmp.js","./node_modules/mingo/dist/esm/operators/expression/comparison/eq.js","./node_modules/mingo/dist/esm/operators/expression/comparison/gt.js","./node_modules/mingo/dist/esm/operators/expression/comparison/gte.js","./node_modules/mingo/dist/esm/operators/expression/comparison/index.js","./node_modules/mingo/dist/esm/operators/expression/comparison/lt.js","./node_modules/mingo/dist/esm/operators/expression/comparison/lte.js","./node_modules/mingo/dist/esm/operators/expression/comparison/ne.js","./node_modules/mingo/dist/esm/operators/expression/conditional/cond.js","./node_modules/mingo/dist/esm/operators/expression/conditional/ifNull.js","./node_modules/mingo/dist/esm/operators/expression/conditional/index.js","./node_modules/mingo/dist/esm/operators/expression/conditional/switch.js","./node_modules/mingo/dist/esm/operators/expression/custom/function.js","./node_modules/mingo/dist/esm/operators/expression/custom/index.js","./node_modules/mingo/dist/esm/operators/expression/date/_internal.js","./node_modules/mingo/dist/esm/operators/expression/date/dateAdd.js","./node_modules/mingo/dist/esm/operators/expression/date/dateDiff.js","./node_modules/mingo/dist/esm/operators/expression/date/dateFromParts.js","./node_modules/mingo/dist/esm/operators/expression/date/dateFromString.js","./node_modules/mingo/dist/esm/operators/expression/date/dateSubtract.js","./node_modules/mingo/dist/esm/operators/expression/date/dateToParts.js","./node_modules/mingo/dist/esm/operators/expression/date/dateToString.js","./node_modules/mingo/dist/esm/operators/expression/date/dateTrunc.js","./node_modules/mingo/dist/esm/operators/expression/date/dayOfMonth.js","./node_modules/mingo/dist/esm/operators/expression/date/dayOfWeek.js","./node_modules/mingo/dist/esm/operators/expression/date/dayOfYear.js","./node_modules/mingo/dist/esm/operators/expression/date/hour.js","./node_modules/mingo/dist/esm/operators/expression/date/index.js","./node_modules/mingo/dist/esm/operators/expression/date/isoDayOfWeek.js","./node_modules/mingo/dist/esm/operators/expression/date/isoWeek.js","./node_modules/mingo/dist/esm/operators/expression/date/isoWeekYear.js","./node_modules/mingo/dist/esm/operators/expression/date/millisecond.js","./node_modules/mingo/dist/esm/operators/expression/date/minute.js","./node_modules/mingo/dist/esm/operators/expression/date/month.js","./node_modules/mingo/dist/esm/operators/expression/date/second.js","./node_modules/mingo/dist/esm/operators/expression/date/week.js","./node_modules/mingo/dist/esm/operators/expression/date/year.js","./node_modules/mingo/dist/esm/operators/expression/index.js","./node_modules/mingo/dist/esm/operators/expression/literal.js","./node_modules/mingo/dist/esm/operators/expression/median.js","./node_modules/mingo/dist/esm/operators/expression/misc/getField.js","./node_modules/mingo/dist/esm/operators/expression/misc/index.js","./node_modules/mingo/dist/esm/operators/expression/misc/rand.js","./node_modules/mingo/dist/esm/operators/expression/misc/sampleRate.js","./node_modules/mingo/dist/esm/operators/expression/object/index.js","./node_modules/mingo/dist/esm/operators/expression/object/mergeObjects.js","./node_modules/mingo/dist/esm/operators/expression/object/objectToArray.js","./node_modules/mingo/dist/esm/operators/expression/object/setField.js","./node_modules/mingo/dist/esm/operators/expression/object/unsetField.js","./node_modules/mingo/dist/esm/operators/expression/percentile.js","./node_modules/mingo/dist/esm/operators/expression/set/allElementsTrue.js","./node_modules/mingo/dist/esm/operators/expression/set/anyElementTrue.js","./node_modules/mingo/dist/esm/operators/expression/set/index.js","./node_modules/mingo/dist/esm/operators/expression/set/setDifference.js","./node_modules/mingo/dist/esm/operators/expression/set/setEquals.js","./node_modules/mingo/dist/esm/operators/expression/set/setIntersection.js","./node_modules/mingo/dist/esm/operators/expression/set/setIsSubset.js","./node_modules/mingo/dist/esm/operators/expression/set/setUnion.js","./node_modules/mingo/dist/esm/operators/expression/string/_internal.js","./node_modules/mingo/dist/esm/operators/expression/string/concat.js","./node_modules/mingo/dist/esm/operators/expression/string/index.js","./node_modules/mingo/dist/esm/operators/expression/string/indexOfBytes.js","./node_modules/mingo/dist/esm/operators/expression/string/ltrim.js","./node_modules/mingo/dist/esm/operators/expression/string/regexFind.js","./node_modules/mingo/dist/esm/operators/expression/string/regexFindAll.js","./node_modules/mingo/dist/esm/operators/expression/string/regexMatch.js","./node_modules/mingo/dist/esm/operators/expression/string/replaceAll.js","./node_modules/mingo/dist/esm/operators/expression/string/replaceOne.js","./node_modules/mingo/dist/esm/operators/expression/string/rtrim.js","./node_modules/mingo/dist/esm/operators/expression/string/split.js","./node_modules/mingo/dist/esm/operators/expression/string/strLenBytes.js","./node_modules/mingo/dist/esm/operators/expression/string/strLenCP.js","./node_modules/mingo/dist/esm/operators/expression/string/strcasecmp.js","./node_modules/mingo/dist/esm/operators/expression/string/substr.js","./node_modules/mingo/dist/esm/operators/expression/string/substrBytes.js","./node_modules/mingo/dist/esm/operators/expression/string/substrCP.js","./node_modules/mingo/dist/esm/operators/expression/string/toLower.js","./node_modules/mingo/dist/esm/operators/expression/string/toUpper.js","./node_modules/mingo/dist/esm/operators/expression/string/trim.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/acos.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/acosh.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/asin.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/asinh.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/atan.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/atan2.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/atanh.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/cos.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/cosh.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/degreesToRadians.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/index.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/radiansToDegrees.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/sin.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/sinh.js","./node_modules/mingo/dist/esm/operators/expression/trignometry/tan.js","./node_modules/mingo/dist/esm/operators/expression/type/_internal.js","./node_modules/mingo/dist/esm/operators/expression/type/convert.js","./node_modules/mingo/dist/esm/operators/expression/type/index.js","./node_modules/mingo/dist/esm/operators/expression/type/isNumber.js","./node_modules/mingo/dist/esm/operators/expression/type/toBool.js","./node_modules/mingo/dist/esm/operators/expression/type/toDate.js","./node_modules/mingo/dist/esm/operators/expression/type/toDecimal.js","./node_modules/mingo/dist/esm/operators/expression/type/toDouble.js","./node_modules/mingo/dist/esm/operators/expression/type/toInt.js","./node_modules/mingo/dist/esm/operators/expression/type/toLong.js","./node_modules/mingo/dist/esm/operators/expression/type/toString.js","./node_modules/mingo/dist/esm/operators/expression/type/type.js","./node_modules/mingo/dist/esm/operators/expression/variable/index.js","./node_modules/mingo/dist/esm/operators/expression/variable/let.js","./node_modules/mingo/dist/esm/operators/pipeline/_internal.js","./node_modules/mingo/dist/esm/operators/pipeline/addFields.js","./node_modules/mingo/dist/esm/operators/pipeline/bucket.js","./node_modules/mingo/dist/esm/operators/pipeline/bucketAuto.js","./node_modules/mingo/dist/esm/operators/pipeline/count.js","./node_modules/mingo/dist/esm/operators/pipeline/densify.js","./node_modules/mingo/dist/esm/operators/pipeline/facet.js","./node_modules/mingo/dist/esm/operators/pipeline/fill.js","./node_modules/mingo/dist/esm/operators/pipeline/graphLookup.js","./node_modules/mingo/dist/esm/operators/pipeline/group.js","./node_modules/mingo/dist/esm/operators/pipeline/index.js","./node_modules/mingo/dist/esm/operators/pipeline/limit.js","./node_modules/mingo/dist/esm/operators/pipeline/lookup.js","./node_modules/mingo/dist/esm/operators/pipeline/match.js","./node_modules/mingo/dist/esm/operators/pipeline/merge.js","./node_modules/mingo/dist/esm/operators/pipeline/out.js","./node_modules/mingo/dist/esm/operators/pipeline/project.js","./node_modules/mingo/dist/esm/operators/pipeline/redact.js","./node_modules/mingo/dist/esm/operators/pipeline/replaceRoot.js","./node_modules/mingo/dist/esm/operators/pipeline/replaceWith.js","./node_modules/mingo/dist/esm/operators/pipeline/sample.js","./node_modules/mingo/dist/esm/operators/pipeline/set.js","./node_modules/mingo/dist/esm/operators/pipeline/setWindowFields.js","./node_modules/mingo/dist/esm/operators/pipeline/skip.js","./node_modules/mingo/dist/esm/operators/pipeline/sort.js","./node_modules/mingo/dist/esm/operators/pipeline/sortByCount.js","./node_modules/mingo/dist/esm/operators/pipeline/unionWith.js","./node_modules/mingo/dist/esm/operators/pipeline/unset.js","./node_modules/mingo/dist/esm/operators/pipeline/unwind.js","./node_modules/mingo/dist/esm/operators/query/array/all.js","./node_modules/mingo/dist/esm/operators/query/array/elemMatch.js","./node_modules/mingo/dist/esm/operators/query/array/index.js","./node_modules/mingo/dist/esm/operators/query/array/size.js","./node_modules/mingo/dist/esm/operators/query/comparison/eq.js","./node_modules/mingo/dist/esm/operators/query/comparison/gt.js","./node_modules/mingo/dist/esm/operators/query/comparison/gte.js","./node_modules/mingo/dist/esm/operators/query/comparison/in.js","./node_modules/mingo/dist/esm/operators/query/comparison/index.js","./node_modules/mingo/dist/esm/operators/query/comparison/lt.js","./node_modules/mingo/dist/esm/operators/query/comparison/lte.js","./node_modules/mingo/dist/esm/operators/query/comparison/ne.js","./node_modules/mingo/dist/esm/operators/query/comparison/nin.js","./node_modules/mingo/dist/esm/operators/query/element/exists.js","./node_modules/mingo/dist/esm/operators/query/element/index.js","./node_modules/mingo/dist/esm/operators/query/element/type.js","./node_modules/mingo/dist/esm/operators/query/evaluation/expr.js","./node_modules/mingo/dist/esm/operators/query/evaluation/index.js","./node_modules/mingo/dist/esm/operators/query/evaluation/jsonSchema.js","./node_modules/mingo/dist/esm/operators/query/evaluation/mod.js","./node_modules/mingo/dist/esm/operators/query/evaluation/regex.js","./node_modules/mingo/dist/esm/operators/query/evaluation/where.js","./node_modules/mingo/dist/esm/operators/query/logical/and.js","./node_modules/mingo/dist/esm/operators/query/logical/index.js","./node_modules/mingo/dist/esm/operators/query/logical/nor.js","./node_modules/mingo/dist/esm/operators/query/logical/not.js","./node_modules/mingo/dist/esm/operators/query/logical/or.js","./node_modules/mingo/dist/esm/operators/window/_internal.js","./node_modules/mingo/dist/esm/operators/window/linearFill.js","./node_modules/mingo/dist/esm/operators/window/locf.js","./node_modules/mingo/dist/esm/query.js","./node_modules/mingo/dist/esm/types.js","./node_modules/mingo/dist/esm/util.js","./node_modules/oblivious-set/dist/esm/src/index.js","./node_modules/rxdb/dist/esm/change-event-buffer.js","./node_modules/rxdb/dist/esm/doc-cache.js","./node_modules/rxdb/dist/esm/event-reduce.js","./node_modules/rxdb/dist/esm/hooks.js","./node_modules/rxdb/dist/esm/incremental-write.js","./node_modules/rxdb/dist/esm/overwritable.js","./node_modules/rxdb/dist/esm/plugin-helpers.js","./node_modules/rxdb/dist/esm/plugin.js","./node_modules/rxdb/dist/esm/plugins/attachments/attachments-utils.js","./node_modules/rxdb/dist/esm/plugins/dev-mode/check-document.js","./node_modules/rxdb/dist/esm/plugins/dev-mode/check-migration-strategies.js","./node_modules/rxdb/dist/esm/plugins/dev-mode/check-orm.js","./node_modules/rxdb/dist/esm/plugins/dev-mode/check-query.js","./node_modules/rxdb/dist/esm/plugins/dev-mode/check-schema.js","./node_modules/rxdb/dist/esm/plugins/dev-mode/dev-mode-tracking.js","./node_modules/rxdb/dist/esm/plugins/dev-mode/entity-properties.js","./node_modules/rxdb/dist/esm/plugins/dev-mode/error-messages.js","./node_modules/rxdb/dist/esm/plugins/dev-mode/index.js","./node_modules/rxdb/dist/esm/plugins/dev-mode/unallowed-properties.js","./node_modules/rxdb/dist/esm/plugins/leader-election/index.js","./node_modules/rxdb/dist/esm/plugins/replication-webrtc/connection-handler-simple-peer.js","./node_modules/rxdb/dist/esm/plugins/replication-webrtc/index.js","./node_modules/rxdb/dist/esm/plugins/replication-webrtc/signaling-server.js","./node_modules/rxdb/dist/esm/plugins/replication-webrtc/webrtc-helper.js","./node_modules/rxdb/dist/esm/plugins/replication/index.js","./node_modules/rxdb/dist/esm/plugins/replication/replication-helper.js","./node_modules/rxdb/dist/esm/plugins/storage-dexie/dexie-helper.js","./node_modules/rxdb/dist/esm/plugins/storage-dexie/dexie-query.js","./node_modules/rxdb/dist/esm/plugins/storage-dexie/rx-storage-dexie.js","./node_modules/rxdb/dist/esm/plugins/storage-dexie/rx-storage-instance-dexie.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-array.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-document.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-error.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-global.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-hash.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-map.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-object-deep-equal.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-object-dot-prop.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-object.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-other.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-premium.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-regex.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-rxdb-version.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-string.js","./node_modules/rxdb/dist/esm/plugins/utils/utils-time.js","./node_modules/rxdb/dist/esm/plugins/validate-ajv/index.js","./node_modules/rxdb/dist/esm/query-cache.js","./node_modules/rxdb/dist/esm/query-planner.js","./node_modules/rxdb/dist/esm/replication-protocol/checkpoint.js","./node_modules/rxdb/dist/esm/replication-protocol/conflicts.js","./node_modules/rxdb/dist/esm/replication-protocol/default-conflict-handler.js","./node_modules/rxdb/dist/esm/replication-protocol/downstream.js","./node_modules/rxdb/dist/esm/replication-protocol/helper.js","./node_modules/rxdb/dist/esm/replication-protocol/index.js","./node_modules/rxdb/dist/esm/replication-protocol/meta-instance.js","./node_modules/rxdb/dist/esm/replication-protocol/upstream.js","./node_modules/rxdb/dist/esm/rx-change-event.js","./node_modules/rxdb/dist/esm/rx-collection-helper.js","./node_modules/rxdb/dist/esm/rx-collection.js","./node_modules/rxdb/dist/esm/rx-database-internal-store.js","./node_modules/rxdb/dist/esm/rx-database.js","./node_modules/rxdb/dist/esm/rx-document-prototype-merge.js","./node_modules/rxdb/dist/esm/rx-document.js","./node_modules/rxdb/dist/esm/rx-error.js","./node_modules/rxdb/dist/esm/rx-query-helper.js","./node_modules/rxdb/dist/esm/rx-query-mingo.js","./node_modules/rxdb/dist/esm/rx-query-single-result.js","./node_modules/rxdb/dist/esm/rx-query.js","./node_modules/rxdb/dist/esm/rx-schema-helper.js","./node_modules/rxdb/dist/esm/rx-schema.js","./node_modules/rxdb/dist/esm/rx-storage-helper.js","./node_modules/rxdb/dist/esm/rx-storage-multiinstance.js","./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js","./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js","./node_modules/rxjs/dist/esm5/internal/Observable.js","./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js","./node_modules/rxjs/dist/esm5/internal/Subject.js","./node_modules/rxjs/dist/esm5/internal/Subscriber.js","./node_modules/rxjs/dist/esm5/internal/Subscription.js","./node_modules/rxjs/dist/esm5/internal/config.js","./node_modules/rxjs/dist/esm5/internal/firstValueFrom.js","./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js","./node_modules/rxjs/dist/esm5/internal/observable/concat.js","./node_modules/rxjs/dist/esm5/internal/observable/empty.js","./node_modules/rxjs/dist/esm5/internal/observable/from.js","./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js","./node_modules/rxjs/dist/esm5/internal/observable/merge.js","./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js","./node_modules/rxjs/dist/esm5/internal/operators/concatAll.js","./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js","./node_modules/rxjs/dist/esm5/internal/operators/filter.js","./node_modules/rxjs/dist/esm5/internal/operators/map.js","./node_modules/rxjs/dist/esm5/internal/operators/merge.js","./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js","./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js","./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js","./node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js","./node_modules/rxjs/dist/esm5/internal/operators/observeOn.js","./node_modules/rxjs/dist/esm5/internal/operators/share.js","./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js","./node_modules/rxjs/dist/esm5/internal/operators/startWith.js","./node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js","./node_modules/rxjs/dist/esm5/internal/operators/switchMap.js","./node_modules/rxjs/dist/esm5/internal/operators/tap.js","./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js","./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js","./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js","./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js","./node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js","./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js","./node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js","./node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js","./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js","./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js","./node_modules/rxjs/dist/esm5/internal/symbol/observable.js","./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js","./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js","./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js","./node_modules/rxjs/dist/esm5/internal/util/args.js","./node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js","./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js","./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js","./node_modules/rxjs/dist/esm5/internal/util/createObject.js","./node_modules/rxjs/dist/esm5/internal/util/errorContext.js","./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js","./node_modules/rxjs/dist/esm5/internal/util/identity.js","./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js","./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js","./node_modules/rxjs/dist/esm5/internal/util/isFunction.js","./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js","./node_modules/rxjs/dist/esm5/internal/util/isIterable.js","./node_modules/rxjs/dist/esm5/internal/util/isPromise.js","./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js","./node_modules/rxjs/dist/esm5/internal/util/isScheduler.js","./node_modules/rxjs/dist/esm5/internal/util/lift.js","./node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js","./node_modules/rxjs/dist/esm5/internal/util/noop.js","./node_modules/rxjs/dist/esm5/internal/util/pipe.js","./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js","./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js","./node_modules/simple-peer/simplepeer.min.js","./node_modules/tslib/tslib.es6.mjs","./node_modules/unload/dist/es/browser.js","./node_modules/unload/dist/es/index.js","./node_modules/unload/dist/es/node.js","./rxdb-setup.js","webpack/bootstrap","webpack/runtime/async module","webpack/runtime/compat get default export","webpack/runtime/create fake namespace object","webpack/runtime/define property getters","webpack/runtime/ensure chunk","webpack/runtime/get javascript chunk filename","webpack/runtime/global","webpack/runtime/hasOwnProperty shorthand","webpack/runtime/make namespace object","webpack/runtime/import chunk loading","webpack/before-startup","webpack/startup","webpack/after-startup"],"sourcesContent":["import isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nfunction _construct(t, e, r) {\n  if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return r && setPrototypeOf(p, r.prototype), p;\n}\nexport { _construct as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nexport { _createClass as default };","function _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nexport { _getPrototypeOf as default };","import setPrototypeOf from \"./setPrototypeOf.js\";\nfunction _inheritsLoose(t, o) {\n  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, setPrototypeOf(t, o);\n}\nexport { _inheritsLoose as default };","function _isNativeFunction(t) {\n  try {\n    return -1 !== Function.toString.call(t).indexOf(\"[native code]\");\n  } catch (n) {\n    return \"function\" == typeof t;\n  }\n}\nexport { _isNativeFunction as default };","function _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\nexport { _isNativeReflectConstruct as default };","function _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nexport { _setPrototypeOf as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nfunction _wrapNativeSuper(t) {\n  var r = \"function\" == typeof Map ? new Map() : void 0;\n  return _wrapNativeSuper = function _wrapNativeSuper(t) {\n    if (null === t || !isNativeFunction(t)) return t;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n    if (void 0 !== r) {\n      if (r.has(t)) return r.get(t);\n      r.set(t, Wrapper);\n    }\n    function Wrapper() {\n      return construct(t, arguments, getPrototypeOf(this).constructor);\n    }\n    return Wrapper.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), setPrototypeOf(Wrapper, t);\n  }, _wrapNativeSuper(t);\n}\nexport { _wrapNativeSuper as default };","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatNames = exports.fastFormats = exports.fullFormats = void 0;\nfunction fmtDef(validate, compare) {\n    return { validate, compare };\n}\nexports.fullFormats = {\n    // date: http://tools.ietf.org/html/rfc3339#section-5.6\n    date: fmtDef(date, compareDate),\n    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n    time: fmtDef(getTime(true), compareTime),\n    \"date-time\": fmtDef(getDateTime(true), compareDateTime),\n    \"iso-time\": fmtDef(getTime(), compareIsoTime),\n    \"iso-date-time\": fmtDef(getDateTime(), compareIsoDateTime),\n    // duration: https://tools.ietf.org/html/rfc3339#appendix-A\n    duration: /^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n    uri,\n    \"uri-reference\": /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n    // uri-template: https://tools.ietf.org/html/rfc6570\n    \"uri-template\": /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n    // For the source: https://gist.github.com/dperini/729294\n    // For test cases: https://mathiasbynens.be/demo/url-regex\n    url: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n    hostname: /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n    ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/,\n    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n    regex,\n    // uuid: http://tools.ietf.org/html/rfc4122\n    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n    // JSON-pointer: https://tools.ietf.org/html/rfc6901\n    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n    \"json-pointer\": /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n    \"json-pointer-uri-fragment\": /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n    \"relative-json-pointer\": /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n    // byte: https://github.com/miguelmota/is-base64\n    byte,\n    // signed 32 bit integer\n    int32: { type: \"number\", validate: validateInt32 },\n    // signed 64 bit integer\n    int64: { type: \"number\", validate: validateInt64 },\n    // C-type float\n    float: { type: \"number\", validate: validateNumber },\n    // C-type double\n    double: { type: \"number\", validate: validateNumber },\n    // hint to the UI to hide input strings\n    password: true,\n    // unchecked string payload\n    binary: true,\n};\nexports.fastFormats = {\n    ...exports.fullFormats,\n    date: fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/, compareDate),\n    time: fmtDef(/^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i, compareTime),\n    \"date-time\": fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i, compareDateTime),\n    \"iso-time\": fmtDef(/^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i, compareIsoTime),\n    \"iso-date-time\": fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i, compareIsoDateTime),\n    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n    uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n    \"uri-reference\": /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n    // email (sources from jsen validator):\n    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')\n    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n};\nexports.formatNames = Object.keys(exports.fullFormats);\nfunction isLeapYear(year) {\n    // https://tools.ietf.org/html/rfc3339#appendix-C\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nfunction date(str) {\n    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n    const matches = DATE.exec(str);\n    if (!matches)\n        return false;\n    const year = +matches[1];\n    const month = +matches[2];\n    const day = +matches[3];\n    return (month >= 1 &&\n        month <= 12 &&\n        day >= 1 &&\n        day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]));\n}\nfunction compareDate(d1, d2) {\n    if (!(d1 && d2))\n        return undefined;\n    if (d1 > d2)\n        return 1;\n    if (d1 < d2)\n        return -1;\n    return 0;\n}\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d(?:\\.\\d+)?)(z|([+-])(\\d\\d)(?::?(\\d\\d))?)?$/i;\nfunction getTime(strictTimeZone) {\n    return function time(str) {\n        const matches = TIME.exec(str);\n        if (!matches)\n            return false;\n        const hr = +matches[1];\n        const min = +matches[2];\n        const sec = +matches[3];\n        const tz = matches[4];\n        const tzSign = matches[5] === \"-\" ? -1 : 1;\n        const tzH = +(matches[6] || 0);\n        const tzM = +(matches[7] || 0);\n        if (tzH > 23 || tzM > 59 || (strictTimeZone && !tz))\n            return false;\n        if (hr <= 23 && min <= 59 && sec < 60)\n            return true;\n        // leap second\n        const utcMin = min - tzM * tzSign;\n        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);\n        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;\n    };\n}\nfunction compareTime(s1, s2) {\n    if (!(s1 && s2))\n        return undefined;\n    const t1 = new Date(\"2020-01-01T\" + s1).valueOf();\n    const t2 = new Date(\"2020-01-01T\" + s2).valueOf();\n    if (!(t1 && t2))\n        return undefined;\n    return t1 - t2;\n}\nfunction compareIsoTime(t1, t2) {\n    if (!(t1 && t2))\n        return undefined;\n    const a1 = TIME.exec(t1);\n    const a2 = TIME.exec(t2);\n    if (!(a1 && a2))\n        return undefined;\n    t1 = a1[1] + a1[2] + a1[3];\n    t2 = a2[1] + a2[2] + a2[3];\n    if (t1 > t2)\n        return 1;\n    if (t1 < t2)\n        return -1;\n    return 0;\n}\nconst DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction getDateTime(strictTimeZone) {\n    const time = getTime(strictTimeZone);\n    return function date_time(str) {\n        // http://tools.ietf.org/html/rfc3339#section-5.6\n        const dateTime = str.split(DATE_TIME_SEPARATOR);\n        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);\n    };\n}\nfunction compareDateTime(dt1, dt2) {\n    if (!(dt1 && dt2))\n        return undefined;\n    const d1 = new Date(dt1).valueOf();\n    const d2 = new Date(dt2).valueOf();\n    if (!(d1 && d2))\n        return undefined;\n    return d1 - d2;\n}\nfunction compareIsoDateTime(dt1, dt2) {\n    if (!(dt1 && dt2))\n        return undefined;\n    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);\n    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);\n    const res = compareDate(d1, d2);\n    if (res === undefined)\n        return undefined;\n    return res || compareTime(t1, t2);\n}\nconst NOT_URI_FRAGMENT = /\\/|:/;\nconst URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nfunction uri(str) {\n    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n    return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n}\nconst BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;\nfunction byte(str) {\n    BYTE.lastIndex = 0;\n    return BYTE.test(str);\n}\nconst MIN_INT32 = -(2 ** 31);\nconst MAX_INT32 = 2 ** 31 - 1;\nfunction validateInt32(value) {\n    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;\n}\nfunction validateInt64(value) {\n    // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n    return Number.isInteger(value);\n}\nfunction validateNumber() {\n    return true;\n}\nconst Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n    if (Z_ANCHOR.test(str))\n        return false;\n    try {\n        new RegExp(str);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n//# sourceMappingURL=formats.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst formats_1 = require(\"./formats\");\nconst limit_1 = require(\"./limit\");\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst fullName = new codegen_1.Name(\"fullFormats\");\nconst fastName = new codegen_1.Name(\"fastFormats\");\nconst formatsPlugin = (ajv, opts = { keywords: true }) => {\n    if (Array.isArray(opts)) {\n        addFormats(ajv, opts, formats_1.fullFormats, fullName);\n        return ajv;\n    }\n    const [formats, exportName] = opts.mode === \"fast\" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];\n    const list = opts.formats || formats_1.formatNames;\n    addFormats(ajv, list, formats, exportName);\n    if (opts.keywords)\n        (0, limit_1.default)(ajv);\n    return ajv;\n};\nformatsPlugin.get = (name, mode = \"full\") => {\n    const formats = mode === \"fast\" ? formats_1.fastFormats : formats_1.fullFormats;\n    const f = formats[name];\n    if (!f)\n        throw new Error(`Unknown format \"${name}\"`);\n    return f;\n};\nfunction addFormats(ajv, list, fs, exportName) {\n    var _a;\n    var _b;\n    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : (_b.formats = (0, codegen_1._) `require(\"ajv-formats/dist/formats\").${exportName}`);\n    for (const f of list)\n        ajv.addFormat(f, fs[f]);\n}\nmodule.exports = exports = formatsPlugin;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = formatsPlugin;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatLimitDefinition = void 0;\nconst ajv_1 = require(\"ajv\");\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    formatMaximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    formatMinimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    formatExclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    formatExclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `should be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nexports.formatLimitDefinition = {\n    keyword: Object.keys(KWDs),\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, keyword, it } = cxt;\n        const { opts, self } = it;\n        if (!opts.validateFormats)\n            return;\n        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n        if (fCxt.$data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fmt = gen.const(\"fmt\", (0, codegen_1._) `${fmts}[${fCxt.schemaCode}]`);\n            cxt.fail$data((0, codegen_1.or)((0, codegen_1._) `typeof ${fmt} != \"object\"`, (0, codegen_1._) `${fmt} instanceof RegExp`, (0, codegen_1._) `typeof ${fmt}.compare != \"function\"`, compareCode(fmt)));\n        }\n        function validateFormat() {\n            const format = fCxt.schema;\n            const fmtDef = self.formats[format];\n            if (!fmtDef || fmtDef === true)\n                return;\n            if (typeof fmtDef != \"object\" ||\n                fmtDef instanceof RegExp ||\n                typeof fmtDef.compare != \"function\") {\n                throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`);\n            }\n            const fmt = gen.scopeValue(\"formats\", {\n                key: format,\n                ref: fmtDef,\n                code: opts.code.formats ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : undefined,\n            });\n            cxt.fail$data(compareCode(fmt));\n        }\n        function compareCode(fmt) {\n            return (0, codegen_1._) `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;\n        }\n    },\n    dependencies: [\"format\"],\n};\nconst formatLimitPlugin = (ajv) => {\n    ajv.addKeyword(exports.formatLimitDefinition);\n    return ajv;\n};\nexports.default = formatLimitPlugin;\n//# sourceMappingURL=limit.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;\nconst core_1 = require(\"./core\");\nconst draft7_1 = require(\"./vocabularies/draft7\");\nconst discriminator_1 = require(\"./vocabularies/discriminator\");\nconst draft7MetaSchema = require(\"./refs/json-schema-draft-07.json\");\nconst META_SUPPORT_DATA = [\"/properties\"];\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\nclass Ajv extends core_1.default {\n    _addVocabularies() {\n        super._addVocabularies();\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n            this.addKeyword(discriminator_1.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta)\n            return;\n        const metaSchema = this.opts.$data\n            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n            : draft7MetaSchema;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return (this.opts.defaultMeta =\n            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));\n    }\n}\nexports.Ajv = Ajv;\nmodule.exports = exports = Ajv;\nmodule.exports.Ajv = Ajv;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Ajv;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nvar validation_error_1 = require(\"./runtime/validation_error\");\nObject.defineProperty(exports, \"ValidationError\", { enumerable: true, get: function () { return validation_error_1.default; } });\nvar ref_error_1 = require(\"./compile/ref_error\");\nObject.defineProperty(exports, \"MissingRefError\", { enumerable: true, get: function () { return ref_error_1.default; } });\n//# sourceMappingURL=ajv.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass _CodeOrName {\n}\nexports._CodeOrName = _CodeOrName;\nexports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass Name extends _CodeOrName {\n    constructor(s) {\n        super();\n        if (!exports.IDENTIFIER.test(s))\n            throw new Error(\"CodeGen: name must be a valid identifier\");\n        this.str = s;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        return false;\n    }\n    get names() {\n        return { [this.str]: 1 };\n    }\n}\nexports.Name = Name;\nclass _Code extends _CodeOrName {\n    constructor(code) {\n        super();\n        this._items = typeof code === \"string\" ? [code] : code;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        if (this._items.length > 1)\n            return false;\n        const item = this._items[0];\n        return item === \"\" || item === '\"\"';\n    }\n    get str() {\n        var _a;\n        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, \"\")));\n    }\n    get names() {\n        var _a;\n        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {\n            if (c instanceof Name)\n                names[c.str] = (names[c.str] || 0) + 1;\n            return names;\n        }, {})));\n    }\n}\nexports._Code = _Code;\nexports.nil = new _Code(\"\");\nfunction _(strs, ...args) {\n    const code = [strs[0]];\n    let i = 0;\n    while (i < args.length) {\n        addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n    }\n    return new _Code(code);\n}\nexports._ = _;\nconst plus = new _Code(\"+\");\nfunction str(strs, ...args) {\n    const expr = [safeStringify(strs[0])];\n    let i = 0;\n    while (i < args.length) {\n        expr.push(plus);\n        addCodeArg(expr, args[i]);\n        expr.push(plus, safeStringify(strs[++i]));\n    }\n    optimize(expr);\n    return new _Code(expr);\n}\nexports.str = str;\nfunction addCodeArg(code, arg) {\n    if (arg instanceof _Code)\n        code.push(...arg._items);\n    else if (arg instanceof Name)\n        code.push(arg);\n    else\n        code.push(interpolate(arg));\n}\nexports.addCodeArg = addCodeArg;\nfunction optimize(expr) {\n    let i = 1;\n    while (i < expr.length - 1) {\n        if (expr[i] === plus) {\n            const res = mergeExprItems(expr[i - 1], expr[i + 1]);\n            if (res !== undefined) {\n                expr.splice(i - 1, 3, res);\n                continue;\n            }\n            expr[i++] = \"+\";\n        }\n        i++;\n    }\n}\nfunction mergeExprItems(a, b) {\n    if (b === '\"\"')\n        return a;\n    if (a === '\"\"')\n        return b;\n    if (typeof a == \"string\") {\n        if (b instanceof Name || a[a.length - 1] !== '\"')\n            return;\n        if (typeof b != \"string\")\n            return `${a.slice(0, -1)}${b}\"`;\n        if (b[0] === '\"')\n            return a.slice(0, -1) + b.slice(1);\n        return;\n    }\n    if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name))\n        return `\"${a}${b.slice(1)}`;\n    return;\n}\nfunction strConcat(c1, c2) {\n    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;\n}\nexports.strConcat = strConcat;\n// TODO do not allow arrays here\nfunction interpolate(x) {\n    return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n        ? x\n        : safeStringify(Array.isArray(x) ? x.join(\",\") : x);\n}\nfunction stringify(x) {\n    return new _Code(safeStringify(x));\n}\nexports.stringify = stringify;\nfunction safeStringify(x) {\n    return JSON.stringify(x)\n        .replace(/\\u2028/g, \"\\\\u2028\")\n        .replace(/\\u2029/g, \"\\\\u2029\");\n}\nexports.safeStringify = safeStringify;\nfunction getProperty(key) {\n    return typeof key == \"string\" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;\n}\nexports.getProperty = getProperty;\n//Does best effort to format the name properly\nfunction getEsmExportName(key) {\n    if (typeof key == \"string\" && exports.IDENTIFIER.test(key)) {\n        return new _Code(`${key}`);\n    }\n    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n}\nexports.getEsmExportName = getEsmExportName;\nfunction regexpCode(rx) {\n    return new _Code(rx.toString());\n}\nexports.regexpCode = regexpCode;\n//# sourceMappingURL=code.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\nconst code_1 = require(\"./code\");\nconst scope_1 = require(\"./scope\");\nvar code_2 = require(\"./code\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return code_2._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return code_2.str; } });\nObject.defineProperty(exports, \"strConcat\", { enumerable: true, get: function () { return code_2.strConcat; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return code_2.nil; } });\nObject.defineProperty(exports, \"getProperty\", { enumerable: true, get: function () { return code_2.getProperty; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return code_2.stringify; } });\nObject.defineProperty(exports, \"regexpCode\", { enumerable: true, get: function () { return code_2.regexpCode; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return code_2.Name; } });\nvar scope_2 = require(\"./scope\");\nObject.defineProperty(exports, \"Scope\", { enumerable: true, get: function () { return scope_2.Scope; } });\nObject.defineProperty(exports, \"ValueScope\", { enumerable: true, get: function () { return scope_2.ValueScope; } });\nObject.defineProperty(exports, \"ValueScopeName\", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });\nObject.defineProperty(exports, \"varKinds\", { enumerable: true, get: function () { return scope_2.varKinds; } });\nexports.operators = {\n    GT: new code_1._Code(\">\"),\n    GTE: new code_1._Code(\">=\"),\n    LT: new code_1._Code(\"<\"),\n    LTE: new code_1._Code(\"<=\"),\n    EQ: new code_1._Code(\"===\"),\n    NEQ: new code_1._Code(\"!==\"),\n    NOT: new code_1._Code(\"!\"),\n    OR: new code_1._Code(\"||\"),\n    AND: new code_1._Code(\"&&\"),\n    ADD: new code_1._Code(\"+\"),\n};\nclass Node {\n    optimizeNodes() {\n        return this;\n    }\n    optimizeNames(_names, _constants) {\n        return this;\n    }\n}\nclass Def extends Node {\n    constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n    }\n    render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (!names[this.name.str])\n            return;\n        if (this.rhs)\n            this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n    }\n}\nclass Assign extends Node {\n    constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n    }\n    render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n            return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n    }\n}\nclass AssignOp extends Assign {\n    constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n    }\n    render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n    }\n}\nclass Label extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        return `${this.label}:` + _n;\n    }\n}\nclass Break extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n    }\n}\nclass Throw extends Node {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render({ _n }) {\n        return `throw ${this.error};` + _n;\n    }\n    get names() {\n        return this.error.names;\n    }\n}\nclass AnyCode extends Node {\n    constructor(code) {\n        super();\n        this.code = code;\n    }\n    render({ _n }) {\n        return `${this.code};` + _n;\n    }\n    optimizeNodes() {\n        return `${this.code}` ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n    }\n    get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n    }\n}\nclass ParentNode extends Node {\n    constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n    }\n    render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n    }\n    optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            const n = nodes[i].optimizeNodes();\n            if (Array.isArray(n))\n                nodes.splice(i, 1, ...n);\n            else if (n)\n                nodes[i] = n;\n            else\n                nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            // iterating backwards improves 1-pass optimization\n            const n = nodes[i];\n            if (n.optimizeNames(names, constants))\n                continue;\n            subtractNames(names, n.names);\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n    }\n}\nclass BlockNode extends ParentNode {\n    render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n    }\n}\nclass Root extends ParentNode {\n}\nclass Else extends BlockNode {\n}\nElse.kind = \"else\";\nclass If extends BlockNode {\n    constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n    }\n    render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n            code += \"else \" + this.else.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n            return this.nodes; // else is ignored here\n        let e = this.else;\n        if (e) {\n            const ns = e.optimizeNodes();\n            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n            if (cond === false)\n                return e instanceof If ? e : e.nodes;\n            if (this.nodes.length)\n                return this;\n            return new If(not(cond), e instanceof If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n            return undefined;\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n            return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n            addNames(names, this.else.names);\n        return names;\n    }\n}\nIf.kind = \"if\";\nclass For extends BlockNode {\n}\nFor.kind = \"for\";\nclass ForLoop extends For {\n    constructor(iteration) {\n        super();\n        this.iteration = iteration;\n    }\n    render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iteration.names);\n    }\n}\nclass ForRange extends For {\n    constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n    }\n    render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n    }\n    get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n    }\n}\nclass ForIter extends For {\n    constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n    }\n    render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iterable.names);\n    }\n}\nclass Func extends BlockNode {\n    constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n    }\n    render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n    }\n}\nFunc.kind = \"func\";\nclass Return extends ParentNode {\n    render(opts) {\n        return \"return \" + super.render(opts);\n    }\n}\nReturn.kind = \"return\";\nclass Try extends BlockNode {\n    render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch)\n            code += this.catch.render(opts);\n        if (this.finally)\n            code += this.finally.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        if (this.catch)\n            addNames(names, this.catch.names);\n        if (this.finally)\n            addNames(names, this.finally.names);\n        return names;\n    }\n}\nclass Catch extends BlockNode {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n    }\n}\nCatch.kind = \"catch\";\nclass Finally extends BlockNode {\n    render(opts) {\n        return \"finally\" + super.render(opts);\n    }\n}\nFinally.kind = \"finally\";\nclass CodeGen {\n    constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? \"\\n\" : \"\" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n    }\n    toString() {\n        return this._root.render(this.opts);\n    }\n    // returns unique name in the internal scope\n    name(prefix) {\n        return this._scope.name(prefix);\n    }\n    // reserves unique name in the external scope\n    scopeName(prefix) {\n        return this._extScope.name(prefix);\n    }\n    // reserves unique name in the external scope and assigns value to it\n    scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n        vs.add(name);\n        return name;\n    }\n    getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n    }\n    // return code that assigns values in the external scope to the names that are used internally\n    // (same names that were returned by gen.scopeName or gen.scopeValue)\n    scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n    }\n    scopeCode() {\n        return this._extScope.scopeCode(this._values);\n    }\n    _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== undefined && constant)\n            this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n    }\n    // `const` declaration (`var` in es5 mode)\n    const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n    }\n    // `let` declaration with optional assignment (`var` in es5 mode)\n    let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n    }\n    // `var` declaration with optional assignment\n    var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n    }\n    // assignment code\n    assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n    }\n    // `+=` code\n    add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n    }\n    // appends passed SafeExpr to code or executes Block\n    code(c) {\n        if (typeof c == \"function\")\n            c();\n        else if (c !== code_1.nil)\n            this._leafNode(new AnyCode(c));\n        return this;\n    }\n    // returns code for object literal for the passed argument list of key-value pairs\n    object(...keyValues) {\n        const code = [\"{\"];\n        for (const [key, value] of keyValues) {\n            if (code.length > 1)\n                code.push(\",\");\n            code.push(key);\n            if (key !== value || this.opts.es5) {\n                code.push(\":\");\n                (0, code_1.addCodeArg)(code, value);\n            }\n        }\n        code.push(\"}\");\n        return new code_1._Code(code);\n    }\n    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n    if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n            this.code(thenBody).else().code(elseBody).endIf();\n        }\n        else if (thenBody) {\n            this.code(thenBody).endIf();\n        }\n        else if (elseBody) {\n            throw new Error('CodeGen: \"else\" body without \"then\" body');\n        }\n        return this;\n    }\n    // `else if` clause - invalid without `if` or after `else` clauses\n    elseIf(condition) {\n        return this._elseNode(new If(condition));\n    }\n    // `else` clause - only valid after `if` or `else if` clauses\n    else() {\n        return this._elseNode(new Else());\n    }\n    // end `if` statement (needed if gen.if was used only with condition)\n    endIf() {\n        return this._endBlockNode(If, Else);\n    }\n    _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n            this.code(forBody).endFor();\n        return this;\n    }\n    // a generic `for` clause (or statement if `forBody` is passed)\n    for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n    }\n    // `for` statement for a range of values\n    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n    }\n    // `for-of` statement (in es5 mode replace with a normal for loop)\n    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n            const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n            return this.forRange(\"_i\", 0, (0, code_1._) `${arr}.length`, (i) => {\n                this.var(name, (0, code_1._) `${arr}[${i}]`);\n                forBody(name);\n            });\n        }\n        return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n    }\n    // `for-in` statement.\n    // With option `ownProperties` replaced with a `for-of` loop for object keys\n    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n    }\n    // end `for` loop\n    endFor() {\n        return this._endBlockNode(For);\n    }\n    // `label` statement\n    label(label) {\n        return this._leafNode(new Label(label));\n    }\n    // `break` statement\n    break(label) {\n        return this._leafNode(new Break(label));\n    }\n    // `return` statement\n    return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n            throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode(Return);\n    }\n    // `try` statement\n    try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n            throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n            const error = this.name(\"e\");\n            this._currNode = node.catch = new Catch(error);\n            catchCode(error);\n        }\n        if (finallyCode) {\n            this._currNode = node.finally = new Finally();\n            this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n    }\n    // `throw` statement\n    throw(error) {\n        return this._leafNode(new Throw(error));\n    }\n    // start self-balancing block\n    block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n            this.code(body).endBlock(nodeCount);\n        return this;\n    }\n    // end the current self-balancing block\n    endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === undefined)\n            throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n    }\n    // `function` heading (or definition if funcBody is passed)\n    func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n            this.code(funcBody).endFunc();\n        return this;\n    }\n    // end function definition\n    endFunc() {\n        return this._endBlockNode(Func);\n    }\n    optimize(n = 1) {\n        while (n-- > 0) {\n            this._root.optimizeNodes();\n            this._root.optimizeNames(this._root.names, this._constants);\n        }\n    }\n    _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n    }\n    _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n    }\n    _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || (N2 && n instanceof N2)) {\n            this._nodes.pop();\n            return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n    }\n    _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n            throw new Error('CodeGen: \"else\" without \"if\"');\n        }\n        this._currNode = n.else = node;\n        return this;\n    }\n    get _root() {\n        return this._nodes[0];\n    }\n    get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n    }\n    set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n    }\n}\nexports.CodeGen = CodeGen;\nfunction addNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n    return names;\n}\nfunction addExprNames(names, from) {\n    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\nfunction optimizeExpr(expr, names, constants) {\n    if (expr instanceof code_1.Name)\n        return replaceName(expr);\n    if (!canOptimize(expr))\n        return expr;\n    return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n            c = replaceName(c);\n        if (c instanceof code_1._Code)\n            items.push(...c._items);\n        else\n            items.push(c);\n        return items;\n    }, []));\n    function replaceName(n) {\n        const c = constants[n.str];\n        if (c === undefined || names[n.str] !== 1)\n            return n;\n        delete names[n.str];\n        return c;\n    }\n    function canOptimize(e) {\n        return (e instanceof code_1._Code &&\n            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));\n    }\n}\nfunction subtractNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction not(x) {\n    return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._) `!${par(x)}`;\n}\nexports.not = not;\nconst andCode = mappend(exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction and(...args) {\n    return args.reduce(andCode);\n}\nexports.and = and;\nconst orCode = mappend(exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction or(...args) {\n    return args.reduce(orCode);\n}\nexports.or = or;\nfunction mappend(op) {\n    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);\n}\nfunction par(x) {\n    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = require(\"./code\");\nclass ValueError extends Error {\n    constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n    UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n    UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));\nexports.varKinds = {\n    const: new code_1.Name(\"const\"),\n    let: new code_1.Name(\"let\"),\n    var: new code_1.Name(\"var\"),\n};\nclass Scope {\n    constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {\n            throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return (this._names[prefix] = { prefix, index: 0 });\n    }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n    constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;\n    }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._) `\\n`;\nclass ValueScope extends Scope {\n    constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined)\n            throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name)\n                return _name;\n        }\n        else {\n            vs = this._values[prefix] = new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n            return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n            if (name.scopePath === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return (0, code_1._) `${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n            if (name.value === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n            const vs = values[prefix];\n            if (!vs)\n                continue;\n            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());\n            vs.forEach((name) => {\n                if (nameSet.has(name))\n                    return;\n                nameSet.set(name, UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;\n                }\n                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {\n                    code = (0, code_1._) `${code}${c}${this.opts._n}`;\n                }\n                else {\n                    throw new ValueError(name);\n                }\n                nameSet.set(name, UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nexports.ValueScope = ValueScope;\n//# sourceMappingURL=scope.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst util_1 = require(\"./util\");\nconst names_1 = require(\"./names\");\nexports.keywordError = {\n    message: ({ keyword }) => (0, codegen_1.str) `must pass \"${keyword}\" keyword validation`,\n};\nexports.keyword$DataError = {\n    message: ({ keyword, schemaType }) => schemaType\n        ? (0, codegen_1.str) `\"${keyword}\" keyword must be ${schemaType} ($data)`\n        : (0, codegen_1.str) `\"${keyword}\" keyword is invalid ($data)`,\n};\nfunction reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {\n        addError(gen, errObj);\n    }\n    else {\n        returnErrors(it, (0, codegen_1._) `[${errObj}]`);\n    }\n}\nexports.reportError = reportError;\nfunction reportExtraError(cxt, error = exports.keywordError, errorPaths) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    addError(gen, errObj);\n    if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n    }\n}\nexports.reportExtraError = reportExtraError;\nfunction resetErrorsCount(gen, errsCount) {\n    gen.assign(names_1.default.errors, errsCount);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\nexports.resetErrorsCount = resetErrorsCount;\nfunction extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {\n    /* istanbul ignore if */\n    if (errsCount === undefined)\n        throw new Error(\"ajv implementation error\");\n    const err = gen.name(\"err\");\n    gen.forRange(\"i\", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);\n        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);\n            gen.assign((0, codegen_1._) `${err}.data`, data);\n        }\n    });\n}\nexports.extendErrors = extendErrors;\nfunction addError(gen, errObj) {\n    const err = gen.const(\"err\", errObj);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);\n    gen.code((0, codegen_1._) `${names_1.default.errors}++`);\n}\nfunction returnErrors(it, errs) {\n    const { gen, validateName, schemaEnv } = it;\n    if (schemaEnv.$async) {\n        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);\n        gen.return(false);\n    }\n}\nconst E = {\n    keyword: new codegen_1.Name(\"keyword\"),\n    schemaPath: new codegen_1.Name(\"schemaPath\"), // also used in JTD errors\n    params: new codegen_1.Name(\"params\"),\n    propertyName: new codegen_1.Name(\"propertyName\"),\n    message: new codegen_1.Name(\"message\"),\n    schema: new codegen_1.Name(\"schema\"),\n    parentSchema: new codegen_1.Name(\"parentSchema\"),\n};\nfunction errorObjectCode(cxt, error, errorPaths) {\n    const { createErrors } = cxt.it;\n    if (createErrors === false)\n        return (0, codegen_1._) `{}`;\n    return errorObject(cxt, error, errorPaths);\n}\nfunction errorObject(cxt, error, errorPaths = {}) {\n    const { gen, it } = cxt;\n    const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths),\n    ];\n    extraErrorProps(cxt, error, keyValues);\n    return gen.object(...keyValues);\n}\nfunction errorInstancePath({ errorPath }, { instancePath }) {\n    const instPath = instancePath\n        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`\n        : errorPath;\n    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n}\nfunction errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;\n    if (schemaPath) {\n        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n    }\n    return [E.schemaPath, schPath];\n}\nfunction extraErrorProps(cxt, { params, message }, keyValues) {\n    const { keyword, data, schemaValue, it } = cxt;\n    const { opts, propertyName, topSchemaRef, schemaPath } = it;\n    keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || (0, codegen_1._) `{}`]);\n    if (opts.messages) {\n        keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n    }\n    if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n    }\n    if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n}\n//# sourceMappingURL=errors.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"./codegen\");\nconst names = {\n    // validation function arguments\n    data: new codegen_1.Name(\"data\"), // data passed to validation function\n    // args passed from referencing schema\n    valCxt: new codegen_1.Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n    instancePath: new codegen_1.Name(\"instancePath\"),\n    parentData: new codegen_1.Name(\"parentData\"),\n    parentDataProperty: new codegen_1.Name(\"parentDataProperty\"),\n    rootData: new codegen_1.Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n    dynamicAnchors: new codegen_1.Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n    // function scoped variables\n    vErrors: new codegen_1.Name(\"vErrors\"), // null or array of validation errors\n    errors: new codegen_1.Name(\"errors\"), // counter of validation errors\n    this: new codegen_1.Name(\"this\"),\n    // \"globals\"\n    self: new codegen_1.Name(\"self\"),\n    scope: new codegen_1.Name(\"scope\"),\n    // JTD serialize/parse name for JSON string and position\n    json: new codegen_1.Name(\"json\"),\n    jsonPos: new codegen_1.Name(\"jsonPos\"),\n    jsonLen: new codegen_1.Name(\"jsonLen\"),\n    jsonPart: new codegen_1.Name(\"jsonPart\"),\n};\nexports.default = names;\n//# sourceMappingURL=names.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst resolve_1 = require(\"./resolve\");\nclass MissingRefError extends Error {\n    constructor(resolver, baseId, ref, msg) {\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));\n    }\n}\nexports.default = MissingRefError;\n//# sourceMappingURL=ref_error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst traverse = require(\"json-schema-traverse\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let innerBaseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            innerBaseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = innerBaseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n//# sourceMappingURL=resolve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRules = exports.isJSONType = void 0;\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"];\nconst jsonTypes = new Set(_jsonTypes);\nfunction isJSONType(x) {\n    return typeof x == \"string\" && jsonTypes.has(x);\n}\nexports.isJSONType = isJSONType;\nfunction getRules() {\n    const groups = {\n        number: { type: \"number\", rules: [] },\n        string: { type: \"string\", rules: [] },\n        array: { type: \"array\", rules: [] },\n        object: { type: \"object\", rules: [] },\n    };\n    return {\n        types: { ...groups, integer: true, boolean: true, null: true },\n        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],\n        post: { rules: [] },\n        all: {},\n        keywords: {},\n    };\n}\nexports.getRules = getRules;\n//# sourceMappingURL=rules.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst code_1 = require(\"./codegen/code\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === \"boolean\")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: \"${key}\"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n            return schema;\n        if (typeof schema == \"string\")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == \"number\")\n        return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var(\"items\", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type || (exports.Type = Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `\"[\" + ${dataProp} + \"]\"`\n                : (0, codegen_1._) `\"['\" + ${dataProp} + \"']\"`\n            : isNumber\n                ? (0, codegen_1._) `\"/\" + ${dataProp}`\n                : (0, codegen_1._) `\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n//# sourceMappingURL=util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;\nfunction schemaHasRulesForType({ schema, self }, type) {\n    const group = self.RULES.types[type];\n    return group && group !== true && shouldUseGroup(schema, group);\n}\nexports.schemaHasRulesForType = schemaHasRulesForType;\nfunction shouldUseGroup(schema, group) {\n    return group.rules.some((rule) => shouldUseRule(schema, rule));\n}\nexports.shouldUseGroup = shouldUseGroup;\nfunction shouldUseRule(schema, rule) {\n    var _a;\n    return (schema[rule.keyword] !== undefined ||\n        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));\n}\nexports.shouldUseRule = shouldUseRule;\n//# sourceMappingURL=applicability.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = require(\"../rules\");\nconst applicability_1 = require(\"./applicability\");\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType || (exports.DataType = DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n//# sourceMappingURL=dataType.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assignDefaults = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nfunction assignDefaults(it, ty) {\n    const { properties, items } = it.schema;\n    if (ty === \"object\" && properties) {\n        for (const key in properties) {\n            assignDefault(it, key, properties[key].default);\n        }\n    }\n    else if (ty === \"array\" && Array.isArray(items)) {\n        items.forEach((sch, i) => assignDefault(it, i, sch.default));\n    }\n}\nexports.assignDefaults = assignDefaults;\nfunction assignDefault(it, prop, defaultValue) {\n    const { gen, compositeRule, data, opts } = it;\n    if (defaultValue === undefined)\n        return;\n    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;\n    if (compositeRule) {\n        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n    }\n    let condition = (0, codegen_1._) `${childData} === undefined`;\n    if (opts.useDefaults === \"empty\") {\n        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === \"\"`;\n    }\n    // `${childData} === undefined` +\n    // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);\n}\n//# sourceMappingURL=defaults.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction narrowSchemaTypes(it, withTypes) {\n    const ts = [];\n    for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n            ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\")\n            ts.push(\"integer\");\n    }\n    it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nfunction getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {\n    if (keyword !== undefined && schema !== undefined) {\n        throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n    }\n    if (keyword !== undefined) {\n        const sch = it.schema[keyword];\n        return schemaProp === undefined\n            ? {\n                schema: sch,\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n            }\n            : {\n                schema: sch[schemaProp],\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,\n            };\n    }\n    if (schema !== undefined) {\n        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n            throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n        }\n        return {\n            schema,\n            schemaPath,\n            topSchemaRef,\n            errSchemaPath,\n        };\n    }\n    throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nexports.getSubschema = getSubschema;\nfunction extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {\n    if (data !== undefined && dataProp !== undefined) {\n        throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n    }\n    const { gen } = it;\n    if (dataProp !== undefined) {\n        const { errorPath, dataPathArr, opts } = it;\n        const nextData = gen.let(\"data\", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;\n        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n    }\n    if (data !== undefined) {\n        const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n        dataContextProps(nextData);\n        if (propertyName !== undefined)\n            subschema.propertyName = propertyName;\n        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n    }\n    if (dataTypes)\n        subschema.dataTypes = dataTypes;\n    function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [...it.dataNames, _nextData];\n    }\n}\nexports.extendSubschemaData = extendSubschemaData;\nfunction extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {\n    if (compositeRule !== undefined)\n        subschema.compositeRule = compositeRule;\n    if (createErrors !== undefined)\n        subschema.createErrors = createErrors;\n    if (allErrors !== undefined)\n        subschema.allErrors = allErrors;\n    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n    subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nexports.extendSubschemaMode = extendSubschemaMode;\n//# sourceMappingURL=subschema.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nexports.default = Ajv;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://github.com/ajv-validator/ajv/issues/889\nconst equal = require(\"fast-deep-equal\");\nequal.code = 'require(\"ajv/dist/runtime/equal\").default';\nexports.default = equal;\n//# sourceMappingURL=equal.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n    const len = str.length;\n    let length = 0;\n    let pos = 0;\n    let value;\n    while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n            // high surrogate, and there is a next character\n            value = str.charCodeAt(pos);\n            if ((value & 0xfc00) === 0xdc00)\n                pos++; // low surrogate\n        }\n    }\n    return length;\n}\nexports.default = ucs2length;\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n//# sourceMappingURL=ucs2length.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst uri = require(\"fast-uri\");\nuri.code = 'require(\"ajv/dist/runtime/uri\").default';\nexports.default = uri;\n//# sourceMappingURL=uri.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ValidationError extends Error {\n    constructor(errors) {\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n    }\n}\nexports.default = ValidationError;\n//# sourceMappingURL=validation_error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = def;\n//# sourceMappingURL=additionalItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must NOT have additional properties\",\n    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,\n};\nconst def = {\n    keyword: \"additionalProperties\",\n    type: [\"object\"],\n    schemaType: [\"boolean\", \"object\"],\n    allowUndefined: true,\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error(\"ajv implementation error\");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n            gen.forIn(\"key\", data, (key) => {\n                if (!props.length && !patProps.length)\n                    additionalPropertyCode(key);\n                else\n                    gen.if(isAdditional(key), () => additionalPropertyCode(key));\n            });\n        }\n        function isAdditional(key) {\n            let definedProp;\n            if (props.length > 8) {\n                // TODO maybe an option instead of hard-coded 8?\n                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n            }\n            else if (props.length) {\n                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));\n            }\n            else {\n                definedProp = codegen_1.nil;\n            }\n            if (patProps.length) {\n                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n            }\n            return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n            gen.code((0, codegen_1._) `delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n            if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n                deleteAdditional(key);\n                return;\n            }\n            if (schema === false) {\n                cxt.setParams({ additionalProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                if (opts.removeAdditional === \"failing\") {\n                    applyAdditionalSchema(key, valid, false);\n                    gen.if((0, codegen_1.not)(valid), () => {\n                        cxt.reset();\n                        deleteAdditional(key);\n                    });\n                }\n                else {\n                    applyAdditionalSchema(key, valid);\n                    if (!allErrors)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                }\n            }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n            const subschema = {\n                keyword: \"additionalProperties\",\n                dataProp: key,\n                dataPropType: util_1.Type.Str,\n            };\n            if (errors === false) {\n                Object.assign(subschema, {\n                    compositeRule: true,\n                    createErrors: false,\n                    allErrors: false,\n                });\n            }\n            cxt.subschema(subschema, valid);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=additionalProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports.default = def;\n//# sourceMappingURL=allOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"anyOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    code: code_1.validateUnion,\n    error: { message: \"must match a schema in anyOf\" },\n};\nexports.default = def;\n//# sourceMappingURL=anyOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=contains.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nexports.error = {\n    message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n};\nconst def = {\n    keyword: \"dependencies\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: exports.error,\n    code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n    },\n};\nfunction splitDependencies({ schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for (const key in schema) {\n        if (key === \"__proto__\")\n            continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen, data, it } = cxt;\n    if (Object.keys(propertyDeps).length === 0)\n        return;\n    const missing = gen.let(\"missing\");\n    for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n            continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(\", \"),\n        });\n        if (it.allErrors) {\n            gen.if(hasProperty, () => {\n                for (const depProp of deps) {\n                    (0, code_1.checkReportMissingProp)(cxt, depProp);\n                }\n            });\n        }\n        else {\n            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n            continue;\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, () => gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = def;\n//# sourceMappingURL=dependencies.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports.default = def;\n//# sourceMappingURL=if.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst additionalItems_1 = require(\"./additionalItems\");\nconst prefixItems_1 = require(\"./prefixItems\");\nconst items_1 = require(\"./items\");\nconst items2020_1 = require(\"./items2020\");\nconst contains_1 = require(\"./contains\");\nconst dependencies_1 = require(\"./dependencies\");\nconst propertyNames_1 = require(\"./propertyNames\");\nconst additionalProperties_1 = require(\"./additionalProperties\");\nconst properties_1 = require(\"./properties\");\nconst patternProperties_1 = require(\"./patternProperties\");\nconst not_1 = require(\"./not\");\nconst anyOf_1 = require(\"./anyOf\");\nconst oneOf_1 = require(\"./oneOf\");\nconst allOf_1 = require(\"./allOf\");\nconst if_1 = require(\"./if\");\nconst thenElse_1 = require(\"./thenElse\");\nfunction getApplicator(draft2020 = false) {\n    const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default,\n    ];\n    // array\n    if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n    else\n        applicator.push(additionalItems_1.default, items_1.default);\n    applicator.push(contains_1.default);\n    return applicator;\n}\nexports.default = getApplicator;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;\n//# sourceMappingURL=items.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst additionalItems_1 = require(\"./additionalItems\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        if (prefixItems)\n            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n            cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nexports.default = def;\n//# sourceMappingURL=items2020.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: \"must NOT be valid\" },\n};\nexports.default = def;\n//# sourceMappingURL=not.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=oneOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=patternProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst items_1 = require(\"./items\");\nconst def = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\"array\"],\n    before: \"uniqueItems\",\n    code: (cxt) => (0, items_1.validateTuple)(cxt, \"items\"),\n};\nexports.default = def;\n//# sourceMappingURL=prefixItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_1 = require(\"../../compile/validate\");\nconst code_1 = require(\"../code\");\nconst util_1 = require(\"../../compile/util\");\nconst additionalProperties_1 = require(\"./additionalProperties\");\nconst def = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n            it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n            return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties) {\n            if (hasDefault(prop)) {\n                applyPropertySchema(prop);\n            }\n            else {\n                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n                applyPropertySchema(prop);\n                if (!it.allErrors)\n                    gen.else().var(valid, true);\n                gen.endIf();\n            }\n            cxt.it.definedProperties.add(prop);\n            cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n        }\n        function applyPropertySchema(prop) {\n            cxt.subschema({\n                keyword: \"properties\",\n                schemaProp: prop,\n                dataProp: prop,\n            }, valid);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=properties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"property name must be valid\",\n    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,\n};\nconst def = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\"object\", \"boolean\"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key) => {\n            cxt.setParams({ propertyName: key });\n            cxt.subschema({\n                keyword: \"propertyNames\",\n                data: key,\n                dataTypes: [\"string\"],\n                propertyName: key,\n                compositeRule: true,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), () => {\n                cxt.error(true);\n                if (!it.allErrors)\n                    gen.break();\n            });\n        });\n        cxt.ok(valid);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=propertyNames.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: [\"then\", \"else\"],\n    schemaType: [\"object\", \"boolean\"],\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === undefined)\n            (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=thenElse.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = require(\"../compile/codegen\");\nconst util_1 = require(\"../compile/util\");\nconst names_1 = require(\"../compile/names\");\nconst util_2 = require(\"../compile/util\");\nfunction checkReportMissingProp(cxt, prop) {\n    const { gen, data, it } = cxt;\n    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);\n        cxt.error();\n    });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp({ gen, data, it: { opts } }, properties, missing) {\n    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n    cxt.setParams({ missingProperty: missing }, true);\n    cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n    return gen.scopeValue(\"func\", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,\n    });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {\n    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n    const valCxt = [\n        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],\n        [names_1.default.parentData, it.parentData],\n        [names_1.default.parentDataProperty, it.parentDataProperty],\n        [names_1.default.rootData, names_1.default.rootData],\n    ];\n    if (it.opts.dynamicRef)\n        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;\n    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._) `new RegExp`;\nfunction usePattern({ gen, it: { opts } }, pattern) {\n    const u = opts.unicodeRegExp ? \"u\" : \"\";\n    const { regExp } = opts.code;\n    const rx = regExp(pattern, u);\n    return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._) `${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,\n    });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    if (it.allErrors) {\n        const validArr = gen.let(\"valid\", true);\n        validateItems(() => gen.assign(validArr, false));\n        return validArr;\n    }\n    gen.var(valid, true);\n    validateItems(() => gen.break());\n    return valid;\n    function validateItems(notValid) {\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        gen.forRange(\"i\", 0, len, (i) => {\n            cxt.subschema({\n                keyword,\n                dataProp: i,\n                dataPropType: util_1.Type.Num,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), notValid);\n        });\n    }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n    const { gen, schema, keyword, it } = cxt;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema))\n        throw new Error(\"ajv implementation error\");\n    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));\n    if (alwaysValid && !it.opts.unevaluated)\n        return;\n    const valid = gen.let(\"valid\", false);\n    const schValid = gen.name(\"_valid\");\n    gen.block(() => schema.forEach((_sch, i) => {\n        const schCxt = cxt.subschema({\n            keyword,\n            schemaProp: i,\n            compositeRule: true,\n        }, schValid);\n        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);\n        const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n        // or if all properties and items were evaluated (it.props === true && it.items === true)\n        if (!merged)\n            gen.if((0, codegen_1.not)(valid));\n    }));\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;\n//# sourceMappingURL=code.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst def = {\n    keyword: \"id\",\n    code() {\n        throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n    },\n};\nexports.default = def;\n//# sourceMappingURL=id.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst id_1 = require(\"./id\");\nconst ref_1 = require(\"./ref\");\nconst core = [\n    \"$schema\",\n    \"$id\",\n    \"$defs\",\n    \"$vocabulary\",\n    { keyword: \"$comment\" },\n    \"definitions\",\n    id_1.default,\n    ref_1.default,\n];\nexports.default = core;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports.default = def;\n//# sourceMappingURL=ref.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst types_1 = require(\"../discriminator/types\");\nconst compile_1 = require(\"../../compile\");\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    const ref = sch.$ref;\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                    if (sch === undefined)\n                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiscrError = void 0;\nvar DiscrError;\n(function (DiscrError) {\n    DiscrError[\"Tag\"] = \"tag\";\n    DiscrError[\"Mapping\"] = \"mapping\";\n})(DiscrError || (exports.DiscrError = DiscrError = {}));\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"./core\");\nconst validation_1 = require(\"./validation\");\nconst applicator_1 = require(\"./applicator\");\nconst format_1 = require(\"./format\");\nconst metadata_1 = require(\"./metadata\");\nconst draft7Vocabularies = [\n    core_1.default,\n    validation_1.default,\n    (0, applicator_1.default)(),\n    format_1.default,\n    metadata_1.metadataVocabulary,\n    metadata_1.contentVocabulary,\n];\nexports.default = draft7Vocabularies;\n//# sourceMappingURL=draft7.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || \"string\"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=format.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst format_1 = require(\"./format\");\nconst format = [format_1.default];\nexports.default = format;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.contentVocabulary = exports.metadataVocabulary = void 0;\nexports.metadataVocabulary = [\n    \"title\",\n    \"description\",\n    \"default\",\n    \"deprecated\",\n    \"readOnly\",\n    \"writeOnly\",\n    \"examples\",\n];\nexports.contentVocabulary = [\n    \"contentMediaType\",\n    \"contentEncoding\",\n    \"contentSchema\",\n];\n//# sourceMappingURL=metadata.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to constant\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"const\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || (schema && typeof schema == \"object\")) {\n            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        }\n        else {\n            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=const.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=enum.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst limitNumber_1 = require(\"./limitNumber\");\nconst multipleOf_1 = require(\"./multipleOf\");\nconst limitLength_1 = require(\"./limitLength\");\nconst pattern_1 = require(\"./pattern\");\nconst limitProperties_1 = require(\"./limitProperties\");\nconst required_1 = require(\"./required\");\nconst limitItems_1 = require(\"./limitItems\");\nconst uniqueItems_1 = require(\"./uniqueItems\");\nconst const_1 = require(\"./const\");\nconst enum_1 = require(\"./enum\");\nconst validation = [\n    // number\n    limitNumber_1.default,\n    multipleOf_1.default,\n    // string\n    limitLength_1.default,\n    pattern_1.default,\n    // object\n    limitProperties_1.default,\n    required_1.default,\n    // array\n    limitItems_1.default,\n    uniqueItems_1.default,\n    // any\n    { keyword: \"type\", schemaType: [\"string\", \"array\"] },\n    { keyword: \"nullable\", schemaType: \"boolean\" },\n    const_1.default,\n    enum_1.default,\n];\nexports.default = validation;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxItems\", \"minItems\"],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst ucs2length_1 = require(\"../../runtime/ucs2length\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxLength\", \"minLength\"],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === \"maxLength\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitLength.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    maximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    minimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    exclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    exclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: Object.keys(KWDs),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitNumber.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxProperties\", \"minProperties\"],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec\n            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n            : (0, codegen_1._) `${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=multipleOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        // TODO regexp should be wrapped in try/catchs\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=pattern.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=required.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataType_1 = require(\"../../compile/validate/dataType\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, codegen_1._) `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == \"string\"`, (0, codegen_1._) `${item} += \"_\"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=uniqueItems.js.map","/**\n * copied and adapted from npm 'binary-search-insert'\n * @link https://www.npmjs.com/package/binary-search-insert\n */\nexport function pushAtSortPosition(array, item, compareFunction, low) {\n  var length = array.length;\n  var high = length - 1;\n  var mid = 0;\n\n  /**\n   * Optimization shortcut.\n   */\n  if (length === 0) {\n    array.push(item);\n    return 0;\n  }\n\n  /**\n   * So we do not have to get the ret[mid] doc again\n   * at the last we store it here.\n   */\n  var lastMidDoc;\n  while (low <= high) {\n    // https://github.com/darkskyapp/binary-search\n    // http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html\n    mid = low + (high - low >> 1);\n    lastMidDoc = array[mid];\n    if (compareFunction(lastMidDoc, item) <= 0.0) {\n      // searching too low\n      low = mid + 1;\n    } else {\n      // searching too high\n      high = mid - 1;\n    }\n  }\n  if (compareFunction(lastMidDoc, item) <= 0.0) {\n    mid++;\n  }\n\n  /**\n   * Insert at correct position\n   */\n  array.splice(mid, 0, item);\n  return mid;\n}","import { splitStringToChunks } from '../util.js';\nimport { getNumberOfChar } from './string-format.js';\nexport function minimalStringToSimpleBdd(str) {\n    const nodesById = new Map();\n    // parse leaf nodes\n    const leafNodeAmount = parseInt(str.charAt(0) + str.charAt(1), 10);\n    const lastLeafNodeChar = (2 + leafNodeAmount * 2);\n    const leafNodeChars = str.substring(2, lastLeafNodeChar);\n    const leafNodeChunks = splitStringToChunks(leafNodeChars, 2);\n    for (let i = 0; i < leafNodeChunks.length; i++) {\n        const chunk = leafNodeChunks[i];\n        const id = chunk.charAt(0);\n        const value = getNumberOfChar(chunk.charAt(1));\n        nodesById.set(id, value);\n    }\n    // parse internal nodes\n    const internalNodeChars = str.substring(lastLeafNodeChar, str.length - 3);\n    const internalNodeChunks = splitStringToChunks(internalNodeChars, 4);\n    for (let i = 0; i < internalNodeChunks.length; i++) {\n        const chunk = internalNodeChunks[i];\n        const id = chunk.charAt(0);\n        const idOf0Branch = chunk.charAt(1);\n        const idOf1Branch = chunk.charAt(2);\n        const level = getNumberOfChar(chunk.charAt(3));\n        if (!nodesById.has(idOf0Branch)) {\n            throw new Error('missing node with id ' + idOf0Branch);\n        }\n        if (!nodesById.has(idOf1Branch)) {\n            throw new Error('missing node with id ' + idOf1Branch);\n        }\n        const node0 = nodesById.get(idOf0Branch);\n        const node1 = nodesById.get(idOf1Branch);\n        const node = {\n            l: level, // level is first for prettier json output\n            0: node0,\n            1: node1\n        };\n        nodesById.set(id, node);\n    }\n    // parse root node\n    const last3 = str.slice(-3);\n    const idOf0 = last3.charAt(0);\n    const idOf1 = last3.charAt(1);\n    const levelOfRoot = getNumberOfChar(last3.charAt(2));\n    const nodeOf0 = nodesById.get(idOf0);\n    const nodeOf1 = nodesById.get(idOf1);\n    const rootNode = {\n        l: levelOfRoot,\n        0: nodeOf0,\n        1: nodeOf1,\n    };\n    return rootNode;\n}\n//# sourceMappingURL=minimal-string-to-simple-bdd.js.map","import { booleanToBooleanString } from '../util.js';\nexport function resolveWithSimpleBdd(simpleBdd, fns, input) {\n    let currentNode = simpleBdd;\n    let currentLevel = simpleBdd.l;\n    while (true) {\n        const booleanResult = fns[currentLevel](input);\n        const branchKey = booleanToBooleanString(booleanResult);\n        currentNode = currentNode[branchKey];\n        if (typeof currentNode === 'number' || typeof currentNode === 'string') {\n            return currentNode;\n        }\n        else {\n            currentLevel = currentNode.l;\n        }\n    }\n}\n//# sourceMappingURL=resolve-with-simple-bdd.js.map","/*\nlet t = 0;\nwhile (t < 10000) {\n    const char = String.fromCharCode(t);\n    console.log(t + ' : ' + char);\n    t++;\n}\n*/\n/*\n\nTo have a really small string representation, we have to hack some stuff\nwhich makes is complicated but effective.\n\nRules for the string:\n- The string starts with a number like '23' that defines how many leaf-nodes we have\n- leaf nodes consist of two chars like 'ab'\n    - the first char is the id\n    - the second the value is a number you can get via String.charCodeAt()\n- Internal nodes have four chars like 'abcd'\n    - the first char is the id\n    - the second char is the id of the 0-branch\n    - the third char is the id of the 1-branch\n    - the last char is the id of the boolean-function (= level)\n- The last 3 chars of the string is the root node like 'abc'\n    - it looks like the internal-node but without the id (first char)\n\n*/\n// we use this because 39 is the quotes which causes problems\nexport const CHAR_CODE_OFFSET = 40; // String.fromCharCode(33) === ')'\nexport function getCharOfLevel(level) {\n    const charCode = CHAR_CODE_OFFSET + level;\n    return String.fromCharCode(charCode);\n}\nexport function getNumberOfChar(char) {\n    const charCode = char.charCodeAt(0);\n    return charCode - CHAR_CODE_OFFSET;\n}\nexport function getCharOfValue(value) {\n    const charCode = CHAR_CODE_OFFSET + value;\n    return String.fromCharCode(charCode);\n}\nexport const FIRST_CHAR_CODE_FOR_ID = 97; // String.fromCharCode(97) === 'a'\nexport function getNextCharId(lastCode) {\n    // jump these codes because they look strange\n    if (lastCode >= 128 && lastCode <= 160) {\n        lastCode = 161;\n    }\n    const char = String.fromCharCode(lastCode);\n    return {\n        char,\n        nextCode: lastCode + 1\n    };\n}\n//# sourceMappingURL=string-format.js.map","export function booleanStringToBoolean(str) {\n    if (str === '1') {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function booleanToBooleanString(b) {\n    if (b) {\n        return '1';\n    }\n    else {\n        return '0';\n    }\n}\nexport function oppositeBoolean(input) {\n    if (input === '1') {\n        return '0';\n    }\n    else {\n        return '1';\n    }\n}\nexport function lastChar(str) {\n    return str.slice(-1);\n}\n/**\n * @link https://stackoverflow.com/a/1349426\n */\nfunction makeid(length = 6) {\n    let result = '';\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    const charactersLength = characters.length;\n    for (let i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    }\n    return result;\n}\nconst nodeIdPrefix = makeid(4);\nlet lastIdGen = 0;\nexport function nextNodeId() {\n    const ret = 'node_' + nodeIdPrefix + '_' + lastIdGen;\n    lastIdGen++;\n    return ret;\n}\n/**\n * @link https://stackoverflow.com/a/16155417\n */\nexport function decimalToPaddedBinary(decimal, padding) {\n    const binary = (decimal >>> 0).toString(2);\n    const padded = binary.padStart(padding, '0');\n    return padded;\n}\nexport function oppositeBinary(i) {\n    if (i === '1') {\n        return '0';\n    }\n    else if (i === '0') {\n        return '1';\n    }\n    else {\n        throw new Error('non-binary given');\n    }\n}\nexport function binaryToDecimal(binary) {\n    return parseInt(binary, 2);\n}\nexport function minBinaryWithLength(length) {\n    return new Array(length).fill(0).map(() => '0').join('');\n}\nexport function maxBinaryWithLength(length) {\n    return new Array(length).fill(0).map(() => '1').join('');\n}\nexport function getNextStateSet(stateSet) {\n    const decimal = binaryToDecimal(stateSet);\n    const increase = decimal + 1;\n    const binary = decimalToPaddedBinary(increase, stateSet.length);\n    return binary;\n}\nexport function firstKeyOfMap(map) {\n    const iterator1 = map.keys();\n    return iterator1.next().value;\n}\n/**\n * Shuffles array in place. ES6 version\n * @link https://stackoverflow.com/a/6274381\n */\nexport function shuffleArray(a) {\n    for (let i = a.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [a[j], a[i]];\n    }\n    return a;\n}\nexport function lastOfArray(ar) {\n    return ar[ar.length - 1];\n}\n/**\n * @link https://stackoverflow.com/a/6259536\n */\nexport function splitStringToChunks(str, chunkSize) {\n    const chunks = [];\n    for (let i = 0, charsLength = str.length; i < charsLength; i += chunkSize) {\n        chunks.push(str.substring(i, i + chunkSize));\n    }\n    return chunks;\n}\n//# sourceMappingURL=util.js.map","import { isPromise, PROMISE_RESOLVED_FALSE, PROMISE_RESOLVED_VOID } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\n\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */\nexport var OPEN_BROADCAST_CHANNELS = new Set();\nvar lastId = 0;\nexport var BroadcastChannel = function BroadcastChannel(name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options);\n\n  // isListening\n  this._iL = false;\n\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n  this._onML = null;\n\n  /**\n   * _addEventListeners\n   */\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n\n  /**\n   * Unsent message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n  this._uMP = new Set();\n\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n  this._befC = [];\n\n  /**\n   * _preparePromise\n   */\n  this._prepP = null;\n  _prepareChannel(this);\n};\n\n// STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\nBroadcastChannel._pubkey = true;\n\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\nexport function clearNodeFolder(options) {\n  options = fillOptionsWithDefaults(options);\n  var method = chooseMethod(options);\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return PROMISE_RESOLVED_FALSE;\n  }\n}\n\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\nvar ENFORCED_OPTIONS;\nexport function enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n}\n\n// PROTOTYPE\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\n       * In the past when this error appeared, it was really hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */\n      JSON.stringify(msg));\n    }\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n    _removeListenerObject(this, 'message', this._onML);\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n    if (this.closed) {\n      return;\n    }\n    OPEN_BROADCAST_CHANNELS[\"delete\"](this);\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare\n    // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    })\n    // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    })\n    // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n  get type() {\n    return this.method.type;\n  },\n  get isClosed() {\n    return this.closed;\n  }\n};\n\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n\n    // add/remove to unsent messages list\n    broadcastChannel._uMP.add(sendPromise);\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n  _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n  _stopListening(channel);\n}\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (listenerObject) {\n        if (msgObj.time >= listenerObject.time) {\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n    var time = channel.method.microSeconds();\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // no one is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}","import { add as unloadAdd } from 'unload';\n\n/**\n * sends and internal message over the broadcast-channel\n */\nexport function sendLeaderMessage(leaderElector, action) {\n  var msgJson = {\n    context: 'leader',\n    action: action,\n    token: leaderElector.token\n  };\n  return leaderElector.broadcastChannel.postInternal(msgJson);\n}\nexport function beLeader(leaderElector) {\n  leaderElector.isLeader = true;\n  leaderElector._hasLeader = true;\n  var unloadFn = unloadAdd(function () {\n    return leaderElector.die();\n  });\n  leaderElector._unl.push(unloadFn);\n  var isLeaderListener = function isLeaderListener(msg) {\n    if (msg.context === 'leader' && msg.action === 'apply') {\n      sendLeaderMessage(leaderElector, 'tell');\n    }\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._dpLC) {\n      /**\n       * another instance is also leader!\n       * This can happen on rare events\n       * like when the CPU is at 100% for long time\n       * or the tabs are open very long and the browser throttles them.\n       * @link https://github.com/pubkey/broadcast-channel/issues/414\n       * @link https://github.com/pubkey/broadcast-channel/issues/385\n       */\n      leaderElector._dpLC = true;\n      leaderElector._dpL(); // message the lib user so the app can handle the problem\n      sendLeaderMessage(leaderElector, 'tell'); // ensure other leader also knows the problem\n    }\n  };\n  leaderElector.broadcastChannel.addEventListener('internal', isLeaderListener);\n  leaderElector._lstns.push(isLeaderListener);\n  return sendLeaderMessage(leaderElector, 'tell');\n}","import { randomToken } from './util.js';\nimport { sendLeaderMessage, beLeader } from './leader-election-util.js';\n\n/**\n * A faster version of the leader elector that uses the WebLock API\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API\n */\nexport var LeaderElectionWebLock = function LeaderElectionWebLock(broadcastChannel, options) {\n  var _this = this;\n  this.broadcastChannel = broadcastChannel;\n  broadcastChannel._befC.push(function () {\n    return _this.die();\n  });\n  this._options = options;\n  this.isLeader = false;\n  this.isDead = false;\n  this.token = randomToken();\n  this._lstns = [];\n  this._unl = [];\n  this._dpL = function () {}; // onduplicate listener\n  this._dpLC = false; // true when onduplicate called\n\n  this._wKMC = {}; // stuff for cleanup\n\n  // lock name\n  this.lN = 'pubkey-bc||' + broadcastChannel.method.type + '||' + broadcastChannel.name;\n};\nLeaderElectionWebLock.prototype = {\n  hasLeader: function hasLeader() {\n    var _this2 = this;\n    return navigator.locks.query().then(function (locks) {\n      var relevantLocks = locks.held ? locks.held.filter(function (lock) {\n        return lock.name === _this2.lN;\n      }) : [];\n      if (relevantLocks && relevantLocks.length > 0) {\n        return true;\n      } else {\n        return false;\n      }\n    });\n  },\n  awaitLeadership: function awaitLeadership() {\n    var _this3 = this;\n    if (!this._wLMP) {\n      this._wKMC.c = new AbortController();\n      var returnPromise = new Promise(function (res, rej) {\n        _this3._wKMC.res = res;\n        _this3._wKMC.rej = rej;\n      });\n      this._wLMP = new Promise(function (res) {\n        navigator.locks.request(_this3.lN, {\n          signal: _this3._wKMC.c.signal\n        }, function () {\n          // if the lock resolved, we can drop the abort controller\n          _this3._wKMC.c = undefined;\n          beLeader(_this3);\n          res();\n          return returnPromise;\n        })[\"catch\"](function () {});\n      });\n    }\n    return this._wLMP;\n  },\n  set onduplicate(_fn) {\n    // Do nothing because there are no duplicates in the WebLock version\n  },\n  die: function die() {\n    var _this4 = this;\n    this._lstns.forEach(function (listener) {\n      return _this4.broadcastChannel.removeEventListener('internal', listener);\n    });\n    this._lstns = [];\n    this._unl.forEach(function (uFn) {\n      return uFn.remove();\n    });\n    this._unl = [];\n    if (this.isLeader) {\n      this.isLeader = false;\n    }\n    this.isDead = true;\n    if (this._wKMC.res) {\n      this._wKMC.res();\n    }\n    if (this._wKMC.c) {\n      this._wKMC.c.abort('LeaderElectionWebLock.die() called');\n    }\n    return sendLeaderMessage(this, 'death');\n  }\n};","import { sleep, randomToken, PROMISE_RESOLVED_VOID, PROMISE_RESOLVED_TRUE, supportsWebLockAPI } from './util.js';\nimport { sendLeaderMessage, beLeader } from './leader-election-util.js';\nimport { LeaderElectionWebLock } from './leader-election-web-lock.js';\nvar LeaderElection = function LeaderElection(broadcastChannel, options) {\n  var _this = this;\n  this.broadcastChannel = broadcastChannel;\n  this._options = options;\n  this.isLeader = false;\n  this._hasLeader = false;\n  this.isDead = false;\n  this.token = randomToken();\n\n  /**\n   * Apply Queue,\n   * used to ensure we do not run applyOnce()\n   * in parallel.\n   */\n  this._aplQ = PROMISE_RESOLVED_VOID;\n  // amount of unfinished applyOnce() calls\n  this._aplQC = 0;\n\n  // things to clean up\n  this._unl = []; // _unloads\n  this._lstns = []; // _listeners\n  this._dpL = function () {}; // onduplicate listener\n  this._dpLC = false; // true when onduplicate called\n\n  /**\n   * Even when the own instance is not applying,\n   * we still listen to messages to ensure the hasLeader flag\n   * is set correctly.\n   */\n  var hasLeaderListener = function hasLeaderListener(msg) {\n    if (msg.context === 'leader') {\n      if (msg.action === 'death') {\n        _this._hasLeader = false;\n      }\n      if (msg.action === 'tell') {\n        _this._hasLeader = true;\n      }\n    }\n  };\n  this.broadcastChannel.addEventListener('internal', hasLeaderListener);\n  this._lstns.push(hasLeaderListener);\n};\nLeaderElection.prototype = {\n  hasLeader: function hasLeader() {\n    return Promise.resolve(this._hasLeader);\n  },\n  /**\n   * Returns true if the instance is leader,\n   * false if not.\n   * @async\n   */\n  applyOnce: function applyOnce(\n  // true if the applyOnce() call came from the fallbackInterval cycle\n  isFromFallbackInterval) {\n    var _this2 = this;\n    if (this.isLeader) {\n      return sleep(0, true);\n    }\n    if (this.isDead) {\n      return sleep(0, false);\n    }\n\n    /**\n     * Already applying more than once,\n     * -> wait for the apply queue to be finished.\n     */\n    if (this._aplQC > 1) {\n      return this._aplQ;\n    }\n\n    /**\n     * Add a new apply-run\n     */\n    var applyRun = function applyRun() {\n      /**\n       * Optimization shortcuts.\n       * Directly return if a previous run\n       * has already elected a leader.\n       */\n      if (_this2.isLeader) {\n        return PROMISE_RESOLVED_TRUE;\n      }\n      var stopCriteria = false;\n      var stopCriteriaPromiseResolve;\n      /**\n       * Resolves when a stop criteria is reached.\n       * Uses as a performance shortcut so we do not\n       * have to await the responseTime when it is already clear\n       * that the election failed.\n       */\n      var stopCriteriaPromise = new Promise(function (res) {\n        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {\n          stopCriteria = true;\n          res();\n        };\n      });\n      var handleMessage = function handleMessage(msg) {\n        if (msg.context === 'leader' && msg.token != _this2.token) {\n          if (msg.action === 'apply') {\n            // other is applying\n            if (msg.token > _this2.token) {\n              /**\n               * other has higher token\n               * -> stop applying and let other become leader.\n               */\n              stopCriteriaPromiseResolve();\n            }\n          }\n          if (msg.action === 'tell') {\n            // other is already leader\n            stopCriteriaPromiseResolve();\n            _this2._hasLeader = true;\n          }\n        }\n      };\n      _this2.broadcastChannel.addEventListener('internal', handleMessage);\n\n      /**\n       * If the applyOnce() call came from the fallbackInterval,\n       * we can assume that the election runs in the background and\n       * not critical process is waiting for it.\n       * When this is true, we give the other instances\n       * more time to answer to messages in the election cycle.\n       * This makes it less likely to elect duplicate leaders.\n       * But also it takes longer which is not a problem because we anyway\n       * run in the background.\n       */\n      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;\n      return sendLeaderMessage(_this2, 'apply') // send out that this one is applying\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })\n      // send again in case another instance was just created\n      .then(function () {\n        return sendLeaderMessage(_this2, 'apply');\n      })\n      // let others time to respond\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })[\"catch\"](function () {}).then(function () {\n        _this2.broadcastChannel.removeEventListener('internal', handleMessage);\n        if (!stopCriteria) {\n          // no stop criteria -> own is leader\n          return beLeader(_this2).then(function () {\n            return true;\n          });\n        } else {\n          // other is leader\n          return false;\n        }\n      });\n    };\n    this._aplQC = this._aplQC + 1;\n    this._aplQ = this._aplQ.then(function () {\n      return applyRun();\n    }).then(function () {\n      _this2._aplQC = _this2._aplQC - 1;\n    });\n    return this._aplQ.then(function () {\n      return _this2.isLeader;\n    });\n  },\n  awaitLeadership: function awaitLeadership() {\n    if (/* _awaitLeadershipPromise */\n    !this._aLP) {\n      this._aLP = _awaitLeadershipOnce(this);\n    }\n    return this._aLP;\n  },\n  set onduplicate(fn) {\n    this._dpL = fn;\n  },\n  die: function die() {\n    var _this3 = this;\n    this._lstns.forEach(function (listener) {\n      return _this3.broadcastChannel.removeEventListener('internal', listener);\n    });\n    this._lstns = [];\n    this._unl.forEach(function (uFn) {\n      return uFn.remove();\n    });\n    this._unl = [];\n    if (this.isLeader) {\n      this._hasLeader = false;\n      this.isLeader = false;\n    }\n    this.isDead = true;\n    return sendLeaderMessage(this, 'death');\n  }\n};\n\n/**\n * @param leaderElector {LeaderElector}\n */\nfunction _awaitLeadershipOnce(leaderElector) {\n  if (leaderElector.isLeader) {\n    return PROMISE_RESOLVED_VOID;\n  }\n  return new Promise(function (res) {\n    var resolved = false;\n    function finish() {\n      if (resolved) {\n        return;\n      }\n      resolved = true;\n      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);\n      res(true);\n    }\n\n    // try once now\n    leaderElector.applyOnce().then(function () {\n      if (leaderElector.isLeader) {\n        finish();\n      }\n    });\n\n    /**\n     * Try on fallbackInterval\n     * @recursive\n     */\n    var _tryOnFallBack = function tryOnFallBack() {\n      return sleep(leaderElector._options.fallbackInterval).then(function () {\n        if (leaderElector.isDead || resolved) {\n          return;\n        }\n        if (leaderElector.isLeader) {\n          finish();\n        } else {\n          return leaderElector.applyOnce(true).then(function () {\n            if (leaderElector.isLeader) {\n              finish();\n            } else {\n              _tryOnFallBack();\n            }\n          });\n        }\n      });\n    };\n    _tryOnFallBack();\n\n    // try when other leader dies\n    var whenDeathListener = function whenDeathListener(msg) {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector._hasLeader = false;\n        leaderElector.applyOnce().then(function () {\n          if (leaderElector.isLeader) {\n            finish();\n          }\n        });\n      }\n    };\n    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);\n    leaderElector._lstns.push(whenDeathListener);\n  });\n}\nfunction fillOptionsWithDefaults(options, channel) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options));\n  if (!options.fallbackInterval) {\n    options.fallbackInterval = 3000;\n  }\n  if (!options.responseTime) {\n    options.responseTime = channel.method.averageResponseTime(channel.options);\n  }\n  return options;\n}\nexport function createLeaderElection(channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('BroadcastChannel already has a leader-elector');\n  }\n  options = fillOptionsWithDefaults(options, channel);\n  var elector = supportsWebLockAPI() ? new LeaderElectionWebLock(channel, options) : new LeaderElection(channel, options);\n  channel._befC.push(function () {\n    return elector.die();\n  });\n  channel._leaderElector = elector;\n  return elector;\n}","import { NativeMethod } from './methods/native.js';\nimport { IndexedDBMethod } from './methods/indexed-db.js';\nimport { LocalstorageMethod } from './methods/localstorage.js';\nimport { SimulateMethod } from './methods/simulate.js';\n// the line below will be removed from es5/browser builds\n\n// order is important\nvar METHODS = [NativeMethod,\n// fastest\nIndexedDBMethod, LocalstorageMethod];\nexport function chooseMethod(options) {\n  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);\n\n  // the line below will be removed from es5/browser builds\n\n  // directly chosen\n  if (options.type) {\n    if (options.type === 'simulate') {\n      // only use simulate-method if directly chosen\n      return SimulateMethod;\n    }\n    var ret = chooseMethods.find(function (m) {\n      return m.type === options.type;\n    });\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n\n  /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage will be chosen\n   */\n  if (!options.webWorkerSupport) {\n    chooseMethods = chooseMethods.filter(function (m) {\n      return m.type !== 'idb';\n    });\n  }\n  var useMethod = chooseMethods.find(function (method) {\n    return method.canBeUsed();\n  });\n  if (!useMethod) {\n    throw new Error(\"No usable method found in \" + JSON.stringify(METHODS.map(function (m) {\n      return m.type;\n    })));\n  } else {\n    return useMethod;\n  }\n}","/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n * \n * When working on this, ensure to use these performance optimizations:\n * @link https://rxdb.info/slow-indexeddb.html\n */\n\nimport { sleep, randomInt, randomToken, microSeconds as micro, PROMISE_RESOLVED_VOID } from '../util.js';\nexport var microSeconds = micro;\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options.js';\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\n\n/**\n * Use relaxed durability for faster performance on all transactions.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\nexport var TRANSACTION_SETTINGS = {\n  durability: 'relaxed'\n};\nexport var type = 'idb';\nexport function getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n  if (typeof window !== 'undefined') {\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  }\n  return false;\n}\n\n/**\n * If possible, we should explicitly commit IndexedDB transactions\n * for better performance.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\nexport function commitIndexedDBTransaction(tx) {\n  if (tx.commit) {\n    tx.commit();\n  }\n}\nexport function createDatabase(channelName) {\n  var IndexedDB = getIdb();\n\n  // create table\n  var dbName = DB_PREFIX + channelName;\n\n  /**\n   * All IndexedDB databases are opened without version\n   * because it is a bit faster, especially on firefox\n   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version\n   */\n  var openRequest = IndexedDB.open(dbName);\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n  return new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n}\n\n/**\n * writes the new message to the database\n * so other readers can find it\n */\nexport function writeMessage(db, readerUuid, messageJson) {\n  var time = Date.now();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  return new Promise(function (res, rej) {\n    tx.oncomplete = function () {\n      return res();\n    };\n    tx.onerror = function (ev) {\n      return rej(ev);\n    };\n    var objectStore = tx.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n    commitIndexedDBTransaction(tx);\n  });\n}\nexport function getAllMessages(db) {\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n      if (cursor) {\n        ret.push(cursor.value);\n        //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n        cursor[\"continue\"]();\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nexport function getMessagesHigherThan(db, lastCursorId) {\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n\n  /**\n   * Optimization shortcut,\n   * if getAll() can be used, do not use a cursor.\n   * @link https://rxdb.info/slow-indexeddb.html\n   */\n  if (objectStore.getAll) {\n    var getAllRequest = objectStore.getAll(keyRangeValue);\n    return new Promise(function (res, rej) {\n      getAllRequest.onerror = function (err) {\n        return rej(err);\n      };\n      getAllRequest.onsuccess = function (e) {\n        res(e.target.result);\n      };\n    });\n  }\n  function openCursor() {\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\n    // catches that error, having it open the cursor to the first\n    // item. When it gets data it will advance to the desired key.\n    try {\n      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n      return objectStore.openCursor(keyRangeValue);\n    } catch (e) {\n      return objectStore.openCursor();\n    }\n  }\n  return new Promise(function (res, rej) {\n    var openCursorRequest = openCursor();\n    openCursorRequest.onerror = function (err) {\n      return rej(err);\n    };\n    openCursorRequest.onsuccess = function (ev) {\n      var cursor = ev.target.result;\n      if (cursor) {\n        if (cursor.value.id < lastCursorId + 1) {\n          cursor[\"continue\"](lastCursorId + 1);\n        } else {\n          ret.push(cursor.value);\n          cursor[\"continue\"]();\n        }\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nexport function removeMessagesById(channelState, ids) {\n  if (channelState.closed) {\n    return Promise.resolve([]);\n  }\n  var tx = channelState.db.transaction(OBJECT_STORE_ID, 'readwrite', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  return Promise.all(ids.map(function (id) {\n    var deleteRequest = objectStore[\"delete\"](id);\n    return new Promise(function (res) {\n      deleteRequest.onsuccess = function () {\n        return res();\n      };\n    });\n  }));\n}\nexport function getOldMessages(db, ttl) {\n  var olderThen = Date.now() - ttl;\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n      if (cursor) {\n        var msgObk = cursor.value;\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk);\n          //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          commitIndexedDBTransaction(tx);\n          res(ret);\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function cleanOldMessages(channelState) {\n  return getOldMessages(channelState.db, channelState.options.idb.ttl).then(function (tooOld) {\n    return removeMessagesById(channelState, tooOld.map(function (msg) {\n      return msg.id;\n    }));\n  });\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: randomToken(),\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parallel\n      writeBlockPromise: PROMISE_RESOLVED_VOID,\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n\n    /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */\n    db.onclose = function () {\n      state.closed = true;\n      if (options.idb.onclose) options.idb.onclose();\n    };\n\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n    _readLoop(state);\n    return state;\n  });\n}\nfunction _readLoop(state) {\n  if (state.closed) return;\n  readNewMessages(state).then(function () {\n    return sleep(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n  return true;\n}\n\n/**\n * reads all new messages from the database and emits them\n */\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return PROMISE_RESOLVED_VOID;\n\n  // if no one is listening, we do not need to scan for new messages\n  if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined sometimes\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */.filter(function (msgObj) {\n      return !!msgObj;\n    }).map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return PROMISE_RESOLVED_VOID;\n  });\n}\nexport function close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nexport function postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if (randomInt(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nexport function canBeUsed() {\n  return !!getIdb();\n}\nexport function averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\nexport var IndexedDBMethod = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside webworkers because they have no access to localstorage\n * This is basically implemented to support IE9 or your grandmother's toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options.js';\nimport { sleep, randomToken, microSeconds as micro } from '../util.js';\nexport var microSeconds = micro;\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\nexport var type = 'localstorage';\n\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\nexport function getLocalStorage() {\n  var localStorage;\n  if (typeof window === 'undefined') return null;\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n  return localStorage;\n}\nexport function storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    sleep().then(function () {\n      var key = storageKey(channelState.channelName);\n      var writeObj = {\n        token: randomToken(),\n        time: Date.now(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      var value = JSON.stringify(writeObj);\n      getLocalStorage().setItem(key, value);\n\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n      var ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nexport function addStorageEventListener(channelName, fn) {\n  var key = storageKey(channelName);\n  var listener = function listener(ev) {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n  window.addEventListener('storage', listener);\n  return listener;\n}\nexport function removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  if (!canBeUsed()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n  var uuid = randomToken();\n\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n  var eMIs = new ObliviousSet(options.localstorage.removeTimeout);\n  var state = {\n    channelName: channelName,\n    uuid: uuid,\n    eMIs: eMIs // emittedMessagesIds\n  };\n  state.listener = addStorageEventListener(channelName, function (msgObj) {\n    if (!state.messagesCallback) return; // no listener\n    if (msgObj.uuid === uuid) return; // own message\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nexport function close(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  var ls = getLocalStorage();\n  if (!ls) return false;\n  try {\n    var key = '__broadcastchannel_check';\n    ls.setItem(key, 'works');\n    ls.removeItem(key);\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n    return false;\n  }\n  return true;\n}\nexport function averageResponseTime() {\n  var defaultTime = 120;\n  var userAgent = navigator.userAgent.toLowerCase();\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2;\n  }\n  return defaultTime;\n}\nexport var LocalstorageMethod = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","import { microSeconds as micro, PROMISE_RESOLVED_VOID } from '../util.js';\nexport var microSeconds = micro;\nexport var type = 'native';\nexport function create(channelName) {\n  var state = {\n    time: micro(),\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n  };\n  state.bc.onmessage = function (msgEvent) {\n    if (state.messagesCallback) {\n      state.messagesCallback(msgEvent.data);\n    }\n  };\n  return state;\n}\nexport function close(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nexport function postMessage(channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false);\n    return PROMISE_RESOLVED_VOID;\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nexport function onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  // Deno runtime\n  // eslint-disable-next-line\n  if (typeof globalThis !== 'undefined' && globalThis.Deno && globalThis.Deno.args) {\n    return true;\n  }\n\n  // Browser runtime\n  if ((typeof window !== 'undefined' || typeof self !== 'undefined') && typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function averageResponseTime() {\n  return 150;\n}\nexport var NativeMethod = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","import { microSeconds as micro } from '../util.js';\nexport var microSeconds = micro;\nexport var type = 'simulate';\nvar SIMULATE_CHANNELS = new Set();\nexport function create(channelName) {\n  var state = {\n    time: microSeconds(),\n    name: channelName,\n    messagesCallback: null\n  };\n  SIMULATE_CHANNELS.add(state);\n  return state;\n}\nexport function close(channelState) {\n  SIMULATE_CHANNELS[\"delete\"](channelState);\n}\nexport var SIMULATE_DELAY_TIME = 5;\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      var channelArray = Array.from(SIMULATE_CHANNELS);\n      channelArray.forEach(function (channel) {\n        if (channel.name === channelState.name &&\n        // has same name\n        channel !== channelState &&\n        // not own channel\n        !!channel.messagesCallback &&\n        // has subscribers\n        channel.time < messageJson.time // channel not created after postMessage() call\n        ) {\n          channel.messagesCallback(messageJson);\n        }\n      });\n      res();\n    }, SIMULATE_DELAY_TIME);\n  });\n}\nexport function onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  return true;\n}\nexport function averageResponseTime() {\n  return SIMULATE_DELAY_TIME;\n}\nexport var SimulateMethod = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","export function fillOptionsWithDefaults() {\n  var originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var options = JSON.parse(JSON.stringify(originalOptions));\n\n  // main\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true;\n\n  // indexed-db\n  if (!options.idb) options.idb = {};\n  //  after this time the messages get deleted\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;\n  //  handles abrupt db onclose events.\n  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose;\n\n  // localstorage\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60;\n\n  // custom methods\n  if (originalOptions.methods) options.methods = originalOptions.methods;\n\n  // node\n  if (!options.node) options.node = {};\n  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;\n  /**\n   * On linux use 'ulimit -Hn' to get the limit of open files.\n   * On ubuntu this was 4096 for me, so we use half of that as maxParallelWrites default.\n   */\n  if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;\n  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;\n  return options;\n}","/**\n * returns true if the given object is a promise\n */\nexport function isPromise(obj) {\n  return obj && typeof obj.then === 'function';\n}\nexport var PROMISE_RESOLVED_FALSE = Promise.resolve(false);\nexport var PROMISE_RESOLVED_TRUE = Promise.resolve(true);\nexport var PROMISE_RESOLVED_VOID = Promise.resolve();\nexport function sleep(time, resolveWith) {\n  if (!time) time = 0;\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      return res(resolveWith);\n    }, time);\n  });\n}\nexport function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * https://stackoverflow.com/a/8084248\n */\nexport function randomToken() {\n  return Math.random().toString(36).substring(2);\n}\nvar lastMs = 0;\n\n/**\n * Returns the current unix time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\nexport function microSeconds() {\n  var ret = Date.now() * 1000; // milliseconds to microseconds\n  if (ret <= lastMs) {\n    ret = lastMs + 1;\n  }\n  lastMs = ret;\n  return ret;\n}\n\n/**\n * Check if WebLock API is supported.\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API\n */\nexport function supportsWebLockAPI() {\n  if (typeof navigator !== 'undefined' && typeof navigator.locks !== 'undefined' && typeof navigator.locks.request === 'function') {\n    return true;\n  } else {\n    return false;\n  }\n}","/**\n * Creates a new Idle-Queue\n * @constructor\n * @param {number} [parallels=1] amount of parrallel runs of the limited-ressource\n */\nexport var IdleQueue = function IdleQueue() {\n  var parallels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  this._parallels = parallels || 1;\n  /**\n   * _queueCounter\n   * each lock() increased this number\n   * each unlock() decreases this number\n   * If _qC==0, the state is in idle\n   * @type {Number}\n   */\n\n  this._qC = 0;\n  /**\n   * _idleCalls\n   * contains all promises that where added via requestIdlePromise()\n   * and not have been resolved\n   * @type {Set<Promise>} _iC with oldest promise first\n   */\n\n  this._iC = new Set();\n  /**\n   * _lastHandleNumber\n   * @type {Number}\n   */\n\n  this._lHN = 0;\n  /**\n   * _handlePromiseMap\n   * Contains the handleNumber on the left\n   * And the assigned promise on the right.\n   * This is stored so you can use cancelIdleCallback(handleNumber)\n   * to stop executing the callback.\n   * @type {Map<Number><Promise>}\n   */\n\n  this._hPM = new Map();\n  this._pHM = new Map(); // _promiseHandleMap\n};\nIdleQueue.prototype = {\n  isIdle: function isIdle() {\n    return this._qC < this._parallels;\n  },\n\n  /**\n   * creates a lock in the queue\n   * and returns an unlock-function to remove the lock from the queue\n   * @return {function} unlock function than must be called afterwards\n   */\n  lock: function lock() {\n    this._qC++;\n  },\n  unlock: function unlock() {\n    this._qC--;\n\n    _tryIdleCall(this);\n  },\n\n  /**\n   * wraps a function with lock/unlock and runs it\n   * @param  {function}  fun\n   * @return {Promise<any>}\n   */\n  wrapCall: function wrapCall(fun) {\n    var _this = this;\n\n    this.lock();\n    var maybePromise;\n\n    try {\n      maybePromise = fun();\n    } catch (err) {\n      this.unlock();\n      throw err;\n    }\n\n    if (!maybePromise.then || typeof maybePromise.then !== 'function') {\n      // no promise\n      this.unlock();\n      return maybePromise;\n    } else {\n      // promise\n      return maybePromise.then(function (ret) {\n        // sucessfull -> unlock before return\n        _this.unlock();\n\n        return ret;\n      })[\"catch\"](function (err) {\n        // not sucessfull -> unlock before throwing\n        _this.unlock();\n\n        throw err;\n      });\n    }\n  },\n\n  /**\n   * does the same as requestIdleCallback() but uses promises instead of the callback\n   * @param {{timeout?: number}} options like timeout\n   * @return {Promise<void>} promise that resolves when the database is in idle-mode\n   */\n  requestIdlePromise: function requestIdlePromise(options) {\n    var _this2 = this;\n\n    options = options || {};\n    var resolve;\n    var prom = new Promise(function (res) {\n      return resolve = res;\n    });\n\n    var resolveFromOutside = function resolveFromOutside() {\n      _removeIdlePromise(_this2, prom);\n\n      resolve();\n    };\n\n    prom._manRes = resolveFromOutside;\n\n    if (options.timeout) {\n      // if timeout has passed, resolve promise even if not idle\n      var timeoutObj = setTimeout(function () {\n        prom._manRes();\n      }, options.timeout);\n      prom._timeoutObj = timeoutObj;\n    }\n\n    this._iC.add(prom);\n\n    _tryIdleCall(this);\n\n    return prom;\n  },\n\n  /**\n   * remove the promise so it will never be resolved\n   * @param  {Promise} promise from requestIdlePromise()\n   * @return {void}\n   */\n  cancelIdlePromise: function cancelIdlePromise(promise) {\n    _removeIdlePromise(this, promise);\n  },\n\n  /**\n   * api equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n   * @param  {Function} callback\n   * @param  {options}   options  [description]\n   * @return {number} handle which can be used with cancelIdleCallback()\n   */\n  requestIdleCallback: function requestIdleCallback(callback, options) {\n    var handle = this._lHN++;\n    var promise = this.requestIdlePromise(options);\n\n    this._hPM.set(handle, promise);\n\n    this._pHM.set(promise, handle);\n\n    promise.then(function () {\n      return callback();\n    });\n    return handle;\n  },\n\n  /**\n   * API equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback\n   * @param  {number} handle returned from requestIdleCallback()\n   * @return {void}\n   */\n  cancelIdleCallback: function cancelIdleCallback(handle) {\n    var promise = this._hPM.get(handle);\n\n    this.cancelIdlePromise(promise);\n  },\n\n  /**\n   * clears and resets everything\n   * @return {void}\n   */\n  clear: function clear() {\n    var _this3 = this;\n\n    // remove all non-cleared\n    this._iC.forEach(function (promise) {\n      return _removeIdlePromise(_this3, promise);\n    });\n\n    this._qC = 0;\n\n    this._iC.clear();\n\n    this._hPM = new Map();\n    this._pHM = new Map();\n  }\n};\n/**\n * processes the oldest call of the idleCalls-queue\n * @return {Promise<void>}\n */\n\nfunction _resolveOneIdleCall(idleQueue) {\n  if (idleQueue._iC.size === 0) return;\n\n  var iterator = idleQueue._iC.values();\n\n  var oldestPromise = iterator.next().value;\n\n  oldestPromise._manRes(); // try to call the next tick\n\n\n  setTimeout(function () {\n    return _tryIdleCall(idleQueue);\n  }, 0);\n}\n/**\n * removes the promise from the queue and maps and also its corresponding handle-number\n * @param  {Promise} promise from requestIdlePromise()\n * @return {void}\n */\n\n\nfunction _removeIdlePromise(idleQueue, promise) {\n  if (!promise) return; // remove timeout if exists\n\n  if (promise._timeoutObj) clearTimeout(promise._timeoutObj); // remove handle-nr if exists\n\n  if (idleQueue._pHM.has(promise)) {\n    var handle = idleQueue._pHM.get(promise);\n\n    idleQueue._hPM[\"delete\"](handle);\n\n    idleQueue._pHM[\"delete\"](promise);\n  } // remove from queue\n\n\n  idleQueue._iC[\"delete\"](promise);\n}\n/**\n * resolves the last entry of this._iC\n * but only if the queue is empty\n * @return {Promise}\n */\n\n\nfunction _tryIdleCall(idleQueue) {\n  // ensure this does not run in parallel\n  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;\n  idleQueue._tryIR = true; // w8 one tick\n\n  setTimeout(function () {\n    // check if queue empty\n    if (!idleQueue.isIdle()) {\n      idleQueue._tryIR = false;\n      return;\n    }\n    /**\n     * wait 1 tick here\n     * because many functions do IO->CPU->IO\n     * which means the queue is empty for a short time\n     * but the ressource is not idle\n     */\n\n\n    setTimeout(function () {\n      // check if queue still empty\n      if (!idleQueue.isIdle()) {\n        idleQueue._tryIR = false;\n        return;\n      } // ressource is idle\n\n\n      _resolveOneIdleCall(idleQueue);\n\n      idleQueue._tryIR = false;\n    }, 0);\n  }, 0);\n}","/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 4.0.10, Fri Nov 15 2024\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Dexie = factory());\n})(this, (function () { 'use strict';\n\n    /*! *****************************************************************************\n    Copyright (c) Microsoft Corporation.\n    Permission to use, copy, modify, and/or distribute this software for any\n    purpose with or without fee is hereby granted.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n    PERFORMANCE OF THIS SOFTWARE.\n    ***************************************************************************** */\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    function __extends(d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }\n    var __assign = function() {\n        __assign = Object.assign || function __assign(t) {\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\n                s = arguments[i];\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n            return t;\n        };\n        return __assign.apply(this, arguments);\n    };\n    function __spreadArray(to, from, pack) {\n        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n            if (ar || !(i in from)) {\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                ar[i] = from[i];\n            }\n        }\n        return to.concat(ar || Array.prototype.slice.call(from));\n    }\n\n    var _global = typeof globalThis !== 'undefined' ? globalThis :\n        typeof self !== 'undefined' ? self :\n            typeof window !== 'undefined' ? window :\n                global;\n\n    var keys = Object.keys;\n    var isArray = Array.isArray;\n    if (typeof Promise !== 'undefined' && !_global.Promise) {\n        _global.Promise = Promise;\n    }\n    function extend(obj, extension) {\n        if (typeof extension !== 'object')\n            return obj;\n        keys(extension).forEach(function (key) {\n            obj[key] = extension[key];\n        });\n        return obj;\n    }\n    var getProto = Object.getPrototypeOf;\n    var _hasOwn = {}.hasOwnProperty;\n    function hasOwn(obj, prop) {\n        return _hasOwn.call(obj, prop);\n    }\n    function props(proto, extension) {\n        if (typeof extension === 'function')\n            extension = extension(getProto(proto));\n        (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {\n            setProp(proto, key, extension[key]);\n        });\n    }\n    var defineProperty = Object.defineProperty;\n    function setProp(obj, prop, functionOrGetSet, options) {\n        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n            { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n            { value: functionOrGetSet, configurable: true, writable: true }, options));\n    }\n    function derive(Child) {\n        return {\n            from: function (Parent) {\n                Child.prototype = Object.create(Parent.prototype);\n                setProp(Child.prototype, \"constructor\", Child);\n                return {\n                    extend: props.bind(null, Child.prototype)\n                };\n            }\n        };\n    }\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    function getPropertyDescriptor(obj, prop) {\n        var pd = getOwnPropertyDescriptor(obj, prop);\n        var proto;\n        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n    }\n    var _slice = [].slice;\n    function slice(args, start, end) {\n        return _slice.call(args, start, end);\n    }\n    function override(origFunc, overridedFactory) {\n        return overridedFactory(origFunc);\n    }\n    function assert(b) {\n        if (!b)\n            throw new Error(\"Assertion Failed\");\n    }\n    function asap$1(fn) {\n        if (_global.setImmediate)\n            setImmediate(fn);\n        else\n            setTimeout(fn, 0);\n    }\n    function arrayToObject(array, extractor) {\n        return array.reduce(function (result, item, i) {\n            var nameAndValue = extractor(item, i);\n            if (nameAndValue)\n                result[nameAndValue[0]] = nameAndValue[1];\n            return result;\n        }, {});\n    }\n    function getByKeyPath(obj, keyPath) {\n        if (typeof keyPath === 'string' && hasOwn(obj, keyPath))\n            return obj[keyPath];\n        if (!keyPath)\n            return obj;\n        if (typeof keyPath !== 'string') {\n            var rv = [];\n            for (var i = 0, l = keyPath.length; i < l; ++i) {\n                var val = getByKeyPath(obj, keyPath[i]);\n                rv.push(val);\n            }\n            return rv;\n        }\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var innerObj = obj[keyPath.substr(0, period)];\n            return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n        }\n        return undefined;\n    }\n    function setByKeyPath(obj, keyPath, value) {\n        if (!obj || keyPath === undefined)\n            return;\n        if ('isFrozen' in Object && Object.isFrozen(obj))\n            return;\n        if (typeof keyPath !== 'string' && 'length' in keyPath) {\n            assert(typeof value !== 'string' && 'length' in value);\n            for (var i = 0, l = keyPath.length; i < l; ++i) {\n                setByKeyPath(obj, keyPath[i], value[i]);\n            }\n        }\n        else {\n            var period = keyPath.indexOf('.');\n            if (period !== -1) {\n                var currentKeyPath = keyPath.substr(0, period);\n                var remainingKeyPath = keyPath.substr(period + 1);\n                if (remainingKeyPath === \"\")\n                    if (value === undefined) {\n                        if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                            obj.splice(currentKeyPath, 1);\n                        else\n                            delete obj[currentKeyPath];\n                    }\n                    else\n                        obj[currentKeyPath] = value;\n                else {\n                    var innerObj = obj[currentKeyPath];\n                    if (!innerObj || !hasOwn(obj, currentKeyPath))\n                        innerObj = (obj[currentKeyPath] = {});\n                    setByKeyPath(innerObj, remainingKeyPath, value);\n                }\n            }\n            else {\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                        obj.splice(keyPath, 1);\n                    else\n                        delete obj[keyPath];\n                }\n                else\n                    obj[keyPath] = value;\n            }\n        }\n    }\n    function delByKeyPath(obj, keyPath) {\n        if (typeof keyPath === 'string')\n            setByKeyPath(obj, keyPath, undefined);\n        else if ('length' in keyPath)\n            [].map.call(keyPath, function (kp) {\n                setByKeyPath(obj, kp, undefined);\n            });\n    }\n    function shallowClone(obj) {\n        var rv = {};\n        for (var m in obj) {\n            if (hasOwn(obj, m))\n                rv[m] = obj[m];\n        }\n        return rv;\n    }\n    var concat = [].concat;\n    function flatten(a) {\n        return concat.apply([], a);\n    }\n    var intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n        .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return [\"Int\", \"Uint\", \"Float\"].map(function (t) { return t + num + \"Array\"; }); }))).filter(function (t) { return _global[t]; });\n    var intrinsicTypes = new Set(intrinsicTypeNames.map(function (t) { return _global[t]; }));\n    function cloneSimpleObjectTree(o) {\n        var rv = {};\n        for (var k in o)\n            if (hasOwn(o, k)) {\n                var v = o[k];\n                rv[k] = !v || typeof v !== 'object' || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);\n            }\n        return rv;\n    }\n    function objectIsEmpty(o) {\n        for (var k in o)\n            if (hasOwn(o, k))\n                return false;\n        return true;\n    }\n    var circularRefs = null;\n    function deepClone(any) {\n        circularRefs = new WeakMap();\n        var rv = innerDeepClone(any);\n        circularRefs = null;\n        return rv;\n    }\n    function innerDeepClone(x) {\n        if (!x || typeof x !== 'object')\n            return x;\n        var rv = circularRefs.get(x);\n        if (rv)\n            return rv;\n        if (isArray(x)) {\n            rv = [];\n            circularRefs.set(x, rv);\n            for (var i = 0, l = x.length; i < l; ++i) {\n                rv.push(innerDeepClone(x[i]));\n            }\n        }\n        else if (intrinsicTypes.has(x.constructor)) {\n            rv = x;\n        }\n        else {\n            var proto = getProto(x);\n            rv = proto === Object.prototype ? {} : Object.create(proto);\n            circularRefs.set(x, rv);\n            for (var prop in x) {\n                if (hasOwn(x, prop)) {\n                    rv[prop] = innerDeepClone(x[prop]);\n                }\n            }\n        }\n        return rv;\n    }\n    var toString = {}.toString;\n    function toStringTag(o) {\n        return toString.call(o).slice(8, -1);\n    }\n    var iteratorSymbol = typeof Symbol !== 'undefined' ?\n        Symbol.iterator :\n        '@@iterator';\n    var getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n        var i;\n        return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n    } : function () { return null; };\n    function delArrayItem(a, x) {\n        var i = a.indexOf(x);\n        if (i >= 0)\n            a.splice(i, 1);\n        return i >= 0;\n    }\n    var NO_CHAR_ARRAY = {};\n    function getArrayOf(arrayLike) {\n        var i, a, x, it;\n        if (arguments.length === 1) {\n            if (isArray(arrayLike))\n                return arrayLike.slice();\n            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n                return [arrayLike];\n            if ((it = getIteratorOf(arrayLike))) {\n                a = [];\n                while ((x = it.next()), !x.done)\n                    a.push(x.value);\n                return a;\n            }\n            if (arrayLike == null)\n                return [arrayLike];\n            i = arrayLike.length;\n            if (typeof i === 'number') {\n                a = new Array(i);\n                while (i--)\n                    a[i] = arrayLike[i];\n                return a;\n            }\n            return [arrayLike];\n        }\n        i = arguments.length;\n        a = new Array(i);\n        while (i--)\n            a[i] = arguments[i];\n        return a;\n    }\n    var isAsyncFunction = typeof Symbol !== 'undefined'\n        ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }\n        : function () { return false; };\n\n    var dexieErrorNames = [\n        'Modify',\n        'Bulk',\n        'OpenFailed',\n        'VersionChange',\n        'Schema',\n        'Upgrade',\n        'InvalidTable',\n        'MissingAPI',\n        'NoSuchDatabase',\n        'InvalidArgument',\n        'SubTransaction',\n        'Unsupported',\n        'Internal',\n        'DatabaseClosed',\n        'PrematureCommit',\n        'ForeignAwait'\n    ];\n    var idbDomErrorNames = [\n        'Unknown',\n        'Constraint',\n        'Data',\n        'TransactionInactive',\n        'ReadOnly',\n        'Version',\n        'NotFound',\n        'InvalidState',\n        'InvalidAccess',\n        'Abort',\n        'Timeout',\n        'QuotaExceeded',\n        'Syntax',\n        'DataClone'\n    ];\n    var errorList = dexieErrorNames.concat(idbDomErrorNames);\n    var defaultTexts = {\n        VersionChanged: \"Database version changed by other database connection\",\n        DatabaseClosed: \"Database has been closed\",\n        Abort: \"Transaction aborted\",\n        TransactionInactive: \"Transaction has already completed or failed\",\n        MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n    };\n    function DexieError(name, msg) {\n        this.name = name;\n        this.message = msg;\n    }\n    derive(DexieError).from(Error).extend({\n        toString: function () { return this.name + \": \" + this.message; }\n    });\n    function getMultiErrorMessage(msg, failures) {\n        return msg + \". Errors: \" + Object.keys(failures)\n            .map(function (key) { return failures[key].toString(); })\n            .filter(function (v, i, s) { return s.indexOf(v) === i; })\n            .join('\\n');\n    }\n    function ModifyError(msg, failures, successCount, failedKeys) {\n        this.failures = failures;\n        this.failedKeys = failedKeys;\n        this.successCount = successCount;\n        this.message = getMultiErrorMessage(msg, failures);\n    }\n    derive(ModifyError).from(DexieError);\n    function BulkError(msg, failures) {\n        this.name = \"BulkError\";\n        this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });\n        this.failuresByPos = failures;\n        this.message = getMultiErrorMessage(msg, this.failures);\n    }\n    derive(BulkError).from(DexieError);\n    var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + \"Error\", obj); }, {});\n    var BaseException = DexieError;\n    var exceptions = errorList.reduce(function (obj, name) {\n        var fullName = name + \"Error\";\n        function DexieError(msgOrInner, inner) {\n            this.name = fullName;\n            if (!msgOrInner) {\n                this.message = defaultTexts[name] || fullName;\n                this.inner = null;\n            }\n            else if (typeof msgOrInner === 'string') {\n                this.message = \"\".concat(msgOrInner).concat(!inner ? '' : '\\n ' + inner);\n                this.inner = inner || null;\n            }\n            else if (typeof msgOrInner === 'object') {\n                this.message = \"\".concat(msgOrInner.name, \" \").concat(msgOrInner.message);\n                this.inner = msgOrInner;\n            }\n        }\n        derive(DexieError).from(BaseException);\n        obj[name] = DexieError;\n        return obj;\n    }, {});\n    exceptions.Syntax = SyntaxError;\n    exceptions.Type = TypeError;\n    exceptions.Range = RangeError;\n    var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n        obj[name + \"Error\"] = exceptions[name];\n        return obj;\n    }, {});\n    function mapError(domError, message) {\n        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n            return domError;\n        var rv = new exceptionMap[domError.name](message || domError.message, domError);\n        if (\"stack\" in domError) {\n            setProp(rv, \"stack\", { get: function () {\n                    return this.inner.stack;\n                } });\n        }\n        return rv;\n    }\n    var fullNameExceptions = errorList.reduce(function (obj, name) {\n        if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n            obj[name + \"Error\"] = exceptions[name];\n        return obj;\n    }, {});\n    fullNameExceptions.ModifyError = ModifyError;\n    fullNameExceptions.DexieError = DexieError;\n    fullNameExceptions.BulkError = BulkError;\n\n    function nop() { }\n    function mirror(val) { return val; }\n    function pureFunctionChain(f1, f2) {\n        if (f1 == null || f1 === mirror)\n            return f2;\n        return function (val) {\n            return f2(f1(val));\n        };\n    }\n    function callBoth(on1, on2) {\n        return function () {\n            on1.apply(this, arguments);\n            on2.apply(this, arguments);\n        };\n    }\n    function hookCreatingChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function () {\n            var res = f1.apply(this, arguments);\n            if (res !== undefined)\n                arguments[0] = res;\n            var onsuccess = this.onsuccess,\n            onerror = this.onerror;\n            this.onsuccess = null;\n            this.onerror = null;\n            var res2 = f2.apply(this, arguments);\n            if (onsuccess)\n                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n            if (onerror)\n                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n            return res2 !== undefined ? res2 : res;\n        };\n    }\n    function hookDeletingChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function () {\n            f1.apply(this, arguments);\n            var onsuccess = this.onsuccess,\n            onerror = this.onerror;\n            this.onsuccess = this.onerror = null;\n            f2.apply(this, arguments);\n            if (onsuccess)\n                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n            if (onerror)\n                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        };\n    }\n    function hookUpdatingChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function (modifications) {\n            var res = f1.apply(this, arguments);\n            extend(modifications, res);\n            var onsuccess = this.onsuccess,\n            onerror = this.onerror;\n            this.onsuccess = null;\n            this.onerror = null;\n            var res2 = f2.apply(this, arguments);\n            if (onsuccess)\n                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n            if (onerror)\n                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n            return res === undefined ?\n                (res2 === undefined ? undefined : res2) :\n                (extend(res, res2));\n        };\n    }\n    function reverseStoppableEventChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function () {\n            if (f2.apply(this, arguments) === false)\n                return false;\n            return f1.apply(this, arguments);\n        };\n    }\n    function promisableChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function () {\n            var res = f1.apply(this, arguments);\n            if (res && typeof res.then === 'function') {\n                var thiz = this, i = arguments.length, args = new Array(i);\n                while (i--)\n                    args[i] = arguments[i];\n                return res.then(function () {\n                    return f2.apply(thiz, args);\n                });\n            }\n            return f2.apply(this, arguments);\n        };\n    }\n\n    var debug = typeof location !== 'undefined' &&\n        /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n    function setDebug(value, filter) {\n        debug = value;\n    }\n\n    var INTERNAL = {};\n    var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?\n        [] :\n        (function () {\n            var globalP = Promise.resolve();\n            if (typeof crypto === 'undefined' || !crypto.subtle)\n                return [globalP, getProto(globalP), globalP];\n            var nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n            return [\n                nativeP,\n                getProto(nativeP),\n                globalP\n            ];\n        })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\n    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\n    var patchGlobalPromise = !!resolvedGlobalPromise;\n    function schedulePhysicalTick() {\n        queueMicrotask(physicalTick);\n    }\n    var asap = function (callback, args) {\n        microtickQueue.push([callback, args]);\n        if (needsNewPhysicalTick) {\n            schedulePhysicalTick();\n            needsNewPhysicalTick = false;\n        }\n    };\n    var isOutsideMicroTick = true,\n    needsNewPhysicalTick = true,\n    unhandledErrors = [],\n    rejectingErrors = [],\n    rejectionMapper = mirror;\n    var globalPSD = {\n        id: 'global',\n        global: true,\n        ref: 0,\n        unhandleds: [],\n        onunhandled: nop,\n        pgp: false,\n        env: {},\n        finalize: nop\n    };\n    var PSD = globalPSD;\n    var microtickQueue = [];\n    var numScheduledCalls = 0;\n    var tickFinalizers = [];\n    function DexiePromise(fn) {\n        if (typeof this !== 'object')\n            throw new TypeError('Promises must be constructed via new');\n        this._listeners = [];\n        this._lib = false;\n        var psd = (this._PSD = PSD);\n        if (typeof fn !== 'function') {\n            if (fn !== INTERNAL)\n                throw new TypeError('Not a function');\n            this._state = arguments[1];\n            this._value = arguments[2];\n            if (this._state === false)\n                handleRejection(this, this._value);\n            return;\n        }\n        this._state = null;\n        this._value = null;\n        ++psd.ref;\n        executePromiseTask(this, fn);\n    }\n    var thenProp = {\n        get: function () {\n            var psd = PSD, microTaskId = totalEchoes;\n            function then(onFulfilled, onRejected) {\n                var _this = this;\n                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n                var cleanup = possibleAwait && !decrementExpectedAwaits();\n                var rv = new DexiePromise(function (resolve, reject) {\n                    propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n                });\n                if (this._consoleTask)\n                    rv._consoleTask = this._consoleTask;\n                return rv;\n            }\n            then.prototype = INTERNAL;\n            return then;\n        },\n        set: function (value) {\n            setProp(this, 'then', value && value.prototype === INTERNAL ?\n                thenProp :\n                {\n                    get: function () {\n                        return value;\n                    },\n                    set: thenProp.set\n                });\n        }\n    };\n    props(DexiePromise.prototype, {\n        then: thenProp,\n        _then: function (onFulfilled, onRejected) {\n            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n        },\n        catch: function (onRejected) {\n            if (arguments.length === 1)\n                return this.then(null, onRejected);\n            var type = arguments[0], handler = arguments[1];\n            return typeof type === 'function' ? this.then(null, function (err) {\n                return err instanceof type ? handler(err) : PromiseReject(err);\n            })\n                : this.then(null, function (err) {\n                    return err && err.name === type ? handler(err) : PromiseReject(err);\n                });\n        },\n        finally: function (onFinally) {\n            return this.then(function (value) {\n                return DexiePromise.resolve(onFinally()).then(function () { return value; });\n            }, function (err) {\n                return DexiePromise.resolve(onFinally()).then(function () { return PromiseReject(err); });\n            });\n        },\n        timeout: function (ms, msg) {\n            var _this = this;\n            return ms < Infinity ?\n                new DexiePromise(function (resolve, reject) {\n                    var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);\n                    _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n                }) : this;\n        }\n    });\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n        setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\n    globalPSD.env = snapShot();\n    function Listener(onFulfilled, onRejected, resolve, reject, zone) {\n        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n        this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n        this.resolve = resolve;\n        this.reject = reject;\n        this.psd = zone;\n    }\n    props(DexiePromise, {\n        all: function () {\n            var values = getArrayOf.apply(null, arguments)\n                .map(onPossibleParallellAsync);\n            return new DexiePromise(function (resolve, reject) {\n                if (values.length === 0)\n                    resolve([]);\n                var remaining = values.length;\n                values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {\n                    values[i] = x;\n                    if (!--remaining)\n                        resolve(values);\n                }, reject); });\n            });\n        },\n        resolve: function (value) {\n            if (value instanceof DexiePromise)\n                return value;\n            if (value && typeof value.then === 'function')\n                return new DexiePromise(function (resolve, reject) {\n                    value.then(resolve, reject);\n                });\n            var rv = new DexiePromise(INTERNAL, true, value);\n            return rv;\n        },\n        reject: PromiseReject,\n        race: function () {\n            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(function (resolve, reject) {\n                values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });\n            });\n        },\n        PSD: {\n            get: function () { return PSD; },\n            set: function (value) { return PSD = value; }\n        },\n        totalEchoes: { get: function () { return totalEchoes; } },\n        newPSD: newScope,\n        usePSD: usePSD,\n        scheduler: {\n            get: function () { return asap; },\n            set: function (value) { asap = value; }\n        },\n        rejectionMapper: {\n            get: function () { return rejectionMapper; },\n            set: function (value) { rejectionMapper = value; }\n        },\n        follow: function (fn, zoneProps) {\n            return new DexiePromise(function (resolve, reject) {\n                return newScope(function (resolve, reject) {\n                    var psd = PSD;\n                    psd.unhandleds = [];\n                    psd.onunhandled = reject;\n                    psd.finalize = callBoth(function () {\n                        var _this = this;\n                        run_at_end_of_this_or_next_physical_tick(function () {\n                            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);\n                        });\n                    }, psd.finalize);\n                    fn();\n                }, zoneProps, resolve, reject);\n            });\n        }\n    });\n    if (NativePromise) {\n        if (NativePromise.allSettled)\n            setProp(DexiePromise, \"allSettled\", function () {\n                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n                return new DexiePromise(function (resolve) {\n                    if (possiblePromises.length === 0)\n                        resolve([]);\n                    var remaining = possiblePromises.length;\n                    var results = new Array(remaining);\n                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: \"fulfilled\", value: value }; }, function (reason) { return results[i] = { status: \"rejected\", reason: reason }; })\n                        .then(function () { return --remaining || resolve(results); }); });\n                });\n            });\n        if (NativePromise.any && typeof AggregateError !== 'undefined')\n            setProp(DexiePromise, \"any\", function () {\n                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n                return new DexiePromise(function (resolve, reject) {\n                    if (possiblePromises.length === 0)\n                        reject(new AggregateError([]));\n                    var remaining = possiblePromises.length;\n                    var failures = new Array(remaining);\n                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {\n                        failures[i] = failure;\n                        if (!--remaining)\n                            reject(new AggregateError(failures));\n                    }); });\n                });\n            });\n        if (NativePromise.withResolvers)\n            DexiePromise.withResolvers = NativePromise.withResolvers;\n    }\n    function executePromiseTask(promise, fn) {\n        try {\n            fn(function (value) {\n                if (promise._state !== null)\n                    return;\n                if (value === promise)\n                    throw new TypeError('A promise cannot be resolved with itself.');\n                var shouldExecuteTick = promise._lib && beginMicroTickScope();\n                if (value && typeof value.then === 'function') {\n                    executePromiseTask(promise, function (resolve, reject) {\n                        value instanceof DexiePromise ?\n                            value._then(resolve, reject) :\n                            value.then(resolve, reject);\n                    });\n                }\n                else {\n                    promise._state = true;\n                    promise._value = value;\n                    propagateAllListeners(promise);\n                }\n                if (shouldExecuteTick)\n                    endMicroTickScope();\n            }, handleRejection.bind(null, promise));\n        }\n        catch (ex) {\n            handleRejection(promise, ex);\n        }\n    }\n    function handleRejection(promise, reason) {\n        rejectingErrors.push(reason);\n        if (promise._state !== null)\n            return;\n        var shouldExecuteTick = promise._lib && beginMicroTickScope();\n        reason = rejectionMapper(reason);\n        promise._state = false;\n        promise._value = reason;\n        addPossiblyUnhandledError(promise);\n        propagateAllListeners(promise);\n        if (shouldExecuteTick)\n            endMicroTickScope();\n    }\n    function propagateAllListeners(promise) {\n        var listeners = promise._listeners;\n        promise._listeners = [];\n        for (var i = 0, len = listeners.length; i < len; ++i) {\n            propagateToListener(promise, listeners[i]);\n        }\n        var psd = promise._PSD;\n        --psd.ref || psd.finalize();\n        if (numScheduledCalls === 0) {\n            ++numScheduledCalls;\n            asap(function () {\n                if (--numScheduledCalls === 0)\n                    finalizePhysicalTick();\n            }, []);\n        }\n    }\n    function propagateToListener(promise, listener) {\n        if (promise._state === null) {\n            promise._listeners.push(listener);\n            return;\n        }\n        var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n        if (cb === null) {\n            return (promise._state ? listener.resolve : listener.reject)(promise._value);\n        }\n        ++listener.psd.ref;\n        ++numScheduledCalls;\n        asap(callListener, [cb, promise, listener]);\n    }\n    function callListener(cb, promise, listener) {\n        try {\n            var ret, value = promise._value;\n            if (!promise._state && rejectingErrors.length)\n                rejectingErrors = [];\n            ret = debug && promise._consoleTask ? promise._consoleTask.run(function () { return cb(value); }) : cb(value);\n            if (!promise._state && rejectingErrors.indexOf(value) === -1) {\n                markErrorAsHandled(promise);\n            }\n            listener.resolve(ret);\n        }\n        catch (e) {\n            listener.reject(e);\n        }\n        finally {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n            --listener.psd.ref || listener.psd.finalize();\n        }\n    }\n    function physicalTick() {\n        usePSD(globalPSD, function () {\n            beginMicroTickScope() && endMicroTickScope();\n        });\n    }\n    function beginMicroTickScope() {\n        var wasRootExec = isOutsideMicroTick;\n        isOutsideMicroTick = false;\n        needsNewPhysicalTick = false;\n        return wasRootExec;\n    }\n    function endMicroTickScope() {\n        var callbacks, i, l;\n        do {\n            while (microtickQueue.length > 0) {\n                callbacks = microtickQueue;\n                microtickQueue = [];\n                l = callbacks.length;\n                for (i = 0; i < l; ++i) {\n                    var item = callbacks[i];\n                    item[0].apply(null, item[1]);\n                }\n            }\n        } while (microtickQueue.length > 0);\n        isOutsideMicroTick = true;\n        needsNewPhysicalTick = true;\n    }\n    function finalizePhysicalTick() {\n        var unhandledErrs = unhandledErrors;\n        unhandledErrors = [];\n        unhandledErrs.forEach(function (p) {\n            p._PSD.onunhandled.call(null, p._value, p);\n        });\n        var finalizers = tickFinalizers.slice(0);\n        var i = finalizers.length;\n        while (i)\n            finalizers[--i]();\n    }\n    function run_at_end_of_this_or_next_physical_tick(fn) {\n        function finalizer() {\n            fn();\n            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n        }\n        tickFinalizers.push(finalizer);\n        ++numScheduledCalls;\n        asap(function () {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n    function addPossiblyUnhandledError(promise) {\n        if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))\n            unhandledErrors.push(promise);\n    }\n    function markErrorAsHandled(promise) {\n        var i = unhandledErrors.length;\n        while (i)\n            if (unhandledErrors[--i]._value === promise._value) {\n                unhandledErrors.splice(i, 1);\n                return;\n            }\n    }\n    function PromiseReject(reason) {\n        return new DexiePromise(INTERNAL, false, reason);\n    }\n    function wrap(fn, errorCatcher) {\n        var psd = PSD;\n        return function () {\n            var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n            try {\n                switchToZone(psd, true);\n                return fn.apply(this, arguments);\n            }\n            catch (e) {\n                errorCatcher && errorCatcher(e);\n            }\n            finally {\n                switchToZone(outerScope, false);\n                if (wasRootExec)\n                    endMicroTickScope();\n            }\n        };\n    }\n    var task = { awaits: 0, echoes: 0, id: 0 };\n    var taskCounter = 0;\n    var zoneStack = [];\n    var zoneEchoes = 0;\n    var totalEchoes = 0;\n    var zone_id_counter = 0;\n    function newScope(fn, props, a1, a2) {\n        var parent = PSD, psd = Object.create(parent);\n        psd.parent = parent;\n        psd.ref = 0;\n        psd.global = false;\n        psd.id = ++zone_id_counter;\n        globalPSD.env;\n        psd.env = patchGlobalPromise ? {\n            Promise: DexiePromise,\n            PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n            all: DexiePromise.all,\n            race: DexiePromise.race,\n            allSettled: DexiePromise.allSettled,\n            any: DexiePromise.any,\n            resolve: DexiePromise.resolve,\n            reject: DexiePromise.reject,\n        } : {};\n        if (props)\n            extend(psd, props);\n        ++parent.ref;\n        psd.finalize = function () {\n            --this.parent.ref || this.parent.finalize();\n        };\n        var rv = usePSD(psd, fn, a1, a2);\n        if (psd.ref === 0)\n            psd.finalize();\n        return rv;\n    }\n    function incrementExpectedAwaits() {\n        if (!task.id)\n            task.id = ++taskCounter;\n        ++task.awaits;\n        task.echoes += ZONE_ECHO_LIMIT;\n        return task.id;\n    }\n    function decrementExpectedAwaits() {\n        if (!task.awaits)\n            return false;\n        if (--task.awaits === 0)\n            task.id = 0;\n        task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n        return true;\n    }\n    if (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n        incrementExpectedAwaits = decrementExpectedAwaits = nop;\n    }\n    function onPossibleParallellAsync(possiblePromise) {\n        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n            incrementExpectedAwaits();\n            return possiblePromise.then(function (x) {\n                decrementExpectedAwaits();\n                return x;\n            }, function (e) {\n                decrementExpectedAwaits();\n                return rejection(e);\n            });\n        }\n        return possiblePromise;\n    }\n    function zoneEnterEcho(targetZone) {\n        ++totalEchoes;\n        if (!task.echoes || --task.echoes === 0) {\n            task.echoes = task.awaits = task.id = 0;\n        }\n        zoneStack.push(PSD);\n        switchToZone(targetZone, true);\n    }\n    function zoneLeaveEcho() {\n        var zone = zoneStack[zoneStack.length - 1];\n        zoneStack.pop();\n        switchToZone(zone, false);\n    }\n    function switchToZone(targetZone, bEnteringZone) {\n        var currentZone = PSD;\n        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n            queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n        }\n        if (targetZone === PSD)\n            return;\n        PSD = targetZone;\n        if (currentZone === globalPSD)\n            globalPSD.env = snapShot();\n        if (patchGlobalPromise) {\n            var GlobalPromise = globalPSD.env.Promise;\n            var targetEnv = targetZone.env;\n            if (currentZone.global || targetZone.global) {\n                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n                GlobalPromise.all = targetEnv.all;\n                GlobalPromise.race = targetEnv.race;\n                GlobalPromise.resolve = targetEnv.resolve;\n                GlobalPromise.reject = targetEnv.reject;\n                if (targetEnv.allSettled)\n                    GlobalPromise.allSettled = targetEnv.allSettled;\n                if (targetEnv.any)\n                    GlobalPromise.any = targetEnv.any;\n            }\n        }\n    }\n    function snapShot() {\n        var GlobalPromise = _global.Promise;\n        return patchGlobalPromise ? {\n            Promise: GlobalPromise,\n            PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n            all: GlobalPromise.all,\n            race: GlobalPromise.race,\n            allSettled: GlobalPromise.allSettled,\n            any: GlobalPromise.any,\n            resolve: GlobalPromise.resolve,\n            reject: GlobalPromise.reject,\n        } : {};\n    }\n    function usePSD(psd, fn, a1, a2, a3) {\n        var outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn(a1, a2, a3);\n        }\n        finally {\n            switchToZone(outerScope, false);\n        }\n    }\n    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n        return typeof fn !== 'function' ? fn : function () {\n            var outerZone = PSD;\n            if (possibleAwait)\n                incrementExpectedAwaits();\n            switchToZone(zone, true);\n            try {\n                return fn.apply(this, arguments);\n            }\n            finally {\n                switchToZone(outerZone, false);\n                if (cleanup)\n                    queueMicrotask(decrementExpectedAwaits);\n            }\n        };\n    }\n    function execInGlobalContext(cb) {\n        if (Promise === NativePromise && task.echoes === 0) {\n            if (zoneEchoes === 0) {\n                cb();\n            }\n            else {\n                enqueueNativeMicroTask(cb);\n            }\n        }\n        else {\n            setTimeout(cb, 0);\n        }\n    }\n    var rejection = DexiePromise.reject;\n\n    function tempTransaction(db, mode, storeNames, fn) {\n        if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n            if (db._state.openComplete) {\n                return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n            }\n            if (!db._state.isBeingOpened) {\n                if (!db._state.autoOpen)\n                    return rejection(new exceptions.DatabaseClosed());\n                db.open().catch(nop);\n            }\n            return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });\n        }\n        else {\n            var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            }\n            catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn('Dexie: Need to reopen db');\n                    db.close({ disableAutoOpen: false });\n                    return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });\n                }\n                return rejection(ex);\n            }\n            return trans._promise(mode, function (resolve, reject) {\n                return newScope(function () {\n                    PSD.trans = trans;\n                    return fn(resolve, reject, trans);\n                });\n            }).then(function (result) {\n                if (mode === 'readwrite')\n                    try {\n                        trans.idbtrans.commit();\n                    }\n                    catch (_a) { }\n                return mode === 'readonly' ? result : trans._completion.then(function () { return result; });\n            });\n        }\n    }\n\n    var DEXIE_VERSION = '4.0.10';\n    var maxString = String.fromCharCode(65535);\n    var minKey = -Infinity;\n    var INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\n    var STRING_EXPECTED = \"String expected.\";\n    var connections = [];\n    var DBNAMES_DB = '__dbnames';\n    var READONLY = 'readonly';\n    var READWRITE = 'readwrite';\n\n    function combine(filter1, filter2) {\n        return filter1 ?\n            filter2 ?\n                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n                filter1 :\n            filter2;\n    }\n\n    var AnyRange = {\n        type: 3 ,\n        lower: -Infinity,\n        lowerOpen: false,\n        upper: [[]],\n        upperOpen: false\n    };\n\n    function workaroundForUndefinedPrimKey(keyPath) {\n        return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n            ? function (obj) {\n                if (obj[keyPath] === undefined && (keyPath in obj)) {\n                    obj = deepClone(obj);\n                    delete obj[keyPath];\n                }\n                return obj;\n            }\n            : function (obj) { return obj; };\n    }\n\n    function Entity() {\n        throw exceptions.Type();\n    }\n\n    function cmp(a, b) {\n        try {\n            var ta = type(a);\n            var tb = type(b);\n            if (ta !== tb) {\n                if (ta === 'Array')\n                    return 1;\n                if (tb === 'Array')\n                    return -1;\n                if (ta === 'binary')\n                    return 1;\n                if (tb === 'binary')\n                    return -1;\n                if (ta === 'string')\n                    return 1;\n                if (tb === 'string')\n                    return -1;\n                if (ta === 'Date')\n                    return 1;\n                if (tb !== 'Date')\n                    return NaN;\n                return -1;\n            }\n            switch (ta) {\n                case 'number':\n                case 'Date':\n                case 'string':\n                    return a > b ? 1 : a < b ? -1 : 0;\n                case 'binary': {\n                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n                }\n                case 'Array':\n                    return compareArrays(a, b);\n            }\n        }\n        catch (_a) { }\n        return NaN;\n    }\n    function compareArrays(a, b) {\n        var al = a.length;\n        var bl = b.length;\n        var l = al < bl ? al : bl;\n        for (var i = 0; i < l; ++i) {\n            var res = cmp(a[i], b[i]);\n            if (res !== 0)\n                return res;\n        }\n        return al === bl ? 0 : al < bl ? -1 : 1;\n    }\n    function compareUint8Arrays(a, b) {\n        var al = a.length;\n        var bl = b.length;\n        var l = al < bl ? al : bl;\n        for (var i = 0; i < l; ++i) {\n            if (a[i] !== b[i])\n                return a[i] < b[i] ? -1 : 1;\n        }\n        return al === bl ? 0 : al < bl ? -1 : 1;\n    }\n    function type(x) {\n        var t = typeof x;\n        if (t !== 'object')\n            return t;\n        if (ArrayBuffer.isView(x))\n            return 'binary';\n        var tsTag = toStringTag(x);\n        return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n    }\n    function getUint8Array(a) {\n        if (a instanceof Uint8Array)\n            return a;\n        if (ArrayBuffer.isView(a))\n            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n        return new Uint8Array(a);\n    }\n\n    var Table =  (function () {\n        function Table() {\n        }\n        Table.prototype._trans = function (mode, fn, writeLocked) {\n            var trans = this._tx || PSD.trans;\n            var tableName = this.name;\n            var task = debug && typeof console !== 'undefined' && console.createTask && console.createTask(\"Dexie: \".concat(mode === 'readonly' ? 'read' : 'write', \" \").concat(this.name));\n            function checkTableInTransaction(resolve, reject, trans) {\n                if (!trans.schema[tableName])\n                    throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n                return fn(trans.idbtrans, trans);\n            }\n            var wasRootExec = beginMicroTickScope();\n            try {\n                var p = trans && trans.db._novip === this.db._novip ?\n                    trans === PSD.trans ?\n                        trans._promise(mode, checkTableInTransaction, writeLocked) :\n                        newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :\n                    tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n                if (task) {\n                    p._consoleTask = task;\n                    p = p.catch(function (err) {\n                        console.trace(err);\n                        return rejection(err);\n                    });\n                }\n                return p;\n            }\n            finally {\n                if (wasRootExec)\n                    endMicroTickScope();\n            }\n        };\n        Table.prototype.get = function (keyOrCrit, cb) {\n            var _this = this;\n            if (keyOrCrit && keyOrCrit.constructor === Object)\n                return this.where(keyOrCrit).first(cb);\n            if (keyOrCrit == null)\n                return rejection(new exceptions.Type(\"Invalid argument to Table.get()\"));\n            return this._trans('readonly', function (trans) {\n                return _this.core.get({ trans: trans, key: keyOrCrit })\n                    .then(function (res) { return _this.hook.reading.fire(res); });\n            }).then(cb);\n        };\n        Table.prototype.where = function (indexOrCrit) {\n            if (typeof indexOrCrit === 'string')\n                return new this.db.WhereClause(this, indexOrCrit);\n            if (isArray(indexOrCrit))\n                return new this.db.WhereClause(this, \"[\".concat(indexOrCrit.join('+'), \"]\"));\n            var keyPaths = keys(indexOrCrit);\n            if (keyPaths.length === 1)\n                return this\n                    .where(keyPaths[0])\n                    .equals(indexOrCrit[keyPaths[0]]);\n            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\n                if (ix.compound &&\n                    keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; })) {\n                    for (var i = 0; i < keyPaths.length; ++i) {\n                        if (keyPaths.indexOf(ix.keyPath[i]) === -1)\n                            return false;\n                    }\n                    return true;\n                }\n                return false;\n            }).sort(function (a, b) { return a.keyPath.length - b.keyPath.length; })[0];\n            if (compoundIndex && this.db._maxKey !== maxString) {\n                var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n                return this\n                    .where(keyPathsInValidOrder)\n                    .equals(keyPathsInValidOrder.map(function (kp) { return indexOrCrit[kp]; }));\n            }\n            if (!compoundIndex && debug)\n                console.warn(\"The query \".concat(JSON.stringify(indexOrCrit), \" on \").concat(this.name, \" would benefit from a \") +\n                    \"compound index [\".concat(keyPaths.join('+'), \"]\"));\n            var idxByName = this.schema.idxByName;\n            function equals(a, b) {\n                return cmp(a, b) === 0;\n            }\n            var _a = keyPaths.reduce(function (_a, keyPath) {\n                var prevIndex = _a[0], prevFilterFn = _a[1];\n                var index = idxByName[keyPath];\n                var value = indexOrCrit[keyPath];\n                return [\n                    prevIndex || index,\n                    prevIndex || !index ?\n                        combine(prevFilterFn, index && index.multi ?\n                            function (x) {\n                                var prop = getByKeyPath(x, keyPath);\n                                return isArray(prop) && prop.some(function (item) { return equals(value, item); });\n                            } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })\n                        : prevFilterFn\n                ];\n            }, [null, null]), idx = _a[0], filterFunction = _a[1];\n            return idx ?\n                this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                    .filter(filterFunction) :\n                compoundIndex ?\n                    this.filter(filterFunction) :\n                    this.where(keyPaths).equals('');\n        };\n        Table.prototype.filter = function (filterFunction) {\n            return this.toCollection().and(filterFunction);\n        };\n        Table.prototype.count = function (thenShortcut) {\n            return this.toCollection().count(thenShortcut);\n        };\n        Table.prototype.offset = function (offset) {\n            return this.toCollection().offset(offset);\n        };\n        Table.prototype.limit = function (numRows) {\n            return this.toCollection().limit(numRows);\n        };\n        Table.prototype.each = function (callback) {\n            return this.toCollection().each(callback);\n        };\n        Table.prototype.toArray = function (thenShortcut) {\n            return this.toCollection().toArray(thenShortcut);\n        };\n        Table.prototype.toCollection = function () {\n            return new this.db.Collection(new this.db.WhereClause(this));\n        };\n        Table.prototype.orderBy = function (index) {\n            return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n                \"[\".concat(index.join('+'), \"]\") :\n                index));\n        };\n        Table.prototype.reverse = function () {\n            return this.toCollection().reverse();\n        };\n        Table.prototype.mapToClass = function (constructor) {\n            var _a = this, db = _a.db, tableName = _a.name;\n            this.schema.mappedClass = constructor;\n            if (constructor.prototype instanceof Entity) {\n                constructor =  (function (_super) {\n                    __extends(class_1, _super);\n                    function class_1() {\n                        return _super !== null && _super.apply(this, arguments) || this;\n                    }\n                    Object.defineProperty(class_1.prototype, \"db\", {\n                        get: function () { return db; },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    class_1.prototype.table = function () { return tableName; };\n                    return class_1;\n                }(constructor));\n            }\n            var inheritedProps = new Set();\n            for (var proto = constructor.prototype; proto; proto = getProto(proto)) {\n                Object.getOwnPropertyNames(proto).forEach(function (propName) { return inheritedProps.add(propName); });\n            }\n            var readHook = function (obj) {\n                if (!obj)\n                    return obj;\n                var res = Object.create(constructor.prototype);\n                for (var m in obj)\n                    if (!inheritedProps.has(m))\n                        try {\n                            res[m] = obj[m];\n                        }\n                        catch (_) { }\n                return res;\n            };\n            if (this.schema.readHook) {\n                this.hook.reading.unsubscribe(this.schema.readHook);\n            }\n            this.schema.readHook = readHook;\n            this.hook(\"reading\", readHook);\n            return constructor;\n        };\n        Table.prototype.defineClass = function () {\n            function Class(content) {\n                extend(this, content);\n            }\n            return this.mapToClass(Class);\n        };\n        Table.prototype.add = function (obj, key) {\n            var _this = this;\n            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n            var objToAdd = obj;\n            if (keyPath && auto) {\n                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n            }\n            return this._trans('readwrite', function (trans) {\n                return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n            }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n                .then(function (lastResult) {\n                if (keyPath) {\n                    try {\n                        setByKeyPath(obj, keyPath, lastResult);\n                    }\n                    catch (_) { }\n                }\n                return lastResult;\n            });\n        };\n        Table.prototype.update = function (keyOrObject, modifications) {\n            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n                if (key === undefined)\n                    return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n                return this.where(\":id\").equals(key).modify(modifications);\n            }\n            else {\n                return this.where(\":id\").equals(keyOrObject).modify(modifications);\n            }\n        };\n        Table.prototype.put = function (obj, key) {\n            var _this = this;\n            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n            var objToAdd = obj;\n            if (keyPath && auto) {\n                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n            }\n            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })\n                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n                .then(function (lastResult) {\n                if (keyPath) {\n                    try {\n                        setByKeyPath(obj, keyPath, lastResult);\n                    }\n                    catch (_) { }\n                }\n                return lastResult;\n            });\n        };\n        Table.prototype.delete = function (key) {\n            var _this = this;\n            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] }); })\n                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n        };\n        Table.prototype.clear = function () {\n            var _this = this;\n            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange }); })\n                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n        };\n        Table.prototype.bulkGet = function (keys) {\n            var _this = this;\n            return this._trans('readonly', function (trans) {\n                return _this.core.getMany({\n                    keys: keys,\n                    trans: trans\n                }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });\n            });\n        };\n        Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {\n            var _this = this;\n            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n            options = options || (keys ? undefined : keysOrOptions);\n            var wantResults = options ? options.allKeys : undefined;\n            return this._trans('readwrite', function (trans) {\n                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n                if (keyPath && keys)\n                    throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n                if (keys && keys.length !== objects.length)\n                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n                var numObjects = objects.length;\n                var objectsToAdd = keyPath && auto ?\n                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                    objects;\n                return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })\n                    .then(function (_a) {\n                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n                    var result = wantResults ? results : lastResult;\n                    if (numFailures === 0)\n                        return result;\n                    throw new BulkError(\"\".concat(_this.name, \".bulkAdd(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n                });\n            });\n        };\n        Table.prototype.bulkPut = function (objects, keysOrOptions, options) {\n            var _this = this;\n            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n            options = options || (keys ? undefined : keysOrOptions);\n            var wantResults = options ? options.allKeys : undefined;\n            return this._trans('readwrite', function (trans) {\n                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n                if (keyPath && keys)\n                    throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n                if (keys && keys.length !== objects.length)\n                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n                var numObjects = objects.length;\n                var objectsToPut = keyPath && auto ?\n                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                    objects;\n                return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })\n                    .then(function (_a) {\n                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n                    var result = wantResults ? results : lastResult;\n                    if (numFailures === 0)\n                        return result;\n                    throw new BulkError(\"\".concat(_this.name, \".bulkPut(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n                });\n            });\n        };\n        Table.prototype.bulkUpdate = function (keysAndChanges) {\n            var _this = this;\n            var coreTable = this.core;\n            var keys = keysAndChanges.map(function (entry) { return entry.key; });\n            var changeSpecs = keysAndChanges.map(function (entry) { return entry.changes; });\n            var offsetMap = [];\n            return this._trans('readwrite', function (trans) {\n                return coreTable.getMany({ trans: trans, keys: keys, cache: 'clone' }).then(function (objs) {\n                    var resultKeys = [];\n                    var resultObjs = [];\n                    keysAndChanges.forEach(function (_a, idx) {\n                        var key = _a.key, changes = _a.changes;\n                        var obj = objs[idx];\n                        if (obj) {\n                            for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {\n                                var keyPath = _b[_i];\n                                var value = changes[keyPath];\n                                if (keyPath === _this.schema.primKey.keyPath) {\n                                    if (cmp(value, key) !== 0) {\n                                        throw new exceptions.Constraint(\"Cannot update primary key in bulkUpdate()\");\n                                    }\n                                }\n                                else {\n                                    setByKeyPath(obj, keyPath, value);\n                                }\n                            }\n                            offsetMap.push(idx);\n                            resultKeys.push(key);\n                            resultObjs.push(obj);\n                        }\n                    });\n                    var numEntries = resultKeys.length;\n                    return coreTable\n                        .mutate({\n                        trans: trans,\n                        type: 'put',\n                        keys: resultKeys,\n                        values: resultObjs,\n                        updates: {\n                            keys: keys,\n                            changeSpecs: changeSpecs\n                        }\n                    })\n                        .then(function (_a) {\n                        var numFailures = _a.numFailures, failures = _a.failures;\n                        if (numFailures === 0)\n                            return numEntries;\n                        for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {\n                            var offset = _b[_i];\n                            var mappedOffset = offsetMap[Number(offset)];\n                            if (mappedOffset != null) {\n                                var failure = failures[offset];\n                                delete failures[offset];\n                                failures[mappedOffset] = failure;\n                            }\n                        }\n                        throw new BulkError(\"\".concat(_this.name, \".bulkUpdate(): \").concat(numFailures, \" of \").concat(numEntries, \" operations failed\"), failures);\n                    });\n                });\n            });\n        };\n        Table.prototype.bulkDelete = function (keys) {\n            var _this = this;\n            var numKeys = keys.length;\n            return this._trans('readwrite', function (trans) {\n                return _this.core.mutate({ trans: trans, type: 'delete', keys: keys });\n            }).then(function (_a) {\n                var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;\n                if (numFailures === 0)\n                    return lastResult;\n                throw new BulkError(\"\".concat(_this.name, \".bulkDelete(): \").concat(numFailures, \" of \").concat(numKeys, \" operations failed\"), failures);\n            });\n        };\n        return Table;\n    }());\n\n    function Events(ctx) {\n        var evs = {};\n        var rv = function (eventName, subscriber) {\n            if (subscriber) {\n                var i = arguments.length, args = new Array(i - 1);\n                while (--i)\n                    args[i - 1] = arguments[i];\n                evs[eventName].subscribe.apply(null, args);\n                return ctx;\n            }\n            else if (typeof (eventName) === 'string') {\n                return evs[eventName];\n            }\n        };\n        rv.addEventType = add;\n        for (var i = 1, l = arguments.length; i < l; ++i) {\n            add(arguments[i]);\n        }\n        return rv;\n        function add(eventName, chainFunction, defaultFunction) {\n            if (typeof eventName === 'object')\n                return addConfiguredEvents(eventName);\n            if (!chainFunction)\n                chainFunction = reverseStoppableEventChain;\n            if (!defaultFunction)\n                defaultFunction = nop;\n            var context = {\n                subscribers: [],\n                fire: defaultFunction,\n                subscribe: function (cb) {\n                    if (context.subscribers.indexOf(cb) === -1) {\n                        context.subscribers.push(cb);\n                        context.fire = chainFunction(context.fire, cb);\n                    }\n                },\n                unsubscribe: function (cb) {\n                    context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n                }\n            };\n            evs[eventName] = rv[eventName] = context;\n            return context;\n        }\n        function addConfiguredEvents(cfg) {\n            keys(cfg).forEach(function (eventName) {\n                var args = cfg[eventName];\n                if (isArray(args)) {\n                    add(eventName, cfg[eventName][0], cfg[eventName][1]);\n                }\n                else if (args === 'asap') {\n                    var context = add(eventName, mirror, function fire() {\n                        var i = arguments.length, args = new Array(i);\n                        while (i--)\n                            args[i] = arguments[i];\n                        context.subscribers.forEach(function (fn) {\n                            asap$1(function fireEvent() {\n                                fn.apply(null, args);\n                            });\n                        });\n                    });\n                }\n                else\n                    throw new exceptions.InvalidArgument(\"Invalid event config\");\n            });\n        }\n    }\n\n    function makeClassConstructor(prototype, constructor) {\n        derive(constructor).from({ prototype: prototype });\n        return constructor;\n    }\n\n    function createTableConstructor(db) {\n        return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n            this.db = db;\n            this._tx = trans;\n            this.name = name;\n            this.schema = tableSchema;\n            this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n                \"creating\": [hookCreatingChain, nop],\n                \"reading\": [pureFunctionChain, mirror],\n                \"updating\": [hookUpdatingChain, nop],\n                \"deleting\": [hookDeletingChain, nop]\n            });\n        });\n    }\n\n    function isPlainKeyRange(ctx, ignoreLimitFilter) {\n        return !(ctx.filter || ctx.algorithm || ctx.or) &&\n            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n    }\n    function addFilter(ctx, fn) {\n        ctx.filter = combine(ctx.filter, fn);\n    }\n    function addReplayFilter(ctx, factory, isLimitFilter) {\n        var curr = ctx.replayFilter;\n        ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;\n        ctx.justLimit = isLimitFilter && !curr;\n    }\n    function addMatchFilter(ctx, fn) {\n        ctx.isMatch = combine(ctx.isMatch, fn);\n    }\n    function getIndexOrStore(ctx, coreSchema) {\n        if (ctx.isPrimKey)\n            return coreSchema.primaryKey;\n        var index = coreSchema.getIndexByKeyPath(ctx.index);\n        if (!index)\n            throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n        return index;\n    }\n    function openCursor(ctx, coreTable, trans) {\n        var index = getIndexOrStore(ctx, coreTable.schema);\n        return coreTable.openCursor({\n            trans: trans,\n            values: !ctx.keysOnly,\n            reverse: ctx.dir === 'prev',\n            unique: !!ctx.unique,\n            query: {\n                index: index,\n                range: ctx.range\n            }\n        });\n    }\n    function iter(ctx, fn, coreTrans, coreTable) {\n        var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n        if (!ctx.or) {\n            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n        }\n        else {\n            var set_1 = {};\n            var union = function (item, cursor, advance) {\n                if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {\n                    var primaryKey = cursor.primaryKey;\n                    var key = '' + primaryKey;\n                    if (key === '[object ArrayBuffer]')\n                        key = '' + new Uint8Array(primaryKey);\n                    if (!hasOwn(set_1, key)) {\n                        set_1[key] = true;\n                        fn(item, cursor, advance);\n                    }\n                }\n            };\n            return Promise.all([\n                ctx.or._iterate(union, coreTrans),\n                iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n            ]);\n        }\n    }\n    function iterate(cursorPromise, filter, fn, valueMapper) {\n        var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;\n        var wrappedFn = wrap(mappedFn);\n        return cursorPromise.then(function (cursor) {\n            if (cursor) {\n                return cursor.start(function () {\n                    var c = function () { return cursor.continue(); };\n                    if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))\n                        wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });\n                    c();\n                });\n            }\n        });\n    }\n\n    var PropModSymbol = Symbol();\n    var PropModification =  (function () {\n        function PropModification(spec) {\n            Object.assign(this, spec);\n        }\n        PropModification.prototype.execute = function (value) {\n            var _a;\n            if (this.add !== undefined) {\n                var term = this.add;\n                if (isArray(term)) {\n                    return __spreadArray(__spreadArray([], (isArray(value) ? value : []), true), term, true).sort();\n                }\n                if (typeof term === 'number')\n                    return (Number(value) || 0) + term;\n                if (typeof term === 'bigint') {\n                    try {\n                        return BigInt(value) + term;\n                    }\n                    catch (_b) {\n                        return BigInt(0) + term;\n                    }\n                }\n                throw new TypeError(\"Invalid term \".concat(term));\n            }\n            if (this.remove !== undefined) {\n                var subtrahend_1 = this.remove;\n                if (isArray(subtrahend_1)) {\n                    return isArray(value) ? value.filter(function (item) { return !subtrahend_1.includes(item); }).sort() : [];\n                }\n                if (typeof subtrahend_1 === 'number')\n                    return Number(value) - subtrahend_1;\n                if (typeof subtrahend_1 === 'bigint') {\n                    try {\n                        return BigInt(value) - subtrahend_1;\n                    }\n                    catch (_c) {\n                        return BigInt(0) - subtrahend_1;\n                    }\n                }\n                throw new TypeError(\"Invalid subtrahend \".concat(subtrahend_1));\n            }\n            var prefixToReplace = (_a = this.replacePrefix) === null || _a === void 0 ? void 0 : _a[0];\n            if (prefixToReplace && typeof value === 'string' && value.startsWith(prefixToReplace)) {\n                return this.replacePrefix[1] + value.substring(prefixToReplace.length);\n            }\n            return value;\n        };\n        return PropModification;\n    }());\n\n    var Collection =  (function () {\n        function Collection() {\n        }\n        Collection.prototype._read = function (fn, cb) {\n            var ctx = this._ctx;\n            return ctx.error ?\n                ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n                ctx.table._trans('readonly', fn).then(cb);\n        };\n        Collection.prototype._write = function (fn) {\n            var ctx = this._ctx;\n            return ctx.error ?\n                ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n                ctx.table._trans('readwrite', fn, \"locked\");\n        };\n        Collection.prototype._addAlgorithm = function (fn) {\n            var ctx = this._ctx;\n            ctx.algorithm = combine(ctx.algorithm, fn);\n        };\n        Collection.prototype._iterate = function (fn, coreTrans) {\n            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n        };\n        Collection.prototype.clone = function (props) {\n            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n            if (props)\n                extend(ctx, props);\n            rv._ctx = ctx;\n            return rv;\n        };\n        Collection.prototype.raw = function () {\n            this._ctx.valueMapper = null;\n            return this;\n        };\n        Collection.prototype.each = function (fn) {\n            var ctx = this._ctx;\n            return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });\n        };\n        Collection.prototype.count = function (cb) {\n            var _this = this;\n            return this._read(function (trans) {\n                var ctx = _this._ctx;\n                var coreTable = ctx.table.core;\n                if (isPlainKeyRange(ctx, true)) {\n                    return coreTable.count({\n                        trans: trans,\n                        query: {\n                            index: getIndexOrStore(ctx, coreTable.schema),\n                            range: ctx.range\n                        }\n                    }).then(function (count) { return Math.min(count, ctx.limit); });\n                }\n                else {\n                    var count = 0;\n                    return iter(ctx, function () { ++count; return false; }, trans, coreTable)\n                        .then(function () { return count; });\n                }\n            }).then(cb);\n        };\n        Collection.prototype.sortBy = function (keyPath, cb) {\n            var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n            function getval(obj, i) {\n                if (i)\n                    return getval(obj[parts[i]], i - 1);\n                return obj[lastPart];\n            }\n            var order = this._ctx.dir === \"next\" ? 1 : -1;\n            function sorter(a, b) {\n                var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n                return cmp(aVal, bVal) * order;\n            }\n            return this.toArray(function (a) {\n                return a.sort(sorter);\n            }).then(cb);\n        };\n        Collection.prototype.toArray = function (cb) {\n            var _this = this;\n            return this._read(function (trans) {\n                var ctx = _this._ctx;\n                if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                    var valueMapper_1 = ctx.valueMapper;\n                    var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                    return ctx.table.core.query({\n                        trans: trans,\n                        limit: ctx.limit,\n                        values: true,\n                        query: {\n                            index: index,\n                            range: ctx.range\n                        }\n                    }).then(function (_a) {\n                        var result = _a.result;\n                        return valueMapper_1 ? result.map(valueMapper_1) : result;\n                    });\n                }\n                else {\n                    var a_1 = [];\n                    return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });\n                }\n            }, cb);\n        };\n        Collection.prototype.offset = function (offset) {\n            var ctx = this._ctx;\n            if (offset <= 0)\n                return this;\n            ctx.offset += offset;\n            if (isPlainKeyRange(ctx)) {\n                addReplayFilter(ctx, function () {\n                    var offsetLeft = offset;\n                    return function (cursor, advance) {\n                        if (offsetLeft === 0)\n                            return true;\n                        if (offsetLeft === 1) {\n                            --offsetLeft;\n                            return false;\n                        }\n                        advance(function () {\n                            cursor.advance(offsetLeft);\n                            offsetLeft = 0;\n                        });\n                        return false;\n                    };\n                });\n            }\n            else {\n                addReplayFilter(ctx, function () {\n                    var offsetLeft = offset;\n                    return function () { return (--offsetLeft < 0); };\n                });\n            }\n            return this;\n        };\n        Collection.prototype.limit = function (numRows) {\n            this._ctx.limit = Math.min(this._ctx.limit, numRows);\n            addReplayFilter(this._ctx, function () {\n                var rowsLeft = numRows;\n                return function (cursor, advance, resolve) {\n                    if (--rowsLeft <= 0)\n                        advance(resolve);\n                    return rowsLeft >= 0;\n                };\n            }, true);\n            return this;\n        };\n        Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {\n            addFilter(this._ctx, function (cursor, advance, resolve) {\n                if (filterFunction(cursor.value)) {\n                    advance(resolve);\n                    return bIncludeStopEntry;\n                }\n                else {\n                    return true;\n                }\n            });\n            return this;\n        };\n        Collection.prototype.first = function (cb) {\n            return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n        };\n        Collection.prototype.last = function (cb) {\n            return this.reverse().first(cb);\n        };\n        Collection.prototype.filter = function (filterFunction) {\n            addFilter(this._ctx, function (cursor) {\n                return filterFunction(cursor.value);\n            });\n            addMatchFilter(this._ctx, filterFunction);\n            return this;\n        };\n        Collection.prototype.and = function (filter) {\n            return this.filter(filter);\n        };\n        Collection.prototype.or = function (indexName) {\n            return new this.db.WhereClause(this._ctx.table, indexName, this);\n        };\n        Collection.prototype.reverse = function () {\n            this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n            if (this._ondirectionchange)\n                this._ondirectionchange(this._ctx.dir);\n            return this;\n        };\n        Collection.prototype.desc = function () {\n            return this.reverse();\n        };\n        Collection.prototype.eachKey = function (cb) {\n            var ctx = this._ctx;\n            ctx.keysOnly = !ctx.isMatch;\n            return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n        };\n        Collection.prototype.eachUniqueKey = function (cb) {\n            this._ctx.unique = \"unique\";\n            return this.eachKey(cb);\n        };\n        Collection.prototype.eachPrimaryKey = function (cb) {\n            var ctx = this._ctx;\n            ctx.keysOnly = !ctx.isMatch;\n            return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n        };\n        Collection.prototype.keys = function (cb) {\n            var ctx = this._ctx;\n            ctx.keysOnly = !ctx.isMatch;\n            var a = [];\n            return this.each(function (item, cursor) {\n                a.push(cursor.key);\n            }).then(function () {\n                return a;\n            }).then(cb);\n        };\n        Collection.prototype.primaryKeys = function (cb) {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                return this._read(function (trans) {\n                    var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                    return ctx.table.core.query({\n                        trans: trans,\n                        values: false,\n                        limit: ctx.limit,\n                        query: {\n                            index: index,\n                            range: ctx.range\n                        }\n                    });\n                }).then(function (_a) {\n                    var result = _a.result;\n                    return result;\n                }).then(cb);\n            }\n            ctx.keysOnly = !ctx.isMatch;\n            var a = [];\n            return this.each(function (item, cursor) {\n                a.push(cursor.primaryKey);\n            }).then(function () {\n                return a;\n            }).then(cb);\n        };\n        Collection.prototype.uniqueKeys = function (cb) {\n            this._ctx.unique = \"unique\";\n            return this.keys(cb);\n        };\n        Collection.prototype.firstKey = function (cb) {\n            return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n        };\n        Collection.prototype.lastKey = function (cb) {\n            return this.reverse().firstKey(cb);\n        };\n        Collection.prototype.distinct = function () {\n            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n            if (!idx || !idx.multi)\n                return this;\n            var set = {};\n            addFilter(this._ctx, function (cursor) {\n                var strKey = cursor.primaryKey.toString();\n                var found = hasOwn(set, strKey);\n                set[strKey] = true;\n                return !found;\n            });\n            return this;\n        };\n        Collection.prototype.modify = function (changes) {\n            var _this = this;\n            var ctx = this._ctx;\n            return this._write(function (trans) {\n                var modifyer;\n                if (typeof changes === 'function') {\n                    modifyer = changes;\n                }\n                else {\n                    var keyPaths = keys(changes);\n                    var numKeys = keyPaths.length;\n                    modifyer = function (item) {\n                        var anythingModified = false;\n                        for (var i = 0; i < numKeys; ++i) {\n                            var keyPath = keyPaths[i];\n                            var val = changes[keyPath];\n                            var origVal = getByKeyPath(item, keyPath);\n                            if (val instanceof PropModification) {\n                                setByKeyPath(item, keyPath, val.execute(origVal));\n                                anythingModified = true;\n                            }\n                            else if (origVal !== val) {\n                                setByKeyPath(item, keyPath, val);\n                                anythingModified = true;\n                            }\n                        }\n                        return anythingModified;\n                    };\n                }\n                var coreTable = ctx.table.core;\n                var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;\n                var limit = 200;\n                var modifyChunkSize = _this.db._options.modifyChunkSize;\n                if (modifyChunkSize) {\n                    if (typeof modifyChunkSize == 'object') {\n                        limit = modifyChunkSize[coreTable.name] || modifyChunkSize['*'] || 200;\n                    }\n                    else {\n                        limit = modifyChunkSize;\n                    }\n                }\n                var totalFailures = [];\n                var successCount = 0;\n                var failedKeys = [];\n                var applyMutateResult = function (expectedCount, res) {\n                    var failures = res.failures, numFailures = res.numFailures;\n                    successCount += expectedCount - numFailures;\n                    for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {\n                        var pos = _a[_i];\n                        totalFailures.push(failures[pos]);\n                    }\n                };\n                return _this.clone().primaryKeys().then(function (keys) {\n                    var criteria = isPlainKeyRange(ctx) &&\n                        ctx.limit === Infinity &&\n                        (typeof changes !== 'function' || changes === deleteCallback) && {\n                        index: ctx.index,\n                        range: ctx.range\n                    };\n                    var nextChunk = function (offset) {\n                        var count = Math.min(limit, keys.length - offset);\n                        return coreTable.getMany({\n                            trans: trans,\n                            keys: keys.slice(offset, offset + count),\n                            cache: \"immutable\"\n                        }).then(function (values) {\n                            var addValues = [];\n                            var putValues = [];\n                            var putKeys = outbound ? [] : null;\n                            var deleteKeys = [];\n                            for (var i = 0; i < count; ++i) {\n                                var origValue = values[i];\n                                var ctx_1 = {\n                                    value: deepClone(origValue),\n                                    primKey: keys[offset + i]\n                                };\n                                if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {\n                                    if (ctx_1.value == null) {\n                                        deleteKeys.push(keys[offset + i]);\n                                    }\n                                    else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {\n                                        deleteKeys.push(keys[offset + i]);\n                                        addValues.push(ctx_1.value);\n                                    }\n                                    else {\n                                        putValues.push(ctx_1.value);\n                                        if (outbound)\n                                            putKeys.push(keys[offset + i]);\n                                    }\n                                }\n                            }\n                            return Promise.resolve(addValues.length > 0 &&\n                                coreTable.mutate({ trans: trans, type: 'add', values: addValues })\n                                    .then(function (res) {\n                                    for (var pos in res.failures) {\n                                        deleteKeys.splice(parseInt(pos), 1);\n                                    }\n                                    applyMutateResult(addValues.length, res);\n                                })).then(function () { return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                                coreTable.mutate({\n                                    trans: trans,\n                                    type: 'put',\n                                    keys: putKeys,\n                                    values: putValues,\n                                    criteria: criteria,\n                                    changeSpec: typeof changes !== 'function'\n                                        && changes,\n                                    isAdditionalChunk: offset > 0\n                                }).then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                                coreTable.mutate({\n                                    trans: trans,\n                                    type: 'delete',\n                                    keys: deleteKeys,\n                                    criteria: criteria,\n                                    isAdditionalChunk: offset > 0\n                                }).then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {\n                                return keys.length > offset + count && nextChunk(offset + limit);\n                            });\n                        });\n                    };\n                    return nextChunk(0).then(function () {\n                        if (totalFailures.length > 0)\n                            throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                        return keys.length;\n                    });\n                });\n            });\n        };\n        Collection.prototype.delete = function () {\n            var ctx = this._ctx, range = ctx.range;\n            if (isPlainKeyRange(ctx) &&\n                (ctx.isPrimKey || range.type === 3 ))\n             {\n                return this._write(function (trans) {\n                    var primaryKey = ctx.table.core.schema.primaryKey;\n                    var coreRange = range;\n                    return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {\n                        return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })\n                            .then(function (_a) {\n                            var failures = _a.failures; _a.lastResult; _a.results; var numFailures = _a.numFailures;\n                            if (numFailures)\n                                throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);\n                            return count - numFailures;\n                        });\n                    });\n                });\n            }\n            return this.modify(deleteCallback);\n        };\n        return Collection;\n    }());\n    var deleteCallback = function (value, ctx) { return ctx.value = null; };\n\n    function createCollectionConstructor(db) {\n        return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n            this.db = db;\n            var keyRange = AnyRange, error = null;\n            if (keyRangeGenerator)\n                try {\n                    keyRange = keyRangeGenerator();\n                }\n                catch (ex) {\n                    error = ex;\n                }\n            var whereCtx = whereClause._ctx;\n            var table = whereCtx.table;\n            var readingHook = table.hook.reading.fire;\n            this._ctx = {\n                table: table,\n                index: whereCtx.index,\n                isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n                range: keyRange,\n                keysOnly: false,\n                dir: \"next\",\n                unique: \"\",\n                algorithm: null,\n                filter: null,\n                replayFilter: null,\n                justLimit: true,\n                isMatch: null,\n                offset: 0,\n                limit: Infinity,\n                error: error,\n                or: whereCtx.or,\n                valueMapper: readingHook !== mirror ? readingHook : null\n            };\n        });\n    }\n\n    function simpleCompare(a, b) {\n        return a < b ? -1 : a === b ? 0 : 1;\n    }\n    function simpleCompareReverse(a, b) {\n        return a > b ? -1 : a === b ? 0 : 1;\n    }\n\n    function fail(collectionOrWhereClause, err, T) {\n        var collection = collectionOrWhereClause instanceof WhereClause ?\n            new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n            collectionOrWhereClause;\n        collection._ctx.error = T ? new T(err) : new TypeError(err);\n        return collection;\n    }\n    function emptyCollection(whereClause) {\n        return new whereClause.Collection(whereClause, function () { return rangeEqual(\"\"); }).limit(0);\n    }\n    function upperFactory(dir) {\n        return dir === \"next\" ?\n            function (s) { return s.toUpperCase(); } :\n            function (s) { return s.toLowerCase(); };\n    }\n    function lowerFactory(dir) {\n        return dir === \"next\" ?\n            function (s) { return s.toLowerCase(); } :\n            function (s) { return s.toUpperCase(); };\n    }\n    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n        var length = Math.min(key.length, lowerNeedle.length);\n        var llp = -1;\n        for (var i = 0; i < length; ++i) {\n            var lwrKeyChar = lowerKey[i];\n            if (lwrKeyChar !== lowerNeedle[i]) {\n                if (cmp(key[i], upperNeedle[i]) < 0)\n                    return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n                if (cmp(key[i], lowerNeedle[i]) < 0)\n                    return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n                if (llp >= 0)\n                    return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n                return null;\n            }\n            if (cmp(key[i], lwrKeyChar) < 0)\n                llp = i;\n        }\n        if (length < lowerNeedle.length && dir === \"next\")\n            return key + upperNeedle.substr(key.length);\n        if (length < key.length && dir === \"prev\")\n            return key.substr(0, upperNeedle.length);\n        return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n    }\n    function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n        if (!needles.every(function (s) { return typeof s === 'string'; })) {\n            return fail(whereClause, STRING_EXPECTED);\n        }\n        function initDirection(dir) {\n            upper = upperFactory(dir);\n            lower = lowerFactory(dir);\n            compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n            var needleBounds = needles.map(function (needle) {\n                return { lower: lower(needle), upper: upper(needle) };\n            }).sort(function (a, b) {\n                return compare(a.lower, b.lower);\n            });\n            upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n            lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n            direction = dir;\n            nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n        }\n        initDirection(\"next\");\n        var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });\n        c._ondirectionchange = function (direction) {\n            initDirection(direction);\n        };\n        var firstPossibleNeedle = 0;\n        c._addAlgorithm(function (cursor, advance, resolve) {\n            var key = cursor.key;\n            if (typeof key !== 'string')\n                return false;\n            var lowerKey = lower(key);\n            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n                return true;\n            }\n            else {\n                var lowestPossibleCasing = null;\n                for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                    var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                    if (casing === null && lowestPossibleCasing === null)\n                        firstPossibleNeedle = i + 1;\n                    else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                        lowestPossibleCasing = casing;\n                    }\n                }\n                if (lowestPossibleCasing !== null) {\n                    advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n                }\n                else {\n                    advance(resolve);\n                }\n                return false;\n            }\n        });\n        return c;\n    }\n    function createRange(lower, upper, lowerOpen, upperOpen) {\n        return {\n            type: 2 ,\n            lower: lower,\n            upper: upper,\n            lowerOpen: lowerOpen,\n            upperOpen: upperOpen\n        };\n    }\n    function rangeEqual(value) {\n        return {\n            type: 1 ,\n            lower: value,\n            upper: value\n        };\n    }\n\n    var WhereClause =  (function () {\n        function WhereClause() {\n        }\n        Object.defineProperty(WhereClause.prototype, \"Collection\", {\n            get: function () {\n                return this._ctx.table.db.Collection;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {\n            includeLower = includeLower !== false;\n            includeUpper = includeUpper === true;\n            try {\n                if ((this._cmp(lower, upper) > 0) ||\n                    (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                    return emptyCollection(this);\n                return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });\n            }\n            catch (e) {\n                return fail(this, INVALID_KEY_ARGUMENT);\n            }\n        };\n        WhereClause.prototype.equals = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return rangeEqual(value); });\n        };\n        WhereClause.prototype.above = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return createRange(value, undefined, true); });\n        };\n        WhereClause.prototype.aboveOrEqual = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return createRange(value, undefined, false); });\n        };\n        WhereClause.prototype.below = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return createRange(undefined, value, false, true); });\n        };\n        WhereClause.prototype.belowOrEqual = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return createRange(undefined, value); });\n        };\n        WhereClause.prototype.startsWith = function (str) {\n            if (typeof str !== 'string')\n                return fail(this, STRING_EXPECTED);\n            return this.between(str, str + maxString, true, true);\n        };\n        WhereClause.prototype.startsWithIgnoreCase = function (str) {\n            if (str === \"\")\n                return this.startsWith(str);\n            return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);\n        };\n        WhereClause.prototype.equalsIgnoreCase = function (str) {\n            return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], \"\");\n        };\n        WhereClause.prototype.anyOfIgnoreCase = function () {\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            if (set.length === 0)\n                return emptyCollection(this);\n            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, \"\");\n        };\n        WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            if (set.length === 0)\n                return emptyCollection(this);\n            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);\n        };\n        WhereClause.prototype.anyOf = function () {\n            var _this = this;\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            var compare = this._cmp;\n            try {\n                set.sort(compare);\n            }\n            catch (e) {\n                return fail(this, INVALID_KEY_ARGUMENT);\n            }\n            if (set.length === 0)\n                return emptyCollection(this);\n            var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });\n            c._ondirectionchange = function (direction) {\n                compare = (direction === \"next\" ?\n                    _this._ascending :\n                    _this._descending);\n                set.sort(compare);\n            };\n            var i = 0;\n            c._addAlgorithm(function (cursor, advance, resolve) {\n                var key = cursor.key;\n                while (compare(key, set[i]) > 0) {\n                    ++i;\n                    if (i === set.length) {\n                        advance(resolve);\n                        return false;\n                    }\n                }\n                if (compare(key, set[i]) === 0) {\n                    return true;\n                }\n                else {\n                    advance(function () { cursor.continue(set[i]); });\n                    return false;\n                }\n            });\n            return c;\n        };\n        WhereClause.prototype.notEqual = function (value) {\n            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n        };\n        WhereClause.prototype.noneOf = function () {\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            if (set.length === 0)\n                return new this.Collection(this);\n            try {\n                set.sort(this._ascending);\n            }\n            catch (e) {\n                return fail(this, INVALID_KEY_ARGUMENT);\n            }\n            var ranges = set.reduce(function (res, val) { return res ?\n                res.concat([[res[res.length - 1][1], val]]) :\n                [[minKey, val]]; }, null);\n            ranges.push([set[set.length - 1], this.db._maxKey]);\n            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n        };\n        WhereClause.prototype.inAnyRange = function (ranges, options) {\n            var _this = this;\n            var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n            if (ranges.length === 0)\n                return emptyCollection(this);\n            if (!ranges.every(function (range) {\n                return range[0] !== undefined &&\n                    range[1] !== undefined &&\n                    ascending(range[0], range[1]) <= 0;\n            })) {\n                return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n            }\n            var includeLowers = !options || options.includeLowers !== false;\n            var includeUppers = options && options.includeUppers === true;\n            function addRange(ranges, newRange) {\n                var i = 0, l = ranges.length;\n                for (; i < l; ++i) {\n                    var range = ranges[i];\n                    if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                        range[0] = min(range[0], newRange[0]);\n                        range[1] = max(range[1], newRange[1]);\n                        break;\n                    }\n                }\n                if (i === l)\n                    ranges.push(newRange);\n                return ranges;\n            }\n            var sortDirection = ascending;\n            function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n            var set;\n            try {\n                set = ranges.reduce(addRange, []);\n                set.sort(rangeSorter);\n            }\n            catch (ex) {\n                return fail(this, INVALID_KEY_ARGUMENT);\n            }\n            var rangePos = 0;\n            var keyIsBeyondCurrentEntry = includeUppers ?\n                function (key) { return ascending(key, set[rangePos][1]) > 0; } :\n                function (key) { return ascending(key, set[rangePos][1]) >= 0; };\n            var keyIsBeforeCurrentEntry = includeLowers ?\n                function (key) { return descending(key, set[rangePos][0]) > 0; } :\n                function (key) { return descending(key, set[rangePos][0]) >= 0; };\n            function keyWithinCurrentRange(key) {\n                return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n            }\n            var checkKey = keyIsBeyondCurrentEntry;\n            var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });\n            c._ondirectionchange = function (direction) {\n                if (direction === \"next\") {\n                    checkKey = keyIsBeyondCurrentEntry;\n                    sortDirection = ascending;\n                }\n                else {\n                    checkKey = keyIsBeforeCurrentEntry;\n                    sortDirection = descending;\n                }\n                set.sort(rangeSorter);\n            };\n            c._addAlgorithm(function (cursor, advance, resolve) {\n                var key = cursor.key;\n                while (checkKey(key)) {\n                    ++rangePos;\n                    if (rangePos === set.length) {\n                        advance(resolve);\n                        return false;\n                    }\n                }\n                if (keyWithinCurrentRange(key)) {\n                    return true;\n                }\n                else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {\n                    return false;\n                }\n                else {\n                    advance(function () {\n                        if (sortDirection === ascending)\n                            cursor.continue(set[rangePos][0]);\n                        else\n                            cursor.continue(set[rangePos][1]);\n                    });\n                    return false;\n                }\n            });\n            return c;\n        };\n        WhereClause.prototype.startsWithAnyOf = function () {\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            if (!set.every(function (s) { return typeof s === 'string'; })) {\n                return fail(this, \"startsWithAnyOf() only works with strings\");\n            }\n            if (set.length === 0)\n                return emptyCollection(this);\n            return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));\n        };\n        return WhereClause;\n    }());\n\n    function createWhereClauseConstructor(db) {\n        return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n            this.db = db;\n            this._ctx = {\n                table: table,\n                index: index === \":id\" ? null : index,\n                or: orCollection\n            };\n            this._cmp = this._ascending = cmp;\n            this._descending = function (a, b) { return cmp(b, a); };\n            this._max = function (a, b) { return cmp(a, b) > 0 ? a : b; };\n            this._min = function (a, b) { return cmp(a, b) < 0 ? a : b; };\n            this._IDBKeyRange = db._deps.IDBKeyRange;\n            if (!this._IDBKeyRange)\n                throw new exceptions.MissingAPI();\n        });\n    }\n\n    function eventRejectHandler(reject) {\n        return wrap(function (event) {\n            preventDefault(event);\n            reject(event.target.error);\n            return false;\n        });\n    }\n    function preventDefault(event) {\n        if (event.stopPropagation)\n            event.stopPropagation();\n        if (event.preventDefault)\n            event.preventDefault();\n    }\n\n    var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\n    var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\n    var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\n    var Transaction =  (function () {\n        function Transaction() {\n        }\n        Transaction.prototype._lock = function () {\n            assert(!PSD.global);\n            ++this._reculock;\n            if (this._reculock === 1 && !PSD.global)\n                PSD.lockOwnerFor = this;\n            return this;\n        };\n        Transaction.prototype._unlock = function () {\n            assert(!PSD.global);\n            if (--this._reculock === 0) {\n                if (!PSD.global)\n                    PSD.lockOwnerFor = null;\n                while (this._blockedFuncs.length > 0 && !this._locked()) {\n                    var fnAndPSD = this._blockedFuncs.shift();\n                    try {\n                        usePSD(fnAndPSD[1], fnAndPSD[0]);\n                    }\n                    catch (e) { }\n                }\n            }\n            return this;\n        };\n        Transaction.prototype._locked = function () {\n            return this._reculock && PSD.lockOwnerFor !== this;\n        };\n        Transaction.prototype.create = function (idbtrans) {\n            var _this = this;\n            if (!this.mode)\n                return this;\n            var idbdb = this.db.idbdb;\n            var dbOpenError = this.db._state.dbOpenError;\n            assert(!this.idbtrans);\n            if (!idbtrans && !idbdb) {\n                switch (dbOpenError && dbOpenError.name) {\n                    case \"DatabaseClosedError\":\n                        throw new exceptions.DatabaseClosed(dbOpenError);\n                    case \"MissingAPIError\":\n                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                    default:\n                        throw new exceptions.OpenFailed(dbOpenError);\n                }\n            }\n            if (!this.active)\n                throw new exceptions.TransactionInactive();\n            assert(this._completion._state === null);\n            idbtrans = this.idbtrans = idbtrans ||\n                (this.db.core\n                    ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                    : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n            idbtrans.onerror = wrap(function (ev) {\n                preventDefault(ev);\n                _this._reject(idbtrans.error);\n            });\n            idbtrans.onabort = wrap(function (ev) {\n                preventDefault(ev);\n                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));\n                _this.active = false;\n                _this.on(\"abort\").fire(ev);\n            });\n            idbtrans.oncomplete = wrap(function () {\n                _this.active = false;\n                _this._resolve();\n                if ('mutatedParts' in idbtrans) {\n                    globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n                }\n            });\n            return this;\n        };\n        Transaction.prototype._promise = function (mode, fn, bWriteLock) {\n            var _this = this;\n            if (mode === 'readwrite' && this.mode !== 'readwrite')\n                return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n            if (!this.active)\n                return rejection(new exceptions.TransactionInactive());\n            if (this._locked()) {\n                return new DexiePromise(function (resolve, reject) {\n                    _this._blockedFuncs.push([function () {\n                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                        }, PSD]);\n                });\n            }\n            else if (bWriteLock) {\n                return newScope(function () {\n                    var p = new DexiePromise(function (resolve, reject) {\n                        _this._lock();\n                        var rv = fn(resolve, reject, _this);\n                        if (rv && rv.then)\n                            rv.then(resolve, reject);\n                    });\n                    p.finally(function () { return _this._unlock(); });\n                    p._lib = true;\n                    return p;\n                });\n            }\n            else {\n                var p = new DexiePromise(function (resolve, reject) {\n                    var rv = fn(resolve, reject, _this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p._lib = true;\n                return p;\n            }\n        };\n        Transaction.prototype._root = function () {\n            return this.parent ? this.parent._root() : this;\n        };\n        Transaction.prototype.waitFor = function (promiseLike) {\n            var root = this._root();\n            var promise = DexiePromise.resolve(promiseLike);\n            if (root._waitingFor) {\n                root._waitingFor = root._waitingFor.then(function () { return promise; });\n            }\n            else {\n                root._waitingFor = promise;\n                root._waitingQueue = [];\n                var store = root.idbtrans.objectStore(root.storeNames[0]);\n                (function spin() {\n                    ++root._spinCount;\n                    while (root._waitingQueue.length)\n                        (root._waitingQueue.shift())();\n                    if (root._waitingFor)\n                        store.get(-Infinity).onsuccess = spin;\n                }());\n            }\n            var currentWaitPromise = root._waitingFor;\n            return new DexiePromise(function (resolve, reject) {\n                promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {\n                    if (root._waitingFor === currentWaitPromise) {\n                        root._waitingFor = null;\n                    }\n                });\n            });\n        };\n        Transaction.prototype.abort = function () {\n            if (this.active) {\n                this.active = false;\n                if (this.idbtrans)\n                    this.idbtrans.abort();\n                this._reject(new exceptions.Abort());\n            }\n        };\n        Transaction.prototype.table = function (tableName) {\n            var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n            if (hasOwn(memoizedTables, tableName))\n                return memoizedTables[tableName];\n            var tableSchema = this.schema[tableName];\n            if (!tableSchema) {\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            }\n            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n            transactionBoundTable.core = this.db.core.table(tableName);\n            memoizedTables[tableName] = transactionBoundTable;\n            return transactionBoundTable;\n        };\n        return Transaction;\n    }());\n\n    function createTransactionConstructor(db) {\n        return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n            var _this = this;\n            this.db = db;\n            this.mode = mode;\n            this.storeNames = storeNames;\n            this.schema = dbschema;\n            this.chromeTransactionDurability = chromeTransactionDurability;\n            this.idbtrans = null;\n            this.on = Events(this, \"complete\", \"error\", \"abort\");\n            this.parent = parent || null;\n            this.active = true;\n            this._reculock = 0;\n            this._blockedFuncs = [];\n            this._resolve = null;\n            this._reject = null;\n            this._waitingFor = null;\n            this._waitingQueue = null;\n            this._spinCount = 0;\n            this._completion = new DexiePromise(function (resolve, reject) {\n                _this._resolve = resolve;\n                _this._reject = reject;\n            });\n            this._completion.then(function () {\n                _this.active = false;\n                _this.on.complete.fire();\n            }, function (e) {\n                var wasActive = _this.active;\n                _this.active = false;\n                _this.on.error.fire(e);\n                _this.parent ?\n                    _this.parent._reject(e) :\n                    wasActive && _this.idbtrans && _this.idbtrans.abort();\n                return rejection(e);\n            });\n        });\n    }\n\n    function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n        return {\n            name: name,\n            keyPath: keyPath,\n            unique: unique,\n            multi: multi,\n            auto: auto,\n            compound: compound,\n            src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n        };\n    }\n    function nameFromKeyPath(keyPath) {\n        return typeof keyPath === 'string' ?\n            keyPath :\n            keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n    }\n\n    function createTableSchema(name, primKey, indexes) {\n        return {\n            name: name,\n            primKey: primKey,\n            indexes: indexes,\n            mappedClass: null,\n            idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; })\n        };\n    }\n\n    function safariMultiStoreFix(storeNames) {\n        return storeNames.length === 1 ? storeNames[0] : storeNames;\n    }\n    var getMaxKey = function (IdbKeyRange) {\n        try {\n            IdbKeyRange.only([[]]);\n            getMaxKey = function () { return [[]]; };\n            return [[]];\n        }\n        catch (e) {\n            getMaxKey = function () { return maxString; };\n            return maxString;\n        }\n    };\n\n    function getKeyExtractor(keyPath) {\n        if (keyPath == null) {\n            return function () { return undefined; };\n        }\n        else if (typeof keyPath === 'string') {\n            return getSinglePathKeyExtractor(keyPath);\n        }\n        else {\n            return function (obj) { return getByKeyPath(obj, keyPath); };\n        }\n    }\n    function getSinglePathKeyExtractor(keyPath) {\n        var split = keyPath.split('.');\n        if (split.length === 1) {\n            return function (obj) { return obj[keyPath]; };\n        }\n        else {\n            return function (obj) { return getByKeyPath(obj, keyPath); };\n        }\n    }\n\n    function arrayify(arrayLike) {\n        return [].slice.call(arrayLike);\n    }\n    var _id_counter = 0;\n    function getKeyPathAlias(keyPath) {\n        return keyPath == null ?\n            \":id\" :\n            typeof keyPath === 'string' ?\n                keyPath :\n                \"[\".concat(keyPath.join('+'), \"]\");\n    }\n    function createDBCore(db, IdbKeyRange, tmpTrans) {\n        function extractSchema(db, trans) {\n            var tables = arrayify(db.objectStoreNames);\n            return {\n                schema: {\n                    name: db.name,\n                    tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {\n                        var keyPath = store.keyPath, autoIncrement = store.autoIncrement;\n                        var compound = isArray(keyPath);\n                        var outbound = keyPath == null;\n                        var indexByKeyPath = {};\n                        var result = {\n                            name: store.name,\n                            primaryKey: {\n                                name: null,\n                                isPrimaryKey: true,\n                                outbound: outbound,\n                                compound: compound,\n                                keyPath: keyPath,\n                                autoIncrement: autoIncrement,\n                                unique: true,\n                                extractKey: getKeyExtractor(keyPath)\n                            },\n                            indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })\n                                .map(function (index) {\n                                var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;\n                                var compound = isArray(keyPath);\n                                var result = {\n                                    name: name,\n                                    compound: compound,\n                                    keyPath: keyPath,\n                                    unique: unique,\n                                    multiEntry: multiEntry,\n                                    extractKey: getKeyExtractor(keyPath)\n                                };\n                                indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                                return result;\n                            }),\n                            getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }\n                        };\n                        indexByKeyPath[\":id\"] = result.primaryKey;\n                        if (keyPath != null) {\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                        }\n                        return result;\n                    })\n                },\n                hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                    !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n            };\n        }\n        function makeIDBKeyRange(range) {\n            if (range.type === 3 )\n                return null;\n            if (range.type === 4 )\n                throw new Error(\"Cannot convert never type to IDBKeyRange\");\n            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;\n            var idbRange = lower === undefined ?\n                upper === undefined ?\n                    null :\n                    IdbKeyRange.upperBound(upper, !!upperOpen) :\n                upper === undefined ?\n                    IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                    IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n            return idbRange;\n        }\n        function createDbCoreTable(tableSchema) {\n            var tableName = tableSchema.name;\n            function mutate(_a) {\n                var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;\n                return new Promise(function (resolve, reject) {\n                    resolve = wrap(resolve);\n                    var store = trans.objectStore(tableName);\n                    var outbound = store.keyPath == null;\n                    var isAddOrPut = type === \"put\" || type === \"add\";\n                    if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                        throw new Error(\"Invalid operation type: \" + type);\n                    var length = (keys || values || { length: 1 }).length;\n                    if (keys && values && keys.length !== values.length) {\n                        throw new Error(\"Given keys array must have same length as given values array.\");\n                    }\n                    if (length === 0)\n                        return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                    var req;\n                    var reqs = [];\n                    var failures = [];\n                    var numFailures = 0;\n                    var errorHandler = function (event) {\n                        ++numFailures;\n                        preventDefault(event);\n                    };\n                    if (type === 'deleteRange') {\n                        if (range.type === 4 )\n                            return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });\n                        if (range.type === 3 )\n                            reqs.push(req = store.clear());\n                        else\n                            reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                    }\n                    else {\n                        var _a = isAddOrPut ?\n                            outbound ?\n                                [values, keys] :\n                                [values, null] :\n                            [keys, null], args1 = _a[0], args2 = _a[1];\n                        if (isAddOrPut) {\n                            for (var i = 0; i < length; ++i) {\n                                reqs.push(req = (args2 && args2[i] !== undefined ?\n                                    store[type](args1[i], args2[i]) :\n                                    store[type](args1[i])));\n                                req.onerror = errorHandler;\n                            }\n                        }\n                        else {\n                            for (var i = 0; i < length; ++i) {\n                                reqs.push(req = store[type](args1[i]));\n                                req.onerror = errorHandler;\n                            }\n                        }\n                    }\n                    var done = function (event) {\n                        var lastResult = event.target.result;\n                        reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });\n                        resolve({\n                            numFailures: numFailures,\n                            failures: failures,\n                            results: type === \"delete\" ? keys : reqs.map(function (req) { return req.result; }),\n                            lastResult: lastResult\n                        });\n                    };\n                    req.onerror = function (event) {\n                        errorHandler(event);\n                        done(event);\n                    };\n                    req.onsuccess = done;\n                });\n            }\n            function openCursor(_a) {\n                var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;\n                return new Promise(function (resolve, reject) {\n                    resolve = wrap(resolve);\n                    var index = query.index, range = query.range;\n                    var store = trans.objectStore(tableName);\n                    var source = index.isPrimaryKey ?\n                        store :\n                        store.index(index.name);\n                    var direction = reverse ?\n                        unique ?\n                            \"prevunique\" :\n                            \"prev\" :\n                        unique ?\n                            \"nextunique\" :\n                            \"next\";\n                    var req = values || !('openKeyCursor' in source) ?\n                        source.openCursor(makeIDBKeyRange(range), direction) :\n                        source.openKeyCursor(makeIDBKeyRange(range), direction);\n                    req.onerror = eventRejectHandler(reject);\n                    req.onsuccess = wrap(function (ev) {\n                        var cursor = req.result;\n                        if (!cursor) {\n                            resolve(null);\n                            return;\n                        }\n                        cursor.___id = ++_id_counter;\n                        cursor.done = false;\n                        var _cursorContinue = cursor.continue.bind(cursor);\n                        var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                        if (_cursorContinuePrimaryKey)\n                            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                        var _cursorAdvance = cursor.advance.bind(cursor);\n                        var doThrowCursorIsNotStarted = function () { throw new Error(\"Cursor not started\"); };\n                        var doThrowCursorIsStopped = function () { throw new Error(\"Cursor not stopped\"); };\n                        cursor.trans = trans;\n                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                        cursor.fail = wrap(reject);\n                        cursor.next = function () {\n                            var _this = this;\n                            var gotOne = 1;\n                            return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });\n                        };\n                        cursor.start = function (callback) {\n                            var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {\n                                resolveIteration = wrap(resolveIteration);\n                                req.onerror = eventRejectHandler(rejectIteration);\n                                cursor.fail = rejectIteration;\n                                cursor.stop = function (value) {\n                                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                    resolveIteration(value);\n                                };\n                            });\n                            var guardedCallback = function () {\n                                if (req.result) {\n                                    try {\n                                        callback();\n                                    }\n                                    catch (err) {\n                                        cursor.fail(err);\n                                    }\n                                }\n                                else {\n                                    cursor.done = true;\n                                    cursor.start = function () { throw new Error(\"Cursor behind last entry\"); };\n                                    cursor.stop();\n                                }\n                            };\n                            req.onsuccess = wrap(function (ev) {\n                                req.onsuccess = guardedCallback;\n                                guardedCallback();\n                            });\n                            cursor.continue = _cursorContinue;\n                            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                            cursor.advance = _cursorAdvance;\n                            guardedCallback();\n                            return iterationPromise;\n                        };\n                        resolve(cursor);\n                    }, reject);\n                });\n            }\n            function query(hasGetAll) {\n                return function (request) {\n                    return new Promise(function (resolve, reject) {\n                        resolve = wrap(resolve);\n                        var trans = request.trans, values = request.values, limit = request.limit, query = request.query;\n                        var nonInfinitLimit = limit === Infinity ? undefined : limit;\n                        var index = query.index, range = query.range;\n                        var store = trans.objectStore(tableName);\n                        var source = index.isPrimaryKey ? store : store.index(index.name);\n                        var idbKeyRange = makeIDBKeyRange(range);\n                        if (limit === 0)\n                            return resolve({ result: [] });\n                        if (hasGetAll) {\n                            var req = values ?\n                                source.getAll(idbKeyRange, nonInfinitLimit) :\n                                source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                            req.onsuccess = function (event) { return resolve({ result: event.target.result }); };\n                            req.onerror = eventRejectHandler(reject);\n                        }\n                        else {\n                            var count_1 = 0;\n                            var req_1 = values || !('openKeyCursor' in source) ?\n                                source.openCursor(idbKeyRange) :\n                                source.openKeyCursor(idbKeyRange);\n                            var result_1 = [];\n                            req_1.onsuccess = function (event) {\n                                var cursor = req_1.result;\n                                if (!cursor)\n                                    return resolve({ result: result_1 });\n                                result_1.push(values ? cursor.value : cursor.primaryKey);\n                                if (++count_1 === limit)\n                                    return resolve({ result: result_1 });\n                                cursor.continue();\n                            };\n                            req_1.onerror = eventRejectHandler(reject);\n                        }\n                    });\n                };\n            }\n            return {\n                name: tableName,\n                schema: tableSchema,\n                mutate: mutate,\n                getMany: function (_a) {\n                    var trans = _a.trans, keys = _a.keys;\n                    return new Promise(function (resolve, reject) {\n                        resolve = wrap(resolve);\n                        var store = trans.objectStore(tableName);\n                        var length = keys.length;\n                        var result = new Array(length);\n                        var keyCount = 0;\n                        var callbackCount = 0;\n                        var req;\n                        var successHandler = function (event) {\n                            var req = event.target;\n                            if ((result[req._pos] = req.result) != null)\n                                ;\n                            if (++callbackCount === keyCount)\n                                resolve(result);\n                        };\n                        var errorHandler = eventRejectHandler(reject);\n                        for (var i = 0; i < length; ++i) {\n                            var key = keys[i];\n                            if (key != null) {\n                                req = store.get(keys[i]);\n                                req._pos = i;\n                                req.onsuccess = successHandler;\n                                req.onerror = errorHandler;\n                                ++keyCount;\n                            }\n                        }\n                        if (keyCount === 0)\n                            resolve(result);\n                    });\n                },\n                get: function (_a) {\n                    var trans = _a.trans, key = _a.key;\n                    return new Promise(function (resolve, reject) {\n                        resolve = wrap(resolve);\n                        var store = trans.objectStore(tableName);\n                        var req = store.get(key);\n                        req.onsuccess = function (event) { return resolve(event.target.result); };\n                        req.onerror = eventRejectHandler(reject);\n                    });\n                },\n                query: query(hasGetAll),\n                openCursor: openCursor,\n                count: function (_a) {\n                    var query = _a.query, trans = _a.trans;\n                    var index = query.index, range = query.range;\n                    return new Promise(function (resolve, reject) {\n                        var store = trans.objectStore(tableName);\n                        var source = index.isPrimaryKey ? store : store.index(index.name);\n                        var idbKeyRange = makeIDBKeyRange(range);\n                        var req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                        req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });\n                        req.onerror = eventRejectHandler(reject);\n                    });\n                }\n            };\n        }\n        var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;\n        var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });\n        var tableMap = {};\n        tables.forEach(function (table) { return tableMap[table.name] = table; });\n        return {\n            stack: \"dbcore\",\n            transaction: db.transaction.bind(db),\n            table: function (name) {\n                var result = tableMap[name];\n                if (!result)\n                    throw new Error(\"Table '\".concat(name, \"' not found\"));\n                return tableMap[name];\n            },\n            MIN_KEY: -Infinity,\n            MAX_KEY: getMaxKey(IdbKeyRange),\n            schema: schema\n        };\n    }\n\n    function createMiddlewareStack(stackImpl, middlewares) {\n        return middlewares.reduce(function (down, _a) {\n            var create = _a.create;\n            return (__assign(__assign({}, down), create(down)));\n        }, stackImpl);\n    }\n    function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {\n        var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;\n        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n        return {\n            dbcore: dbcore\n        };\n    }\n    function generateMiddlewareStacks(db, tmpTrans) {\n        var idbdb = tmpTrans.db;\n        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n        db.core = stacks.dbcore;\n        db.tables.forEach(function (table) {\n            var tableName = table.name;\n            if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {\n                table.core = db.core.table(tableName);\n                if (db[tableName] instanceof db.Table) {\n                    db[tableName].core = table.core;\n                }\n            }\n        });\n    }\n\n    function setApiOnPlace(db, objs, tableNames, dbschema) {\n        tableNames.forEach(function (tableName) {\n            var schema = dbschema[tableName];\n            objs.forEach(function (obj) {\n                var propDesc = getPropertyDescriptor(obj, tableName);\n                if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                    if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                        setProp(obj, tableName, {\n                            get: function () { return this.table(tableName); },\n                            set: function (value) {\n                                defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });\n                            }\n                        });\n                    }\n                    else {\n                        obj[tableName] = new db.Table(tableName, schema);\n                    }\n                }\n            });\n        });\n    }\n    function removeTablesApi(db, objs) {\n        objs.forEach(function (obj) {\n            for (var key in obj) {\n                if (obj[key] instanceof db.Table)\n                    delete obj[key];\n            }\n        });\n    }\n    function lowerVersionFirst(a, b) {\n        return a._cfg.version - b._cfg.version;\n    }\n    function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n        var globalSchema = db._dbSchema;\n        if (idbUpgradeTrans.objectStoreNames.contains('$meta') && !globalSchema.$meta) {\n            globalSchema.$meta = createTableSchema(\"$meta\", parseIndexSyntax(\"\")[0], []);\n            db._storeNames.push('$meta');\n        }\n        var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n        trans.create(idbUpgradeTrans);\n        trans._completion.catch(reject);\n        var rejectTransaction = trans._reject.bind(trans);\n        var transless = PSD.transless || PSD;\n        newScope(function () {\n            PSD.trans = trans;\n            PSD.transless = transless;\n            if (oldVersion === 0) {\n                keys(globalSchema).forEach(function (tableName) {\n                    createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n                });\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);\n            }\n            else {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                return getExistingVersion(db, trans, oldVersion)\n                    .then(function (oldVersion) { return updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans); })\n                    .catch(rejectTransaction);\n            }\n        });\n    }\n    function patchCurrentVersion(db, idbUpgradeTrans) {\n        createMissingTables(db._dbSchema, idbUpgradeTrans);\n        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains('$meta')) {\n            idbUpgradeTrans.db.createObjectStore('$meta').add(Math.ceil((idbUpgradeTrans.db.version / 10) - 1), 'version');\n        }\n        var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n        adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);\n        var diff = getSchemaDiff(globalSchema, db._dbSchema);\n        var _loop_1 = function (tableChange) {\n            if (tableChange.change.length || tableChange.recreate) {\n                console.warn(\"Unable to patch indexes of table \".concat(tableChange.name, \" because it has changes on the type of index or primary key.\"));\n                return { value: void 0 };\n            }\n            var store = idbUpgradeTrans.objectStore(tableChange.name);\n            tableChange.add.forEach(function (idx) {\n                if (debug)\n                    console.debug(\"Dexie upgrade patch: Creating missing index \".concat(tableChange.name, \".\").concat(idx.src));\n                addIndex(store, idx);\n            });\n        };\n        for (var _i = 0, _a = diff.change; _i < _a.length; _i++) {\n            var tableChange = _a[_i];\n            var state_1 = _loop_1(tableChange);\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n        }\n    }\n    function getExistingVersion(db, trans, oldVersion) {\n        if (trans.storeNames.includes('$meta')) {\n            return trans.table('$meta').get('version').then(function (metaVersion) {\n                return metaVersion != null ? metaVersion : oldVersion;\n            });\n        }\n        else {\n            return DexiePromise.resolve(oldVersion);\n        }\n    }\n    function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {\n        var queue = [];\n        var versions = db._versions;\n        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n        var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });\n        if (versToRun.length === 0) {\n            return DexiePromise.resolve();\n        }\n        versToRun.forEach(function (version) {\n            queue.push(function () {\n                var oldSchema = globalSchema;\n                var newSchema = version._cfg.dbschema;\n                adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n                adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n                globalSchema = db._dbSchema = newSchema;\n                var diff = getSchemaDiff(oldSchema, newSchema);\n                diff.add.forEach(function (tuple) {\n                    createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n                });\n                diff.change.forEach(function (change) {\n                    if (change.recreate) {\n                        throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                    }\n                    else {\n                        var store_1 = idbUpgradeTrans.objectStore(change.name);\n                        change.add.forEach(function (idx) { return addIndex(store_1, idx); });\n                        change.change.forEach(function (idx) {\n                            store_1.deleteIndex(idx.name);\n                            addIndex(store_1, idx);\n                        });\n                        change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });\n                    }\n                });\n                var contentUpgrade = version._cfg.contentUpgrade;\n                if (contentUpgrade && version._cfg.version > oldVersion) {\n                    generateMiddlewareStacks(db, idbUpgradeTrans);\n                    trans._memoizedTables = {};\n                    var upgradeSchema_1 = shallowClone(newSchema);\n                    diff.del.forEach(function (table) {\n                        upgradeSchema_1[table] = oldSchema[table];\n                    });\n                    removeTablesApi(db, [db.Transaction.prototype]);\n                    setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);\n                    trans.schema = upgradeSchema_1;\n                    var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);\n                    if (contentUpgradeIsAsync_1) {\n                        incrementExpectedAwaits();\n                    }\n                    var returnValue_1;\n                    var promiseFollowed = DexiePromise.follow(function () {\n                        returnValue_1 = contentUpgrade(trans);\n                        if (returnValue_1) {\n                            if (contentUpgradeIsAsync_1) {\n                                var decrementor = decrementExpectedAwaits.bind(null, null);\n                                returnValue_1.then(decrementor, decrementor);\n                            }\n                        }\n                    });\n                    return (returnValue_1 && typeof returnValue_1.then === 'function' ?\n                        DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));\n                }\n            });\n            queue.push(function (idbtrans) {\n                var newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n                trans.schema = db._dbSchema;\n            });\n            queue.push(function (idbtrans) {\n                if (db.idbdb.objectStoreNames.contains('$meta')) {\n                    if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {\n                        db.idbdb.deleteObjectStore('$meta');\n                        delete db._dbSchema.$meta;\n                        db._storeNames = db._storeNames.filter(function (name) { return name !== '$meta'; });\n                    }\n                    else {\n                        idbtrans.objectStore('$meta').put(version._cfg.version, 'version');\n                    }\n                }\n            });\n        });\n        function runQueue() {\n            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n                DexiePromise.resolve();\n        }\n        return runQueue().then(function () {\n            createMissingTables(globalSchema, idbUpgradeTrans);\n        });\n    }\n    function getSchemaDiff(oldSchema, newSchema) {\n        var diff = {\n            del: [],\n            add: [],\n            change: []\n        };\n        var table;\n        for (table in oldSchema) {\n            if (!newSchema[table])\n                diff.del.push(table);\n        }\n        for (table in newSchema) {\n            var oldDef = oldSchema[table], newDef = newSchema[table];\n            if (!oldDef) {\n                diff.add.push([table, newDef]);\n            }\n            else {\n                var change = {\n                    name: table,\n                    def: newDef,\n                    recreate: false,\n                    del: [],\n                    add: [],\n                    change: []\n                };\n                if ((\n                '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                    (oldDef.primKey.auto !== newDef.primKey.auto)) {\n                    change.recreate = true;\n                    diff.change.push(change);\n                }\n                else {\n                    var oldIndexes = oldDef.idxByName;\n                    var newIndexes = newDef.idxByName;\n                    var idxName = void 0;\n                    for (idxName in oldIndexes) {\n                        if (!newIndexes[idxName])\n                            change.del.push(idxName);\n                    }\n                    for (idxName in newIndexes) {\n                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                        if (!oldIdx)\n                            change.add.push(newIdx);\n                        else if (oldIdx.src !== newIdx.src)\n                            change.change.push(newIdx);\n                    }\n                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                        diff.change.push(change);\n                    }\n                }\n            }\n        }\n        return diff;\n    }\n    function createTable(idbtrans, tableName, primKey, indexes) {\n        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n            { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n            { autoIncrement: primKey.auto });\n        indexes.forEach(function (idx) { return addIndex(store, idx); });\n        return store;\n    }\n    function createMissingTables(newSchema, idbtrans) {\n        keys(newSchema).forEach(function (tableName) {\n            if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n                if (debug)\n                    console.debug('Dexie: Creating missing table', tableName);\n                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n            }\n        });\n    }\n    function deleteRemovedTables(newSchema, idbtrans) {\n        [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {\n            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);\n        });\n    }\n    function addIndex(store, idx) {\n        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n    }\n    function buildGlobalSchema(db, idbdb, tmpTrans) {\n        var globalSchema = {};\n        var dbStoreNames = slice(idbdb.objectStoreNames, 0);\n        dbStoreNames.forEach(function (storeName) {\n            var store = tmpTrans.objectStore(storeName);\n            var keyPath = store.keyPath;\n            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n            var indexes = [];\n            for (var j = 0; j < store.indexNames.length; ++j) {\n                var idbindex = store.index(store.indexNames[j]);\n                keyPath = idbindex.keyPath;\n                var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n                indexes.push(index);\n            }\n            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n        });\n        return globalSchema;\n    }\n    function readGlobalSchema(db, idbdb, tmpTrans) {\n        db.verno = idbdb.version / 10;\n        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n        db._storeNames = slice(idbdb.objectStoreNames, 0);\n        setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n    }\n    function verifyInstalledSchema(db, tmpTrans) {\n        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n        var diff = getSchemaDiff(installedSchema, db._dbSchema);\n        return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));\n    }\n    function adjustToExistingIndexNames(db, schema, idbtrans) {\n        var storeNames = idbtrans.db.objectStoreNames;\n        for (var i = 0; i < storeNames.length; ++i) {\n            var storeName = storeNames[i];\n            var store = idbtrans.objectStore(storeName);\n            db._hasGetAll = 'getAll' in store;\n            for (var j = 0; j < store.indexNames.length; ++j) {\n                var indexName = store.indexNames[j];\n                var keyPath = store.index(indexName).keyPath;\n                var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n                if (schema[storeName]) {\n                    var indexSpec = schema[storeName].idxByName[dexieName];\n                    if (indexSpec) {\n                        indexSpec.name = indexName;\n                        delete schema[storeName].idxByName[dexieName];\n                        schema[storeName].idxByName[indexName] = indexSpec;\n                    }\n                }\n            }\n        }\n        if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n            !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n            [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n            db._hasGetAll = false;\n        }\n    }\n    function parseIndexSyntax(primKeyAndIndexes) {\n        return primKeyAndIndexes.split(',').map(function (index, indexNum) {\n            index = index.trim();\n            var name = index.replace(/([&*]|\\+\\+)/g, \"\");\n            var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n            return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n        });\n    }\n\n    var Version =  (function () {\n        function Version() {\n        }\n        Version.prototype._parseStoresSpec = function (stores, outSchema) {\n            keys(stores).forEach(function (tableName) {\n                if (stores[tableName] !== null) {\n                    var indexes = parseIndexSyntax(stores[tableName]);\n                    var primKey = indexes.shift();\n                    primKey.unique = true;\n                    if (primKey.multi)\n                        throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                    indexes.forEach(function (idx) {\n                        if (idx.auto)\n                            throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                        if (!idx.keyPath)\n                            throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                    });\n                    outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n                }\n            });\n        };\n        Version.prototype.stores = function (stores) {\n            var db = this.db;\n            this._cfg.storesSource = this._cfg.storesSource ?\n                extend(this._cfg.storesSource, stores) :\n                stores;\n            var versions = db._versions;\n            var storesSpec = {};\n            var dbschema = {};\n            versions.forEach(function (version) {\n                extend(storesSpec, version._cfg.storesSource);\n                dbschema = (version._cfg.dbschema = {});\n                version._parseStoresSpec(storesSpec, dbschema);\n            });\n            db._dbSchema = dbschema;\n            removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n            setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n            db._storeNames = keys(dbschema);\n            return this;\n        };\n        Version.prototype.upgrade = function (upgradeFunction) {\n            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n            return this;\n        };\n        return Version;\n    }());\n\n    function createVersionConstructor(db) {\n        return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n            this.db = db;\n            this._cfg = {\n                version: versionNumber,\n                storesSource: null,\n                dbschema: {},\n                tables: {},\n                contentUpgrade: null\n            };\n        });\n    }\n\n    function getDbNamesTable(indexedDB, IDBKeyRange) {\n        var dbNamesDB = indexedDB[\"_dbNamesDB\"];\n        if (!dbNamesDB) {\n            dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n                addons: [],\n                indexedDB: indexedDB,\n                IDBKeyRange: IDBKeyRange,\n            });\n            dbNamesDB.version(1).stores({ dbnames: \"name\" });\n        }\n        return dbNamesDB.table(\"dbnames\");\n    }\n    function hasDatabasesNative(indexedDB) {\n        return indexedDB && typeof indexedDB.databases === \"function\";\n    }\n    function getDatabaseNames(_a) {\n        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n        return hasDatabasesNative(indexedDB)\n            ? Promise.resolve(indexedDB.databases()).then(function (infos) {\n                return infos\n                    .map(function (info) { return info.name; })\n                    .filter(function (name) { return name !== DBNAMES_DB; });\n            })\n            : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n    }\n    function _onDatabaseCreated(_a, name) {\n        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n        !hasDatabasesNative(indexedDB) &&\n            name !== DBNAMES_DB &&\n            getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);\n    }\n    function _onDatabaseDeleted(_a, name) {\n        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n        !hasDatabasesNative(indexedDB) &&\n            name !== DBNAMES_DB &&\n            getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n    }\n\n    function vip(fn) {\n        return newScope(function () {\n            PSD.letThrough = true;\n            return fn();\n        });\n    }\n\n    function idbReady() {\n        var isSafari = !navigator.userAgentData &&\n            /Safari\\//.test(navigator.userAgent) &&\n            !/Chrom(e|ium)\\//.test(navigator.userAgent);\n        if (!isSafari || !indexedDB.databases)\n            return Promise.resolve();\n        var intervalId;\n        return new Promise(function (resolve) {\n            var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n            intervalId = setInterval(tryIdb, 100);\n            tryIdb();\n        }).finally(function () { return clearInterval(intervalId); });\n    }\n\n    var _a;\n    function isEmptyRange(node) {\n        return !(\"from\" in node);\n    }\n    var RangeSet = function (fromOrTree, to) {\n        if (this) {\n            extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n        }\n        else {\n            var rv = new RangeSet();\n            if (fromOrTree && (\"d\" in fromOrTree)) {\n                extend(rv, fromOrTree);\n            }\n            return rv;\n        }\n    };\n    props(RangeSet.prototype, (_a = {\n            add: function (rangeSet) {\n                mergeRanges(this, rangeSet);\n                return this;\n            },\n            addKey: function (key) {\n                addRange(this, key, key);\n                return this;\n            },\n            addKeys: function (keys) {\n                var _this = this;\n                keys.forEach(function (key) { return addRange(_this, key, key); });\n                return this;\n            },\n            hasKey: function (key) {\n                var node = getRangeSetIterator(this).next(key).value;\n                return node && cmp(node.from, key) <= 0 && cmp(node.to, key) >= 0;\n            }\n        },\n        _a[iteratorSymbol] = function () {\n            return getRangeSetIterator(this);\n        },\n        _a));\n    function addRange(target, from, to) {\n        var diff = cmp(from, to);\n        if (isNaN(diff))\n            return;\n        if (diff > 0)\n            throw RangeError();\n        if (isEmptyRange(target))\n            return extend(target, { from: from, to: to, d: 1 });\n        var left = target.l;\n        var right = target.r;\n        if (cmp(to, target.from) < 0) {\n            left\n                ? addRange(left, from, to)\n                : (target.l = { from: from, to: to, d: 1, l: null, r: null });\n            return rebalance(target);\n        }\n        if (cmp(from, target.to) > 0) {\n            right\n                ? addRange(right, from, to)\n                : (target.r = { from: from, to: to, d: 1, l: null, r: null });\n            return rebalance(target);\n        }\n        if (cmp(from, target.from) < 0) {\n            target.from = from;\n            target.l = null;\n            target.d = right ? right.d + 1 : 1;\n        }\n        if (cmp(to, target.to) > 0) {\n            target.to = to;\n            target.r = null;\n            target.d = target.l ? target.l.d + 1 : 1;\n        }\n        var rightWasCutOff = !target.r;\n        if (left && !target.l) {\n            mergeRanges(target, left);\n        }\n        if (right && rightWasCutOff) {\n            mergeRanges(target, right);\n        }\n    }\n    function mergeRanges(target, newSet) {\n        function _addRangeSet(target, _a) {\n            var from = _a.from, to = _a.to, l = _a.l, r = _a.r;\n            addRange(target, from, to);\n            if (l)\n                _addRangeSet(target, l);\n            if (r)\n                _addRangeSet(target, r);\n        }\n        if (!isEmptyRange(newSet))\n            _addRangeSet(target, newSet);\n    }\n    function rangesOverlap(rangeSet1, rangeSet2) {\n        var i1 = getRangeSetIterator(rangeSet2);\n        var nextResult1 = i1.next();\n        if (nextResult1.done)\n            return false;\n        var a = nextResult1.value;\n        var i2 = getRangeSetIterator(rangeSet1);\n        var nextResult2 = i2.next(a.from);\n        var b = nextResult2.value;\n        while (!nextResult1.done && !nextResult2.done) {\n            if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n                return true;\n            cmp(a.from, b.from) < 0\n                ? (a = (nextResult1 = i1.next(b.from)).value)\n                : (b = (nextResult2 = i2.next(a.from)).value);\n        }\n        return false;\n    }\n    function getRangeSetIterator(node) {\n        var state = isEmptyRange(node) ? null : { s: 0, n: node };\n        return {\n            next: function (key) {\n                var keyProvided = arguments.length > 0;\n                while (state) {\n                    switch (state.s) {\n                        case 0:\n                            state.s = 1;\n                            if (keyProvided) {\n                                while (state.n.l && cmp(key, state.n.from) < 0)\n                                    state = { up: state, n: state.n.l, s: 1 };\n                            }\n                            else {\n                                while (state.n.l)\n                                    state = { up: state, n: state.n.l, s: 1 };\n                            }\n                        case 1:\n                            state.s = 2;\n                            if (!keyProvided || cmp(key, state.n.to) <= 0)\n                                return { value: state.n, done: false };\n                        case 2:\n                            if (state.n.r) {\n                                state.s = 3;\n                                state = { up: state, n: state.n.r, s: 0 };\n                                continue;\n                            }\n                        case 3:\n                            state = state.up;\n                    }\n                }\n                return { done: true };\n            },\n        };\n    }\n    function rebalance(target) {\n        var _a, _b;\n        var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n        var r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n        if (r) {\n            var l = r === \"r\" ? \"l\" : \"r\";\n            var rootClone = __assign({}, target);\n            var oldRootRight = target[r];\n            target.from = oldRootRight.from;\n            target.to = oldRootRight.to;\n            target[r] = oldRootRight[r];\n            rootClone[r] = oldRootRight[l];\n            target[l] = rootClone;\n            rootClone.d = computeDepth(rootClone);\n        }\n        target.d = computeDepth(target);\n    }\n    function computeDepth(_a) {\n        var r = _a.r, l = _a.l;\n        return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n    }\n\n    function extendObservabilitySet(target, newSet) {\n        keys(newSet).forEach(function (part) {\n            if (target[part])\n                mergeRanges(target[part], newSet[part]);\n            else\n                target[part] = cloneSimpleObjectTree(newSet[part]);\n        });\n        return target;\n    }\n\n    function obsSetsOverlap(os1, os2) {\n        return os1.all || os2.all || Object.keys(os1).some(function (key) { return os2[key] && rangesOverlap(os2[key], os1[key]); });\n    }\n\n    var cache = {};\n\n    var unsignaledParts = {};\n    var isTaskEnqueued = false;\n    function signalSubscribersLazily(part, optimistic) {\n        extendObservabilitySet(unsignaledParts, part);\n        if (!isTaskEnqueued) {\n            isTaskEnqueued = true;\n            setTimeout(function () {\n                isTaskEnqueued = false;\n                var parts = unsignaledParts;\n                unsignaledParts = {};\n                signalSubscribersNow(parts, false);\n            }, 0);\n        }\n    }\n    function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {\n        if (deleteAffectedCacheEntries === void 0) { deleteAffectedCacheEntries = false; }\n        var queriesToSignal = new Set();\n        if (updatedParts.all) {\n            for (var _i = 0, _a = Object.values(cache); _i < _a.length; _i++) {\n                var tblCache = _a[_i];\n                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n            }\n        }\n        else {\n            for (var key in updatedParts) {\n                var parts = /^idb\\:\\/\\/(.*)\\/(.*)\\//.exec(key);\n                if (parts) {\n                    var dbName = parts[1], tableName = parts[2];\n                    var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n                    if (tblCache)\n                        collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n                }\n            }\n        }\n        queriesToSignal.forEach(function (requery) { return requery(); });\n    }\n    function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {\n        var updatedEntryLists = [];\n        for (var _i = 0, _a = Object.entries(tblCache.queries.query); _i < _a.length; _i++) {\n            var _b = _a[_i], indexName = _b[0], entries = _b[1];\n            var filteredEntries = [];\n            for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {\n                var entry = entries_1[_c];\n                if (obsSetsOverlap(updatedParts, entry.obsSet)) {\n                    entry.subscribers.forEach(function (requery) { return outQueriesToSignal.add(requery); });\n                }\n                else if (deleteAffectedCacheEntries) {\n                    filteredEntries.push(entry);\n                }\n            }\n            if (deleteAffectedCacheEntries)\n                updatedEntryLists.push([indexName, filteredEntries]);\n        }\n        if (deleteAffectedCacheEntries) {\n            for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {\n                var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];\n                tblCache.queries.query[indexName] = filteredEntries;\n            }\n        }\n    }\n\n    function dexieOpen(db) {\n        var state = db._state;\n        var indexedDB = db._deps.indexedDB;\n        if (state.isBeingOpened || db.idbdb)\n            return state.dbReadyPromise.then(function () { return state.dbOpenError ?\n                rejection(state.dbOpenError) :\n                db; });\n        state.isBeingOpened = true;\n        state.dbOpenError = null;\n        state.openComplete = false;\n        var openCanceller = state.openCanceller;\n        var nativeVerToOpen = Math.round(db.verno * 10);\n        var schemaPatchMode = false;\n        function throwIfCancelled() {\n            if (state.openCanceller !== openCanceller)\n                throw new exceptions.DatabaseClosed('db.open() was cancelled');\n        }\n        var resolveDbReady = state.dbReadyResolve,\n        upgradeTransaction = null, wasCreated = false;\n        var tryOpenDB = function () { return new DexiePromise(function (resolve, reject) {\n            throwIfCancelled();\n            if (!indexedDB)\n                throw new exceptions.MissingAPI();\n            var dbName = db.name;\n            var req = state.autoSchema || !nativeVerToOpen ?\n                indexedDB.open(dbName) :\n                indexedDB.open(dbName, nativeVerToOpen);\n            if (!req)\n                throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap(function (e) {\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    var delreq = indexedDB.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(function () {\n                        reject(new exceptions.NoSuchDatabase(\"Database \".concat(dbName, \" doesnt exist\")));\n                    });\n                }\n                else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db.idbdb = req.result;\n                    if (schemaPatchMode) {\n                        patchCurrentVersion(db, upgradeTransaction);\n                    }\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(function () {\n                upgradeTransaction = null;\n                var idbdb = db.idbdb = req.result;\n                var objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0)\n                    try {\n                        var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                        if (state.autoSchema)\n                            readGlobalSchema(db, idbdb, tmpTrans);\n                        else {\n                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                            if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {\n                                console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.\");\n                                idbdb.close();\n                                nativeVerToOpen = idbdb.version + 1;\n                                schemaPatchMode = true;\n                                return resolve(tryOpenDB());\n                            }\n                        }\n                        generateMiddlewareStacks(db, tmpTrans);\n                    }\n                    catch (e) {\n                    }\n                connections.push(db);\n                idbdb.onversionchange = wrap(function (ev) {\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap(function (ev) {\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated)\n                    _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }).catch(function (err) {\n            switch (err === null || err === void 0 ? void 0 : err.name) {\n                case \"UnknownError\":\n                    if (state.PR1398_maxLoop > 0) {\n                        state.PR1398_maxLoop--;\n                        console.warn('Dexie: Workaround for Chrome UnknownError on open()');\n                        return tryOpenDB();\n                    }\n                    break;\n                case \"VersionError\":\n                    if (nativeVerToOpen > 0) {\n                        nativeVerToOpen = 0;\n                        return tryOpenDB();\n                    }\n                    break;\n            }\n            return DexiePromise.reject(err);\n        }); };\n        return DexiePromise.race([\n            openCanceller,\n            (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n        ]).then(function () {\n            throwIfCancelled();\n            state.onReadyBeingFired = [];\n            return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {\n                if (state.onReadyBeingFired.length > 0) {\n                    var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);\n                    state.onReadyBeingFired = [];\n                    return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);\n                }\n            });\n        }).finally(function () {\n            if (state.openCanceller === openCanceller) {\n                state.onReadyBeingFired = null;\n                state.isBeingOpened = false;\n            }\n        }).catch(function (err) {\n            state.dbOpenError = err;\n            try {\n                upgradeTransaction && upgradeTransaction.abort();\n            }\n            catch (_a) { }\n            if (openCanceller === state.openCanceller) {\n                db._close();\n            }\n            return rejection(err);\n        }).finally(function () {\n            state.openComplete = true;\n            resolveDbReady();\n        }).then(function () {\n            if (wasCreated) {\n                var everything_1 = {};\n                db.tables.forEach(function (table) {\n                    table.schema.indexes.forEach(function (idx) {\n                        if (idx.name)\n                            everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\").concat(idx.name)] = new RangeSet(-Infinity, [[[]]]);\n                    });\n                    everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\")] = everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/:dels\")] = new RangeSet(-Infinity, [[[]]]);\n                });\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);\n                signalSubscribersNow(everything_1, true);\n            }\n            return db;\n        });\n    }\n\n    function awaitIterator(iterator) {\n        var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);\n        function step(getNext) {\n            return function (val) {\n                var next = getNext(val), value = next.value;\n                return next.done ? value :\n                    (!value || typeof value.then !== 'function' ?\n                        isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                        value.then(onSuccess, onError));\n            };\n        }\n        return step(callNext)();\n    }\n\n    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n        var i = arguments.length;\n        if (i < 2)\n            throw new exceptions.InvalidArgument(\"Too few arguments\");\n        var args = new Array(i - 1);\n        while (--i)\n            args[i - 1] = arguments[i];\n        scopeFunc = args.pop();\n        var tables = flatten(args);\n        return [mode, tables, scopeFunc];\n    }\n    function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n        return DexiePromise.resolve().then(function () {\n            var transless = PSD.transless || PSD;\n            var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n            trans.explicit = true;\n            var zoneProps = {\n                trans: trans,\n                transless: transless\n            };\n            if (parentTransaction) {\n                trans.idbtrans = parentTransaction.idbtrans;\n            }\n            else {\n                try {\n                    trans.create();\n                    trans.idbtrans._explicit = true;\n                    db._state.PR1398_maxLoop = 3;\n                }\n                catch (ex) {\n                    if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                        console.warn('Dexie: Need to reopen db');\n                        db.close({ disableAutoOpen: false });\n                        return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });\n                    }\n                    return rejection(ex);\n                }\n            }\n            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            var returnValue;\n            var promiseFollowed = DexiePromise.follow(function () {\n                returnValue = scopeFunc.call(trans, trans);\n                if (returnValue) {\n                    if (scopeFuncIsAsync) {\n                        var decrementor = decrementExpectedAwaits.bind(null, null);\n                        returnValue.then(decrementor, decrementor);\n                    }\n                    else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                        returnValue = awaitIterator(returnValue);\n                    }\n                }\n            }, zoneProps);\n            return (returnValue && typeof returnValue.then === 'function' ?\n                DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?\n                    x\n                    : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")); })\n                : promiseFollowed.then(function () { return returnValue; })).then(function (x) {\n                if (parentTransaction)\n                    trans._resolve();\n                return trans._completion.then(function () { return x; });\n            }).catch(function (e) {\n                trans._reject(e);\n                return rejection(e);\n            });\n        });\n    }\n\n    function pad(a, value, count) {\n        var result = isArray(a) ? a.slice() : [a];\n        for (var i = 0; i < count; ++i)\n            result.push(value);\n        return result;\n    }\n    function createVirtualIndexMiddleware(down) {\n        return __assign(__assign({}, down), { table: function (tableName) {\n                var table = down.table(tableName);\n                var schema = table.schema;\n                var indexLookup = {};\n                var allVirtualIndexes = [];\n                function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                    var keyPathAlias = getKeyPathAlias(keyPath);\n                    var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                    var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                    var isVirtual = keyTail > 0;\n                    var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual\n                            ? \"\".concat(keyPathAlias, \"(virtual-from:\").concat(lowLevelIndex.name, \")\")\n                            : lowLevelIndex.name, lowLevelIndex: lowLevelIndex, isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });\n                    indexList.push(virtualIndex);\n                    if (!virtualIndex.isPrimaryKey) {\n                        allVirtualIndexes.push(virtualIndex);\n                    }\n                    if (keyLength > 1) {\n                        var virtualKeyPath = keyLength === 2 ?\n                            keyPath[0] :\n                            keyPath.slice(0, keyLength - 1);\n                        addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                    }\n                    indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });\n                    return virtualIndex;\n                }\n                var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n                indexLookup[\":id\"] = [primaryKey];\n                for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {\n                    var index = _a[_i];\n                    addVirtualIndexes(index.keyPath, 0, index);\n                }\n                function findBestIndex(keyPath) {\n                    var result = indexLookup[getKeyPathAlias(keyPath)];\n                    return result && result[0];\n                }\n                function translateRange(range, keyTail) {\n                    return {\n                        type: range.type === 1  ?\n                            2  :\n                            range.type,\n                        lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                        lowerOpen: true,\n                        upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                        upperOpen: true\n                    };\n                }\n                function translateRequest(req) {\n                    var index = req.query.index;\n                    return index.isVirtual ? __assign(__assign({}, req), { query: {\n                            index: index.lowLevelIndex,\n                            range: translateRange(req.query.range, index.keyTail)\n                        } }) : req;\n                }\n                var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {\n                        return table.count(translateRequest(req));\n                    }, query: function (req) {\n                        return table.query(translateRequest(req));\n                    }, openCursor: function (req) {\n                        var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;\n                        if (!isVirtual)\n                            return table.openCursor(req);\n                        function createVirtualCursor(cursor) {\n                            function _continue(key) {\n                                key != null ?\n                                    cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                    req.unique ?\n                                        cursor.continue(cursor.key.slice(0, keyLength)\n                                            .concat(req.reverse\n                                            ? down.MIN_KEY\n                                            : down.MAX_KEY, keyTail)) :\n                                        cursor.continue();\n                            }\n                            var virtualCursor = Object.create(cursor, {\n                                continue: { value: _continue },\n                                continuePrimaryKey: {\n                                    value: function (key, primaryKey) {\n                                        cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                    }\n                                },\n                                primaryKey: {\n                                    get: function () {\n                                        return cursor.primaryKey;\n                                    }\n                                },\n                                key: {\n                                    get: function () {\n                                        var key = cursor.key;\n                                        return keyLength === 1 ?\n                                            key[0] :\n                                            key.slice(0, keyLength);\n                                    }\n                                },\n                                value: {\n                                    get: function () {\n                                        return cursor.value;\n                                    }\n                                }\n                            });\n                            return virtualCursor;\n                        }\n                        return table.openCursor(translateRequest(req))\n                            .then(function (cursor) { return cursor && createVirtualCursor(cursor); });\n                    } });\n                return result;\n            } });\n    }\n    var virtualIndexMiddleware = {\n        stack: \"dbcore\",\n        name: \"VirtualIndexMiddleware\",\n        level: 1,\n        create: createVirtualIndexMiddleware\n    };\n\n    function getObjectDiff(a, b, rv, prfx) {\n        rv = rv || {};\n        prfx = prfx || '';\n        keys(a).forEach(function (prop) {\n            if (!hasOwn(b, prop)) {\n                rv[prfx + prop] = undefined;\n            }\n            else {\n                var ap = a[prop], bp = b[prop];\n                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                    var apTypeName = toStringTag(ap);\n                    var bpTypeName = toStringTag(bp);\n                    if (apTypeName !== bpTypeName) {\n                        rv[prfx + prop] = b[prop];\n                    }\n                    else if (apTypeName === 'Object') {\n                        getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                    }\n                    else if (ap !== bp) {\n                        rv[prfx + prop] = b[prop];\n                    }\n                }\n                else if (ap !== bp)\n                    rv[prfx + prop] = b[prop];\n            }\n        });\n        keys(b).forEach(function (prop) {\n            if (!hasOwn(a, prop)) {\n                rv[prfx + prop] = b[prop];\n            }\n        });\n        return rv;\n    }\n\n    function getEffectiveKeys(primaryKey, req) {\n        if (req.type === 'delete')\n            return req.keys;\n        return req.keys || req.values.map(primaryKey.extractKey);\n    }\n\n    var hooksMiddleware = {\n        stack: \"dbcore\",\n        name: \"HooksMiddleware\",\n        level: 2,\n        create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {\n                var downTable = downCore.table(tableName);\n                var primaryKey = downTable.schema.primaryKey;\n                var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {\n                        var dxTrans = PSD.trans;\n                        var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;\n                        switch (req.type) {\n                            case 'add':\n                                if (creating.fire === nop)\n                                    break;\n                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                            case 'put':\n                                if (creating.fire === nop && updating.fire === nop)\n                                    break;\n                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                            case 'delete':\n                                if (deleting.fire === nop)\n                                    break;\n                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                            case 'deleteRange':\n                                if (deleting.fire === nop)\n                                    break;\n                                return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);\n                        }\n                        return downTable.mutate(req);\n                        function addPutOrDelete(req) {\n                            var dxTrans = PSD.trans;\n                            var keys = req.keys || getEffectiveKeys(primaryKey, req);\n                            if (!keys)\n                                throw new Error(\"Keys missing\");\n                            req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);\n                            if (req.type !== 'delete')\n                                req.values = __spreadArray([], req.values, true);\n                            if (req.keys)\n                                req.keys = __spreadArray([], req.keys, true);\n                            return getExistingValues(downTable, req, keys).then(function (existingValues) {\n                                var contexts = keys.map(function (key, i) {\n                                    var existingValue = existingValues[i];\n                                    var ctx = { onerror: null, onsuccess: null };\n                                    if (req.type === 'delete') {\n                                        deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                    }\n                                    else if (req.type === 'add' || existingValue === undefined) {\n                                        var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                        if (key == null && generatedPrimaryKey != null) {\n                                            key = generatedPrimaryKey;\n                                            req.keys[i] = key;\n                                            if (!primaryKey.outbound) {\n                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        var objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                        if (additionalChanges_1) {\n                                            var requestedValue_1 = req.values[i];\n                                            Object.keys(additionalChanges_1).forEach(function (keyPath) {\n                                                if (hasOwn(requestedValue_1, keyPath)) {\n                                                    requestedValue_1[keyPath] = additionalChanges_1[keyPath];\n                                                }\n                                                else {\n                                                    setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);\n                                                }\n                                            });\n                                        }\n                                    }\n                                    return ctx;\n                                });\n                                return downTable.mutate(req).then(function (_a) {\n                                    var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;\n                                    for (var i = 0; i < keys.length; ++i) {\n                                        var primKey = results ? results[i] : keys[i];\n                                        var ctx = contexts[i];\n                                        if (primKey == null) {\n                                            ctx.onerror && ctx.onerror(failures[i]);\n                                        }\n                                        else {\n                                            ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                                req.values[i] :\n                                                primKey\n                                            );\n                                        }\n                                    }\n                                    return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };\n                                }).catch(function (error) {\n                                    contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });\n                                    return Promise.reject(error);\n                                });\n                            });\n                        }\n                        function deleteRange(req) {\n                            return deleteNextChunk(req.trans, req.range, 10000);\n                        }\n                        function deleteNextChunk(trans, range, limit) {\n                            return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })\n                                .then(function (_a) {\n                                var result = _a.result;\n                                return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {\n                                    if (res.numFailures > 0)\n                                        return Promise.reject(res.failures[0]);\n                                    if (result.length < limit) {\n                                        return { failures: [], numFailures: 0, lastResult: undefined };\n                                    }\n                                    else {\n                                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);\n                                    }\n                                });\n                            });\n                        }\n                    } });\n                return tableMiddleware;\n            } })); }\n    };\n    function getExistingValues(table, req, effectiveKeys) {\n        return req.type === \"add\"\n            ? Promise.resolve([])\n            : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n    }\n\n    function getFromTransactionCache(keys, cache, clone) {\n        try {\n            if (!cache)\n                return null;\n            if (cache.keys.length < keys.length)\n                return null;\n            var result = [];\n            for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n                if (cmp(cache.keys[i], keys[j]) !== 0)\n                    continue;\n                result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n                ++j;\n            }\n            return result.length === keys.length ? result : null;\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n    var cacheExistingValuesMiddleware = {\n        stack: \"dbcore\",\n        level: -1,\n        create: function (core) {\n            return {\n                table: function (tableName) {\n                    var table = core.table(tableName);\n                    return __assign(__assign({}, table), { getMany: function (req) {\n                            if (!req.cache) {\n                                return table.getMany(req);\n                            }\n                            var cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                            if (cachedResult) {\n                                return DexiePromise.resolve(cachedResult);\n                            }\n                            return table.getMany(req).then(function (res) {\n                                req.trans[\"_cache\"] = {\n                                    keys: req.keys,\n                                    values: req.cache === \"clone\" ? deepClone(res) : res,\n                                };\n                                return res;\n                            });\n                        }, mutate: function (req) {\n                            if (req.type !== \"add\")\n                                req.trans[\"_cache\"] = null;\n                            return table.mutate(req);\n                        } });\n                },\n            };\n        },\n    };\n\n    function isCachableContext(ctx, table) {\n        return (ctx.trans.mode === 'readonly' &&\n            !!ctx.subscr &&\n            !ctx.trans.explicit &&\n            ctx.trans.db._options.cache !== 'disabled' &&\n            !table.schema.primaryKey.outbound);\n    }\n\n    function isCachableRequest(type, req) {\n        switch (type) {\n            case 'query':\n                return req.values && !req.unique;\n            case 'get':\n                return false;\n            case 'getMany':\n                return false;\n            case 'count':\n                return false;\n            case 'openCursor':\n                return false;\n        }\n    }\n\n    var observabilityMiddleware = {\n        stack: \"dbcore\",\n        level: 0,\n        name: \"Observability\",\n        create: function (core) {\n            var dbName = core.schema.name;\n            var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n            return __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n                    if (PSD.subscr && mode !== 'readonly') {\n                        throw new exceptions.ReadOnly(\"Readwrite transaction in liveQuery context. Querier source: \".concat(PSD.querier));\n                    }\n                    return core.transaction(stores, mode, options);\n                }, table: function (tableName) {\n                    var table = core.table(tableName);\n                    var schema = table.schema;\n                    var primaryKey = schema.primaryKey, indexes = schema.indexes;\n                    var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;\n                    var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function (index) { return index.compound && index.keyPath.includes(primaryKey.keyPath); });\n                    var tableClone = __assign(__assign({}, table), { mutate: function (req) {\n                            var _a, _b;\n                            var trans = req.trans;\n                            var mutatedParts = req.mutatedParts || (req.mutatedParts = {});\n                            var getRangeSet = function (indexName) {\n                                var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                                return (mutatedParts[part] ||\n                                    (mutatedParts[part] = new RangeSet()));\n                            };\n                            var pkRangeSet = getRangeSet(\"\");\n                            var delsRangeSet = getRangeSet(\":dels\");\n                            var type = req.type;\n                            var _c = req.type === \"deleteRange\"\n                                ? [req.range]\n                                : req.type === \"delete\"\n                                    ? [req.keys]\n                                    : req.values.length < 50\n                                        ? [getEffectiveKeys(primaryKey, req).filter(function (id) { return id; }), req.values]\n                                        : [], keys = _c[0], newObjs = _c[1];\n                            var oldCache = req.trans[\"_cache\"];\n                            if (isArray(keys)) {\n                                pkRangeSet.addKeys(keys);\n                                var oldObjs = type === 'delete' || keys.length === newObjs.length ? getFromTransactionCache(keys, oldCache) : null;\n                                if (!oldObjs) {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                var range = {\n                                    from: (_a = keys.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY,\n                                    to: (_b = keys.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY\n                                };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });\n                            }\n                            return table.mutate(req).then(function (res) {\n                                if (keys && (req.type === 'add' || req.type === 'put')) {\n                                    pkRangeSet.addKeys(res.results);\n                                    if (indexesWithAutoIncPK) {\n                                        indexesWithAutoIncPK.forEach(function (idx) {\n                                            var idxVals = req.values.map(function (v) { return idx.extractKey(v); });\n                                            var pkPos = idx.keyPath.findIndex(function (prop) { return prop === primaryKey.keyPath; });\n                                            for (var i = 0, len = res.results.length; i < len; ++i) {\n                                                idxVals[i][pkPos] = res.results[i];\n                                            }\n                                            getRangeSet(idx.name).addKeys(idxVals);\n                                        });\n                                    }\n                                }\n                                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);\n                                return res;\n                            });\n                        } });\n                    var getRange = function (_a) {\n                        var _b, _c;\n                        var _d = _a.query, index = _d.index, range = _d.range;\n                        return [\n                            index,\n                            new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),\n                        ];\n                    };\n                    var readSubscribers = {\n                        get: function (req) { return [primaryKey, new RangeSet(req.key)]; },\n                        getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },\n                        count: getRange,\n                        query: getRange,\n                        openCursor: getRange,\n                    };\n                    keys(readSubscribers).forEach(function (method) {\n                        tableClone[method] = function (req) {\n                            var subscr = PSD.subscr;\n                            var isLiveQuery = !!subscr;\n                            var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);\n                            var obsSet = cachable\n                                ? req.obsSet = {}\n                                : subscr;\n                            if (isLiveQuery) {\n                                var getRangeSet = function (indexName) {\n                                    var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                                    return (obsSet[part] ||\n                                        (obsSet[part] = new RangeSet()));\n                                };\n                                var pkRangeSet_1 = getRangeSet(\"\");\n                                var delsRangeSet_1 = getRangeSet(\":dels\");\n                                var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];\n                                if (method === 'query' && queriedIndex.isPrimaryKey && !req.values) {\n                                    delsRangeSet_1.add(queriedRanges);\n                                }\n                                else {\n                                    getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                                }\n                                if (!queriedIndex.isPrimaryKey) {\n                                    if (method === \"count\") {\n                                        delsRangeSet_1.add(FULL_RANGE);\n                                    }\n                                    else {\n                                        var keysPromise_1 = method === \"query\" &&\n                                            outbound &&\n                                            req.values &&\n                                            table.query(__assign(__assign({}, req), { values: false }));\n                                        return table[method].apply(this, arguments).then(function (res) {\n                                            if (method === \"query\") {\n                                                if (outbound && req.values) {\n                                                    return keysPromise_1.then(function (_a) {\n                                                        var resultingKeys = _a.result;\n                                                        pkRangeSet_1.addKeys(resultingKeys);\n                                                        return res;\n                                                    });\n                                                }\n                                                var pKeys = req.values\n                                                    ? res.result.map(extractKey)\n                                                    : res.result;\n                                                if (req.values) {\n                                                    pkRangeSet_1.addKeys(pKeys);\n                                                }\n                                                else {\n                                                    delsRangeSet_1.addKeys(pKeys);\n                                                }\n                                            }\n                                            else if (method === \"openCursor\") {\n                                                var cursor_1 = res;\n                                                var wantValues_1 = req.values;\n                                                return (cursor_1 &&\n                                                    Object.create(cursor_1, {\n                                                        key: {\n                                                            get: function () {\n                                                                delsRangeSet_1.addKey(cursor_1.primaryKey);\n                                                                return cursor_1.key;\n                                                            },\n                                                        },\n                                                        primaryKey: {\n                                                            get: function () {\n                                                                var pkey = cursor_1.primaryKey;\n                                                                delsRangeSet_1.addKey(pkey);\n                                                                return pkey;\n                                                            },\n                                                        },\n                                                        value: {\n                                                            get: function () {\n                                                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);\n                                                                return cursor_1.value;\n                                                            },\n                                                        },\n                                                    }));\n                                            }\n                                            return res;\n                                        });\n                                    }\n                                }\n                            }\n                            return table[method].apply(this, arguments);\n                        };\n                    });\n                    return tableClone;\n                } });\n        },\n    };\n    function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n        function addAffectedIndex(ix) {\n            var rangeSet = getRangeSet(ix.name || \"\");\n            function extractKey(obj) {\n                return obj != null ? ix.extractKey(obj) : null;\n            }\n            var addKeyOrKeys = function (key) { return ix.multiEntry && isArray(key)\n                ? key.forEach(function (key) { return rangeSet.addKey(key); })\n                : rangeSet.addKey(key); };\n            (oldObjs || newObjs).forEach(function (_, i) {\n                var oldKey = oldObjs && extractKey(oldObjs[i]);\n                var newKey = newObjs && extractKey(newObjs[i]);\n                if (cmp(oldKey, newKey) !== 0) {\n                    if (oldKey != null)\n                        addKeyOrKeys(oldKey);\n                    if (newKey != null)\n                        addKeyOrKeys(newKey);\n                }\n            });\n        }\n        schema.indexes.forEach(addAffectedIndex);\n    }\n\n    function adjustOptimisticFromFailures(tblCache, req, res) {\n        if (res.numFailures === 0)\n            return req;\n        if (req.type === 'deleteRange') {\n            return null;\n        }\n        var numBulkOps = req.keys\n            ? req.keys.length\n            : 'values' in req && req.values\n                ? req.values.length\n                : 1;\n        if (res.numFailures === numBulkOps) {\n            return null;\n        }\n        var clone = __assign({}, req);\n        if (isArray(clone.keys)) {\n            clone.keys = clone.keys.filter(function (_, i) { return !(i in res.failures); });\n        }\n        if ('values' in clone && isArray(clone.values)) {\n            clone.values = clone.values.filter(function (_, i) { return !(i in res.failures); });\n        }\n        return clone;\n    }\n\n    function isAboveLower(key, range) {\n        return range.lower === undefined\n            ? true\n            : range.lowerOpen\n                ? cmp(key, range.lower) > 0\n                : cmp(key, range.lower) >= 0;\n    }\n    function isBelowUpper(key, range) {\n        return range.upper === undefined\n            ? true\n            : range.upperOpen\n                ? cmp(key, range.upper) < 0\n                : cmp(key, range.upper) <= 0;\n    }\n    function isWithinRange(key, range) {\n        return isAboveLower(key, range) && isBelowUpper(key, range);\n    }\n\n    function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {\n        if (!ops || ops.length === 0)\n            return result;\n        var index = req.query.index;\n        var multiEntry = index.multiEntry;\n        var queryRange = req.query.range;\n        var primaryKey = table.schema.primaryKey;\n        var extractPrimKey = primaryKey.extractKey;\n        var extractIndex = index.extractKey;\n        var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;\n        var finalResult = ops.reduce(function (result, op) {\n            var modifedResult = result;\n            var includedValues = [];\n            if (op.type === 'add' || op.type === 'put') {\n                var includedPKs = new RangeSet();\n                for (var i = op.values.length - 1; i >= 0; --i) {\n                    var value = op.values[i];\n                    var pk = extractPrimKey(value);\n                    if (includedPKs.hasKey(pk))\n                        continue;\n                    var key = extractIndex(value);\n                    if (multiEntry && isArray(key)\n                        ? key.some(function (k) { return isWithinRange(k, queryRange); })\n                        : isWithinRange(key, queryRange)) {\n                        includedPKs.addKey(pk);\n                        includedValues.push(value);\n                    }\n                }\n            }\n            switch (op.type) {\n                case 'add': {\n                    var existingKeys_1 = new RangeSet().addKeys(req.values ? result.map(function (v) { return extractPrimKey(v); }) : result);\n                    modifedResult = result.concat(req.values\n                        ? includedValues.filter(function (v) {\n                            var key = extractPrimKey(v);\n                            if (existingKeys_1.hasKey(key))\n                                return false;\n                            existingKeys_1.addKey(key);\n                            return true;\n                        })\n                        : includedValues\n                            .map(function (v) { return extractPrimKey(v); })\n                            .filter(function (k) {\n                            if (existingKeys_1.hasKey(k))\n                                return false;\n                            existingKeys_1.addKey(k);\n                            return true;\n                        }));\n                    break;\n                }\n                case 'put': {\n                    var keySet_1 = new RangeSet().addKeys(op.values.map(function (v) { return extractPrimKey(v); }));\n                    modifedResult = result\n                        .filter(\n                    function (item) { return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item); })\n                        .concat(\n                    req.values\n                        ? includedValues\n                        : includedValues.map(function (v) { return extractPrimKey(v); }));\n                    break;\n                }\n                case 'delete':\n                    var keysToDelete_1 = new RangeSet().addKeys(op.keys);\n                    modifedResult = result.filter(function (item) {\n                        return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);\n                    });\n                    break;\n                case 'deleteRange':\n                    var range_1 = op.range;\n                    modifedResult = result.filter(function (item) { return !isWithinRange(extractPrimKey(item), range_1); });\n                    break;\n            }\n            return modifedResult;\n        }, result);\n        if (finalResult === result)\n            return result;\n        finalResult.sort(function (a, b) {\n            return cmp(extractLowLevelIndex(a), extractLowLevelIndex(b)) ||\n                cmp(extractPrimKey(a), extractPrimKey(b));\n        });\n        if (req.limit && req.limit < Infinity) {\n            if (finalResult.length > req.limit) {\n                finalResult.length = req.limit;\n            }\n            else if (result.length === req.limit && finalResult.length < req.limit) {\n                cacheEntry.dirty = true;\n            }\n        }\n        return immutable ? Object.freeze(finalResult) : finalResult;\n    }\n\n    function areRangesEqual(r1, r2) {\n        return (cmp(r1.lower, r2.lower) === 0 &&\n            cmp(r1.upper, r2.upper) === 0 &&\n            !!r1.lowerOpen === !!r2.lowerOpen &&\n            !!r1.upperOpen === !!r2.upperOpen);\n    }\n\n    function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {\n        if (lower1 === undefined)\n            return lower2 !== undefined ? -1 : 0;\n        if (lower2 === undefined)\n            return 1;\n        var c = cmp(lower1, lower2);\n        if (c === 0) {\n            if (lowerOpen1 && lowerOpen2)\n                return 0;\n            if (lowerOpen1)\n                return 1;\n            if (lowerOpen2)\n                return -1;\n        }\n        return c;\n    }\n    function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {\n        if (upper1 === undefined)\n            return upper2 !== undefined ? 1 : 0;\n        if (upper2 === undefined)\n            return -1;\n        var c = cmp(upper1, upper2);\n        if (c === 0) {\n            if (upperOpen1 && upperOpen2)\n                return 0;\n            if (upperOpen1)\n                return -1;\n            if (upperOpen2)\n                return 1;\n        }\n        return c;\n    }\n    function isSuperRange(r1, r2) {\n        return (compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 &&\n            compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0);\n    }\n\n    function findCompatibleQuery(dbName, tableName, type, req) {\n        var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n        if (!tblCache)\n            return [];\n        var queries = tblCache.queries[type];\n        if (!queries)\n            return [null, false, tblCache, null];\n        var indexName = req.query ? req.query.index.name : null;\n        var entries = queries[indexName || ''];\n        if (!entries)\n            return [null, false, tblCache, null];\n        switch (type) {\n            case 'query':\n                var equalEntry = entries.find(function (entry) {\n                    return entry.req.limit === req.limit &&\n                        entry.req.values === req.values &&\n                        areRangesEqual(entry.req.query.range, req.query.range);\n                });\n                if (equalEntry)\n                    return [\n                        equalEntry,\n                        true,\n                        tblCache,\n                        entries,\n                    ];\n                var superEntry = entries.find(function (entry) {\n                    var limit = 'limit' in entry.req ? entry.req.limit : Infinity;\n                    return (limit >= req.limit &&\n                        (req.values ? entry.req.values : true) &&\n                        isSuperRange(entry.req.query.range, req.query.range));\n                });\n                return [superEntry, false, tblCache, entries];\n            case 'count':\n                var countQuery = entries.find(function (entry) {\n                    return areRangesEqual(entry.req.query.range, req.query.range);\n                });\n                return [countQuery, !!countQuery, tblCache, entries];\n        }\n    }\n\n    function subscribeToCacheEntry(cacheEntry, container, requery, signal) {\n        cacheEntry.subscribers.add(requery);\n        signal.addEventListener(\"abort\", function () {\n            cacheEntry.subscribers.delete(requery);\n            if (cacheEntry.subscribers.size === 0) {\n                enqueForDeletion(cacheEntry, container);\n            }\n        });\n    }\n    function enqueForDeletion(cacheEntry, container) {\n        setTimeout(function () {\n            if (cacheEntry.subscribers.size === 0) {\n                delArrayItem(container, cacheEntry);\n            }\n        }, 3000);\n    }\n\n    var cacheMiddleware = {\n        stack: 'dbcore',\n        level: 0,\n        name: 'Cache',\n        create: function (core) {\n            var dbName = core.schema.name;\n            var coreMW = __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n                    var idbtrans = core.transaction(stores, mode, options);\n                    if (mode === 'readwrite') {\n                        var ac_1 = new AbortController();\n                        var signal = ac_1.signal;\n                        var endTransaction = function (wasCommitted) { return function () {\n                            ac_1.abort();\n                            if (mode === 'readwrite') {\n                                var affectedSubscribers_1 = new Set();\n                                for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {\n                                    var storeName = stores_1[_i];\n                                    var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(storeName)];\n                                    if (tblCache) {\n                                        var table = core.table(storeName);\n                                        var ops = tblCache.optimisticOps.filter(function (op) { return op.trans === idbtrans; });\n                                        if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {\n                                            for (var _a = 0, _b = Object.values(tblCache.queries.query); _a < _b.length; _a++) {\n                                                var entries = _b[_a];\n                                                for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {\n                                                    var entry = _d[_c];\n                                                    if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {\n                                                        delArrayItem(entries, entry);\n                                                        entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        else if (ops.length > 0) {\n                                            tblCache.optimisticOps = tblCache.optimisticOps.filter(function (op) { return op.trans !== idbtrans; });\n                                            for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {\n                                                var entries = _f[_e];\n                                                for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {\n                                                    var entry = _h[_g];\n                                                    if (entry.res != null &&\n                                                        idbtrans.mutatedParts\n    ) {\n                                                        if (wasCommitted && !entry.dirty) {\n                                                            var freezeResults = Object.isFrozen(entry.res);\n                                                            var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);\n                                                            if (entry.dirty) {\n                                                                delArrayItem(entries, entry);\n                                                                entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                            }\n                                                            else if (modRes !== entry.res) {\n                                                                entry.res = modRes;\n                                                                entry.promise = DexiePromise.resolve({ result: modRes });\n                                                            }\n                                                        }\n                                                        else {\n                                                            if (entry.dirty) {\n                                                                delArrayItem(entries, entry);\n                                                            }\n                                                            entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                affectedSubscribers_1.forEach(function (requery) { return requery(); });\n                            }\n                        }; };\n                        idbtrans.addEventListener('abort', endTransaction(false), {\n                            signal: signal,\n                        });\n                        idbtrans.addEventListener('error', endTransaction(false), {\n                            signal: signal,\n                        });\n                        idbtrans.addEventListener('complete', endTransaction(true), {\n                            signal: signal,\n                        });\n                    }\n                    return idbtrans;\n                }, table: function (tableName) {\n                    var downTable = core.table(tableName);\n                    var primKey = downTable.schema.primaryKey;\n                    var tableMW = __assign(__assign({}, downTable), { mutate: function (req) {\n                            var trans = PSD.trans;\n                            if (primKey.outbound ||\n                                trans.db._options.cache === 'disabled' ||\n                                trans.explicit ||\n                                trans.idbtrans.mode !== 'readwrite'\n                            ) {\n                                return downTable.mutate(req);\n                            }\n                            var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n                            if (!tblCache)\n                                return downTable.mutate(req);\n                            var promise = downTable.mutate(req);\n                            if ((req.type === 'add' || req.type === 'put') && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function (key) { return key == null; }))) {\n                                promise.then(function (res) {\n                                    var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function (value, i) {\n                                            var _a;\n                                            if (res.failures[i])\n                                                return value;\n                                            var valueWithKey = ((_a = primKey.keyPath) === null || _a === void 0 ? void 0 : _a.includes('.'))\n                                                ? deepClone(value)\n                                                : __assign({}, value);\n                                            setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);\n                                            return valueWithKey;\n                                        }) });\n                                    var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);\n                                    tblCache.optimisticOps.push(adjustedReq);\n                                    queueMicrotask(function () { return req.mutatedParts && signalSubscribersLazily(req.mutatedParts); });\n                                });\n                            }\n                            else {\n                                tblCache.optimisticOps.push(req);\n                                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                                promise.then(function (res) {\n                                    if (res.numFailures > 0) {\n                                        delArrayItem(tblCache.optimisticOps, req);\n                                        var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);\n                                        if (adjustedReq) {\n                                            tblCache.optimisticOps.push(adjustedReq);\n                                        }\n                                        req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                                    }\n                                });\n                                promise.catch(function () {\n                                    delArrayItem(tblCache.optimisticOps, req);\n                                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                                });\n                            }\n                            return promise;\n                        }, query: function (req) {\n                            var _a;\n                            if (!isCachableContext(PSD, downTable) || !isCachableRequest(\"query\", req))\n                                return downTable.query(req);\n                            var freezeResults = ((_a = PSD.trans) === null || _a === void 0 ? void 0 : _a.db._options.cache) === 'immutable';\n                            var _b = PSD, requery = _b.requery, signal = _b.signal;\n                            var _c = findCompatibleQuery(dbName, tableName, 'query', req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];\n                            if (cacheEntry && exactMatch) {\n                                cacheEntry.obsSet = req.obsSet;\n                            }\n                            else {\n                                var promise = downTable.query(req).then(function (res) {\n                                    var result = res.result;\n                                    if (cacheEntry)\n                                        cacheEntry.res = result;\n                                    if (freezeResults) {\n                                        for (var i = 0, l = result.length; i < l; ++i) {\n                                            Object.freeze(result[i]);\n                                        }\n                                        Object.freeze(result);\n                                    }\n                                    else {\n                                        res.result = deepClone(result);\n                                    }\n                                    return res;\n                                }).catch(function (error) {\n                                    if (container && cacheEntry)\n                                        delArrayItem(container, cacheEntry);\n                                    return Promise.reject(error);\n                                });\n                                cacheEntry = {\n                                    obsSet: req.obsSet,\n                                    promise: promise,\n                                    subscribers: new Set(),\n                                    type: 'query',\n                                    req: req,\n                                    dirty: false,\n                                };\n                                if (container) {\n                                    container.push(cacheEntry);\n                                }\n                                else {\n                                    container = [cacheEntry];\n                                    if (!tblCache) {\n                                        tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)] = {\n                                            queries: {\n                                                query: {},\n                                                count: {},\n                                            },\n                                            objs: new Map(),\n                                            optimisticOps: [],\n                                            unsignaledParts: {}\n                                        };\n                                    }\n                                    tblCache.queries.query[req.query.index.name || ''] = container;\n                                }\n                            }\n                            subscribeToCacheEntry(cacheEntry, container, requery, signal);\n                            return cacheEntry.promise.then(function (res) {\n                                return {\n                                    result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults),\n                                };\n                            });\n                        } });\n                    return tableMW;\n                } });\n            return coreMW;\n        },\n    };\n\n    function vipify(target, vipDb) {\n        return new Proxy(target, {\n            get: function (target, prop, receiver) {\n                if (prop === 'db')\n                    return vipDb;\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n\n    var Dexie$1 =  (function () {\n        function Dexie(name, options) {\n            var _this = this;\n            this._middlewares = {};\n            this.verno = 0;\n            var deps = Dexie.dependencies;\n            this._options = options = __assign({\n                addons: Dexie.addons, autoOpen: true,\n                indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange, cache: 'cloned' }, options);\n            this._deps = {\n                indexedDB: options.indexedDB,\n                IDBKeyRange: options.IDBKeyRange\n            };\n            var addons = options.addons;\n            this._dbSchema = {};\n            this._versions = [];\n            this._storeNames = [];\n            this._allTables = {};\n            this.idbdb = null;\n            this._novip = this;\n            var state = {\n                dbOpenError: null,\n                isBeingOpened: false,\n                onReadyBeingFired: null,\n                openComplete: false,\n                dbReadyResolve: nop,\n                dbReadyPromise: null,\n                cancelOpen: nop,\n                openCanceller: null,\n                autoSchema: true,\n                PR1398_maxLoop: 3,\n                autoOpen: options.autoOpen,\n            };\n            state.dbReadyPromise = new DexiePromise(function (resolve) {\n                state.dbReadyResolve = resolve;\n            });\n            state.openCanceller = new DexiePromise(function (_, reject) {\n                state.cancelOpen = reject;\n            });\n            this._state = state;\n            this.name = name;\n            this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n            this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n                return function (subscriber, bSticky) {\n                    Dexie.vip(function () {\n                        var state = _this._state;\n                        if (state.openComplete) {\n                            if (!state.dbOpenError)\n                                DexiePromise.resolve().then(subscriber);\n                            if (bSticky)\n                                subscribe(subscriber);\n                        }\n                        else if (state.onReadyBeingFired) {\n                            state.onReadyBeingFired.push(subscriber);\n                            if (bSticky)\n                                subscribe(subscriber);\n                        }\n                        else {\n                            subscribe(subscriber);\n                            var db_1 = _this;\n                            if (!bSticky)\n                                subscribe(function unsubscribe() {\n                                    db_1.on.ready.unsubscribe(subscriber);\n                                    db_1.on.ready.unsubscribe(unsubscribe);\n                                });\n                        }\n                    });\n                };\n            });\n            this.Collection = createCollectionConstructor(this);\n            this.Table = createTableConstructor(this);\n            this.Transaction = createTransactionConstructor(this);\n            this.Version = createVersionConstructor(this);\n            this.WhereClause = createWhereClauseConstructor(this);\n            this.on(\"versionchange\", function (ev) {\n                if (ev.newVersion > 0)\n                    console.warn(\"Another connection wants to upgrade database '\".concat(_this.name, \"'. Closing db now to resume the upgrade.\"));\n                else\n                    console.warn(\"Another connection wants to delete database '\".concat(_this.name, \"'. Closing db now to resume the delete request.\"));\n                _this.close({ disableAutoOpen: false });\n            });\n            this.on(\"blocked\", function (ev) {\n                if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                    console.warn(\"Dexie.delete('\".concat(_this.name, \"') was blocked\"));\n                else\n                    console.warn(\"Upgrade '\".concat(_this.name, \"' blocked by other connection holding version \").concat(ev.oldVersion / 10));\n            });\n            this._maxKey = getMaxKey(options.IDBKeyRange);\n            this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };\n            this._fireOnBlocked = function (ev) {\n                _this.on(\"blocked\").fire(ev);\n                connections\n                    .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })\n                    .map(function (c) { return c.on(\"versionchange\").fire(ev); });\n            };\n            this.use(cacheExistingValuesMiddleware);\n            this.use(cacheMiddleware);\n            this.use(observabilityMiddleware);\n            this.use(virtualIndexMiddleware);\n            this.use(hooksMiddleware);\n            var vipDB = new Proxy(this, {\n                get: function (_, prop, receiver) {\n                    if (prop === '_vip')\n                        return true;\n                    if (prop === 'table')\n                        return function (tableName) { return vipify(_this.table(tableName), vipDB); };\n                    var rv = Reflect.get(_, prop, receiver);\n                    if (rv instanceof Table)\n                        return vipify(rv, vipDB);\n                    if (prop === 'tables')\n                        return rv.map(function (t) { return vipify(t, vipDB); });\n                    if (prop === '_createTransaction')\n                        return function () {\n                            var tx = rv.apply(this, arguments);\n                            return vipify(tx, vipDB);\n                        };\n                    return rv;\n                }\n            });\n            this.vip = vipDB;\n            addons.forEach(function (addon) { return addon(_this); });\n        }\n        Dexie.prototype.version = function (versionNumber) {\n            if (isNaN(versionNumber) || versionNumber < 0.1)\n                throw new exceptions.Type(\"Given version is not a positive number\");\n            versionNumber = Math.round(versionNumber * 10) / 10;\n            if (this.idbdb || this._state.isBeingOpened)\n                throw new exceptions.Schema(\"Cannot add version when database is open\");\n            this.verno = Math.max(this.verno, versionNumber);\n            var versions = this._versions;\n            var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];\n            if (versionInstance)\n                return versionInstance;\n            versionInstance = new this.Version(versionNumber);\n            versions.push(versionInstance);\n            versions.sort(lowerVersionFirst);\n            versionInstance.stores({});\n            this._state.autoSchema = false;\n            return versionInstance;\n        };\n        Dexie.prototype._whenReady = function (fn) {\n            var _this = this;\n            return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {\n                if (_this._state.openComplete) {\n                    return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));\n                }\n                if (!_this._state.isBeingOpened) {\n                    if (!_this._state.autoOpen) {\n                        reject(new exceptions.DatabaseClosed());\n                        return;\n                    }\n                    _this.open().catch(nop);\n                }\n                _this._state.dbReadyPromise.then(resolve, reject);\n            }).then(fn);\n        };\n        Dexie.prototype.use = function (_a) {\n            var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;\n            if (name)\n                this.unuse({ stack: stack, name: name });\n            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n            middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });\n            middlewares.sort(function (a, b) { return a.level - b.level; });\n            return this;\n        };\n        Dexie.prototype.unuse = function (_a) {\n            var stack = _a.stack, name = _a.name, create = _a.create;\n            if (stack && this._middlewares[stack]) {\n                this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {\n                    return create ? mw.create !== create :\n                        name ? mw.name !== name :\n                            false;\n                });\n            }\n            return this;\n        };\n        Dexie.prototype.open = function () {\n            var _this = this;\n            return usePSD(globalPSD,\n            function () { return dexieOpen(_this); });\n        };\n        Dexie.prototype._close = function () {\n            var state = this._state;\n            var idx = connections.indexOf(this);\n            if (idx >= 0)\n                connections.splice(idx, 1);\n            if (this.idbdb) {\n                try {\n                    this.idbdb.close();\n                }\n                catch (e) { }\n                this.idbdb = null;\n            }\n            if (!state.isBeingOpened) {\n                state.dbReadyPromise = new DexiePromise(function (resolve) {\n                    state.dbReadyResolve = resolve;\n                });\n                state.openCanceller = new DexiePromise(function (_, reject) {\n                    state.cancelOpen = reject;\n                });\n            }\n        };\n        Dexie.prototype.close = function (_a) {\n            var _b = _a === void 0 ? { disableAutoOpen: true } : _a, disableAutoOpen = _b.disableAutoOpen;\n            var state = this._state;\n            if (disableAutoOpen) {\n                if (state.isBeingOpened) {\n                    state.cancelOpen(new exceptions.DatabaseClosed());\n                }\n                this._close();\n                state.autoOpen = false;\n                state.dbOpenError = new exceptions.DatabaseClosed();\n            }\n            else {\n                this._close();\n                state.autoOpen = this._options.autoOpen ||\n                    state.isBeingOpened;\n                state.openComplete = false;\n                state.dbOpenError = null;\n            }\n        };\n        Dexie.prototype.delete = function (closeOptions) {\n            var _this = this;\n            if (closeOptions === void 0) { closeOptions = { disableAutoOpen: true }; }\n            var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== 'object';\n            var state = this._state;\n            return new DexiePromise(function (resolve, reject) {\n                var doDelete = function () {\n                    _this.close(closeOptions);\n                    var req = _this._deps.indexedDB.deleteDatabase(_this.name);\n                    req.onsuccess = wrap(function () {\n                        _onDatabaseDeleted(_this._deps, _this.name);\n                        resolve();\n                    });\n                    req.onerror = eventRejectHandler(reject);\n                    req.onblocked = _this._fireOnBlocked;\n                };\n                if (hasInvalidArguments)\n                    throw new exceptions.InvalidArgument(\"Invalid closeOptions argument to db.delete()\");\n                if (state.isBeingOpened) {\n                    state.dbReadyPromise.then(doDelete);\n                }\n                else {\n                    doDelete();\n                }\n            });\n        };\n        Dexie.prototype.backendDB = function () {\n            return this.idbdb;\n        };\n        Dexie.prototype.isOpen = function () {\n            return this.idbdb !== null;\n        };\n        Dexie.prototype.hasBeenClosed = function () {\n            var dbOpenError = this._state.dbOpenError;\n            return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n        };\n        Dexie.prototype.hasFailed = function () {\n            return this._state.dbOpenError !== null;\n        };\n        Dexie.prototype.dynamicallyOpened = function () {\n            return this._state.autoSchema;\n        };\n        Object.defineProperty(Dexie.prototype, \"tables\", {\n            get: function () {\n                var _this = this;\n                return keys(this._allTables).map(function (name) { return _this._allTables[name]; });\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Dexie.prototype.transaction = function () {\n            var args = extractTransactionArgs.apply(this, arguments);\n            return this._transaction.apply(this, args);\n        };\n        Dexie.prototype._transaction = function (mode, tables, scopeFunc) {\n            var _this = this;\n            var parentTransaction = PSD.trans;\n            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n                parentTransaction = null;\n            var onlyIfCompatible = mode.indexOf('?') !== -1;\n            mode = mode.replace('!', '').replace('?', '');\n            var idbMode, storeNames;\n            try {\n                storeNames = tables.map(function (table) {\n                    var storeName = table instanceof _this.Table ? table.name : table;\n                    if (typeof storeName !== 'string')\n                        throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                    return storeName;\n                });\n                if (mode == \"r\" || mode === READONLY)\n                    idbMode = READONLY;\n                else if (mode == \"rw\" || mode == READWRITE)\n                    idbMode = READWRITE;\n                else\n                    throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n                if (parentTransaction) {\n                    if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                        if (onlyIfCompatible) {\n                            parentTransaction = null;\n                        }\n                        else\n                            throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                    }\n                    if (parentTransaction) {\n                        storeNames.forEach(function (storeName) {\n                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                                if (onlyIfCompatible) {\n                                    parentTransaction = null;\n                                }\n                                else\n                                    throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                        \" not included in parent transaction.\");\n                            }\n                        });\n                    }\n                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                        parentTransaction = null;\n                    }\n                }\n            }\n            catch (e) {\n                return parentTransaction ?\n                    parentTransaction._promise(null, function (_, reject) { reject(e); }) :\n                    rejection(e);\n            }\n            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n            return (parentTransaction ?\n                parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n                PSD.trans ?\n                    usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :\n                    this._whenReady(enterTransaction));\n        };\n        Dexie.prototype.table = function (tableName) {\n            if (!hasOwn(this._allTables, tableName)) {\n                throw new exceptions.InvalidTable(\"Table \".concat(tableName, \" does not exist\"));\n            }\n            return this._allTables[tableName];\n        };\n        return Dexie;\n    }());\n\n    var symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n        ? Symbol.observable\n        : \"@@observable\";\n    var Observable =  (function () {\n        function Observable(subscribe) {\n            this._subscribe = subscribe;\n        }\n        Observable.prototype.subscribe = function (x, error, complete) {\n            return this._subscribe(!x || typeof x === \"function\" ? { next: x, error: error, complete: complete } : x);\n        };\n        Observable.prototype[symbolObservable] = function () {\n            return this;\n        };\n        return Observable;\n    }());\n\n    var domDeps;\n    try {\n        domDeps = {\n            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n        };\n    }\n    catch (e) {\n        domDeps = { indexedDB: null, IDBKeyRange: null };\n    }\n\n    function liveQuery(querier) {\n        var hasValue = false;\n        var currentValue;\n        var observable = new Observable(function (observer) {\n            var scopeFuncIsAsync = isAsyncFunction(querier);\n            function execute(ctx) {\n                var wasRootExec = beginMicroTickScope();\n                try {\n                    if (scopeFuncIsAsync) {\n                        incrementExpectedAwaits();\n                    }\n                    var rv = newScope(querier, ctx);\n                    if (scopeFuncIsAsync) {\n                        rv = rv.finally(decrementExpectedAwaits);\n                    }\n                    return rv;\n                }\n                finally {\n                    wasRootExec && endMicroTickScope();\n                }\n            }\n            var closed = false;\n            var abortController;\n            var accumMuts = {};\n            var currentObs = {};\n            var subscription = {\n                get closed() {\n                    return closed;\n                },\n                unsubscribe: function () {\n                    if (closed)\n                        return;\n                    closed = true;\n                    if (abortController)\n                        abortController.abort();\n                    if (startedListening)\n                        globalEvents.storagemutated.unsubscribe(mutationListener);\n                },\n            };\n            observer.start && observer.start(subscription);\n            var startedListening = false;\n            var doQuery = function () { return execInGlobalContext(_doQuery); };\n            function shouldNotify() {\n                return obsSetsOverlap(currentObs, accumMuts);\n            }\n            var mutationListener = function (parts) {\n                extendObservabilitySet(accumMuts, parts);\n                if (shouldNotify()) {\n                    doQuery();\n                }\n            };\n            var _doQuery = function () {\n                if (closed ||\n                    !domDeps.indexedDB)\n                 {\n                    return;\n                }\n                accumMuts = {};\n                var subscr = {};\n                if (abortController)\n                    abortController.abort();\n                abortController = new AbortController();\n                var ctx = {\n                    subscr: subscr,\n                    signal: abortController.signal,\n                    requery: doQuery,\n                    querier: querier,\n                    trans: null\n                };\n                var ret = execute(ctx);\n                Promise.resolve(ret).then(function (result) {\n                    hasValue = true;\n                    currentValue = result;\n                    if (closed || ctx.signal.aborted) {\n                        return;\n                    }\n                    accumMuts = {};\n                    currentObs = subscr;\n                    if (!objectIsEmpty(currentObs) && !startedListening) {\n                        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                        startedListening = true;\n                    }\n                    execInGlobalContext(function () { return !closed && observer.next && observer.next(result); });\n                }, function (err) {\n                    hasValue = false;\n                    if (!['DatabaseClosedError', 'AbortError'].includes(err === null || err === void 0 ? void 0 : err.name)) {\n                        if (!closed)\n                            execInGlobalContext(function () {\n                                if (closed)\n                                    return;\n                                observer.error && observer.error(err);\n                            });\n                    }\n                });\n            };\n            setTimeout(doQuery, 0);\n            return subscription;\n        });\n        observable.hasValue = function () { return hasValue; };\n        observable.getValue = function () { return currentValue; };\n        return observable;\n    }\n\n    var Dexie = Dexie$1;\n    props(Dexie, __assign(__assign({}, fullNameExceptions), {\n        delete: function (databaseName) {\n            var db = new Dexie(databaseName, { addons: [] });\n            return db.delete();\n        },\n        exists: function (name) {\n            return new Dexie(name, { addons: [] }).open().then(function (db) {\n                db.close();\n                return true;\n            }).catch('NoSuchDatabaseError', function () { return false; });\n        },\n        getDatabaseNames: function (cb) {\n            try {\n                return getDatabaseNames(Dexie.dependencies).then(cb);\n            }\n            catch (_a) {\n                return rejection(new exceptions.MissingAPI());\n            }\n        },\n        defineClass: function () {\n            function Class(content) {\n                extend(this, content);\n            }\n            return Class;\n        }, ignoreTransaction: function (scopeFunc) {\n            return PSD.trans ?\n                usePSD(PSD.transless, scopeFunc) :\n                scopeFunc();\n        }, vip: vip, async: function (generatorFn) {\n            return function () {\n                try {\n                    var rv = awaitIterator(generatorFn.apply(this, arguments));\n                    if (!rv || typeof rv.then !== 'function')\n                        return DexiePromise.resolve(rv);\n                    return rv;\n                }\n                catch (e) {\n                    return rejection(e);\n                }\n            };\n        }, spawn: function (generatorFn, args, thiz) {\n            try {\n                var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        },\n        currentTransaction: {\n            get: function () { return PSD.trans || null; }\n        }, waitFor: function (promiseOrFunction, optionalTimeout) {\n            var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n                Dexie.ignoreTransaction(promiseOrFunction) :\n                promiseOrFunction)\n                .timeout(optionalTimeout || 60000);\n            return PSD.trans ?\n                PSD.trans.waitFor(promise) :\n                promise;\n        },\n        Promise: DexiePromise,\n        debug: {\n            get: function () { return debug; },\n            set: function (value) {\n                setDebug(value);\n            }\n        },\n        derive: derive, extend: extend, props: props, override: override,\n        Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,\n        getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,\n        minKey: minKey,\n        addons: [],\n        connections: connections,\n        errnames: errnames,\n        dependencies: domDeps, cache: cache,\n        semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')\n            .map(function (n) { return parseInt(n); })\n            .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }) }));\n    Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\n    if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {\n            if (!propagatingLocally) {\n                var event_1;\n                event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n                propagatingLocally = true;\n                dispatchEvent(event_1);\n                propagatingLocally = false;\n            }\n        });\n        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {\n            var detail = _a.detail;\n            if (!propagatingLocally) {\n                propagateLocally(detail);\n            }\n        });\n    }\n    function propagateLocally(updateParts) {\n        var wasMe = propagatingLocally;\n        try {\n            propagatingLocally = true;\n            globalEvents.storagemutated.fire(updateParts);\n            signalSubscribersNow(updateParts, true);\n        }\n        finally {\n            propagatingLocally = wasMe;\n        }\n    }\n    var propagatingLocally = false;\n\n    var bc;\n    var createBC = function () { };\n    if (typeof BroadcastChannel !== 'undefined') {\n        createBC = function () {\n            bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n            bc.onmessage = function (ev) { return ev.data && propagateLocally(ev.data); };\n        };\n        createBC();\n        if (typeof bc.unref === 'function') {\n            bc.unref();\n        }\n        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n            if (!propagatingLocally) {\n                bc.postMessage(changedParts);\n            }\n        });\n    }\n\n    if (typeof addEventListener !== 'undefined') {\n        addEventListener('pagehide', function (event) {\n            if (!Dexie$1.disableBfCache && event.persisted) {\n                if (debug)\n                    console.debug('Dexie: handling persisted pagehide');\n                bc === null || bc === void 0 ? void 0 : bc.close();\n                for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {\n                    var db = connections_1[_i];\n                    db.close({ disableAutoOpen: false });\n                }\n            }\n        });\n        addEventListener('pageshow', function (event) {\n            if (!Dexie$1.disableBfCache && event.persisted) {\n                if (debug)\n                    console.debug('Dexie: handling persisted pageshow');\n                createBC();\n                propagateLocally({ all: new RangeSet(-Infinity, [[]]) });\n            }\n        });\n    }\n\n    function add(value) {\n        return new PropModification({ add: value });\n    }\n\n    function remove(value) {\n        return new PropModification({ remove: value });\n    }\n\n    function replacePrefix(a, b) {\n        return new PropModification({ replacePrefix: [a, b] });\n    }\n\n    DexiePromise.rejectionMapper = mapError;\n    setDebug(debug);\n\n    var namedExports = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        Dexie: Dexie$1,\n        liveQuery: liveQuery,\n        Entity: Entity,\n        cmp: cmp,\n        PropModSymbol: PropModSymbol,\n        PropModification: PropModification,\n        replacePrefix: replacePrefix,\n        add: add,\n        remove: remove,\n        'default': Dexie$1,\n        RangeSet: RangeSet,\n        mergeRanges: mergeRanges,\n        rangesOverlap: rangesOverlap\n    });\n\n    __assign(Dexie$1, namedExports, { default: Dexie$1 });\n\n    return Dexie$1;\n\n}));\n//# sourceMappingURL=dexie.js.map\n","// Making the module version consumable via require - to prohibit\n// multiple occurrancies of the same module in the same app\n// (dual package hazard, https://nodejs.org/api/packages.html#dual-package-hazard)\nimport _Dexie from \"./dist/dexie.js\";\nconst DexieSymbol = Symbol.for(\"Dexie\");\nconst Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _Dexie);\nif (_Dexie.semVer !== Dexie.semVer) {\n    throw new Error(`Two different versions of Dexie loaded in the same app: ${_Dexie.semVer} and ${Dexie.semVer}`);\n}\nconst { liveQuery, mergeRanges, rangesOverlap, RangeSet, cmp, Entity,\n    PropModSymbol, PropModification, replacePrefix, add, remove } = Dexie;\nexport { liveQuery, mergeRanges, rangesOverlap, RangeSet, cmp, Dexie, Entity,\n    PropModSymbol, PropModification, replacePrefix, add, remove };\nexport default Dexie;\n","import { pushAtSortPosition } from 'array-push-at-sort-position';\nexport const doNothing = (_input) => { };\nexport const insertFirst = (input) => {\n    input.previousResults.unshift(input.changeEvent.doc);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n    }\n};\nexport const insertLast = (input) => {\n    input.previousResults.push(input.changeEvent.doc);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n    }\n};\nexport const removeFirstItem = (input) => {\n    const first = input.previousResults.shift();\n    if (input.keyDocumentMap && first) {\n        input.keyDocumentMap.delete(first[input.queryParams.primaryKey]);\n    }\n};\nexport const removeLastItem = (input) => {\n    const last = input.previousResults.pop();\n    if (input.keyDocumentMap && last) {\n        input.keyDocumentMap.delete(last[input.queryParams.primaryKey]);\n    }\n};\nexport const removeFirstInsertLast = (input) => {\n    removeFirstItem(input);\n    insertLast(input);\n};\nexport const removeLastInsertFirst = (input) => {\n    removeLastItem(input);\n    insertFirst(input);\n};\nexport const removeFirstInsertFirst = (input) => {\n    removeFirstItem(input);\n    insertFirst(input);\n};\nexport const removeLastInsertLast = (input) => {\n    removeLastItem(input);\n    insertLast(input);\n};\nexport const removeExisting = (input) => {\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.delete(input.changeEvent.id);\n    }\n    // find index of document\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n        const item = results[i];\n        // remove\n        if (item[primary] === input.changeEvent.id) {\n            results.splice(i, 1);\n            break;\n        }\n    }\n};\nexport const replaceExisting = (input) => {\n    // find index of document\n    const doc = input.changeEvent.doc;\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n        const item = results[i];\n        // replace\n        if (item[primary] === input.changeEvent.id) {\n            results[i] = doc;\n            if (input.keyDocumentMap) {\n                input.keyDocumentMap.set(input.changeEvent.id, doc);\n            }\n            break;\n        }\n    }\n};\n/**\n * this function always returns wrong results\n * it must be later optimised out\n * otherwise there is something broken\n */\nexport const alwaysWrong = (input) => {\n    const wrongHuman = {\n        _id: 'wrongHuman' + new Date().getTime()\n    };\n    input.previousResults.length = 0; // clear array\n    input.previousResults.push(wrongHuman);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.clear();\n        input.keyDocumentMap.set(wrongHuman._id, wrongHuman);\n    }\n};\nexport const insertAtSortPosition = (input) => {\n    const docId = input.changeEvent.id;\n    const doc = input.changeEvent.doc;\n    if (input.keyDocumentMap) {\n        if (input.keyDocumentMap.has(docId)) {\n            /**\n             * If document is already in results,\n             * we cannot add it again because it would throw on non-deterministic ordering.\n             */\n            return;\n        }\n        input.keyDocumentMap.set(docId, doc);\n    }\n    else {\n        const isDocInResults = input.previousResults.find((d) => d[input.queryParams.primaryKey] === docId);\n        /**\n         * If document is already in results,\n         * we cannot add it again because it would throw on non-deterministic ordering.\n         */\n        if (isDocInResults) {\n            return;\n        }\n    }\n    pushAtSortPosition(input.previousResults, doc, input.queryParams.sortComparator, 0);\n};\nexport const removeExistingAndInsertAtSortPosition = (input) => {\n    removeExisting(input);\n    insertAtSortPosition(input);\n};\nexport const runFullQueryAgain = (_input) => {\n    throw new Error('Action runFullQueryAgain must be implemented by yourself');\n};\nexport const unknownAction = (_input) => {\n    throw new Error('Action unknownAction should never be called');\n};\n//# sourceMappingURL=action-functions.js.map","import { doNothing, insertFirst, insertLast, removeFirstItem, removeLastItem, removeFirstInsertLast, removeLastInsertFirst, removeExisting, replaceExisting, alwaysWrong, insertAtSortPosition, removeExistingAndInsertAtSortPosition, runFullQueryAgain, unknownAction, removeFirstInsertFirst, removeLastInsertLast } from './action-functions.js';\nexport * from './action-functions.js';\n/**\n * all actions ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nexport const orderedActionList = [\n    'doNothing',\n    'insertFirst',\n    'insertLast',\n    'removeFirstItem',\n    'removeLastItem',\n    'removeFirstInsertLast',\n    'removeLastInsertFirst',\n    'removeFirstInsertFirst',\n    'removeLastInsertLast',\n    'removeExisting',\n    'replaceExisting',\n    'alwaysWrong',\n    'insertAtSortPosition',\n    'removeExistingAndInsertAtSortPosition',\n    'runFullQueryAgain',\n    'unknownAction'\n];\nexport const actionFunctions = {\n    doNothing,\n    insertFirst,\n    insertLast,\n    removeFirstItem,\n    removeLastItem,\n    removeFirstInsertLast,\n    removeLastInsertFirst,\n    removeFirstInsertFirst,\n    removeLastInsertLast,\n    removeExisting,\n    replaceExisting,\n    alwaysWrong,\n    insertAtSortPosition,\n    removeExistingAndInsertAtSortPosition,\n    runFullQueryAgain,\n    unknownAction\n};\n//# sourceMappingURL=index.js.map","import { minimalStringToSimpleBdd, resolveWithSimpleBdd } from 'binary-decision-diagram';\nimport { stateResolveFunctionByIndex } from '../states/index.js';\nexport const minimalBddString = '14a1b,c+d2e5f0g/h.i4j*k-l)m(n6oeh6pnm6qen6ril6snh6tin6ubo9vce9wmh9xns9yne9zmi9{cm9|ad9}cp9~aq9ae9¡bf9¢bq9£cg9¤ck9¥cn9¦nd9§np9¨nq9©nf9ªng9«nm9¬nk9­mr9®ms9¯mt9°mj9±mk9²ml9³mn9´mc8µ³{8¶¯}8·°¤8¸³§8¹mn8º³«8»³m8¼m´4½z²4¾³w4¿zµ4À¯¶4Á°·4Â³º4Ã³¸4Äm¹4Åv¤7Æyn7ÇÀÁ7È~7É¥¤7ÊÃÄ7Ë¨n7Ìº¹7Í­°7Î®m7Ï¯°7Ð±m7Ñ³m7Ò¼m5ÓÄm5Ô¹m5Õ½°5Ö¾m5×¿°5ØÇÏ5ÙÂm5ÚÊÑ5Û±m5Üºm5ÝÌÑ5ÞÕÍ2ß|2à¡u2á£Å2âÖÎ2ã¦Æ2ä©x2åªÆ2æ×Ø2ç|È2è¡¢2é£É2ê¤¥2ëÙÚ2ì¦Ë2í©n2îªn2ïÛÐ2ðÜÝ2ñ¬n2òÒÓ/óan/ôbn/õcn/öÞâ/÷ßã/øàä/ùáå/úæë/ûçì/üèí/ýéî/þÍÎ/ÿÏÑ/ĀòÔ,ācn,Ăöï,ă¤ñ,Ąúð,ąêñ,ĆþÐ,ćÿÑ,Ĉac0ĉbc0Ċóõ0ċôā0Čßá0čà¤0Ďçé0ďèê0Đ÷ù0đøă0Ēûý0ēüą0ĔmÒ-ĕmĀ-ĖÞæ-ėČĎ-Ęčď-ęĂĄ-ĚĐĒ-ěđē-Ĝ²»-ĝÍÏ-ĞĆć-ğ²³-ĠĔĈ3ġĕĊ3ĢĖė3ģęĚ3ĤĢĝ(ĥĜğ(ĦģĞ(ħĠġ+Ĩĉċ+ĩĤĦ+ĪĘě+īħĨ1ĬĩĪ1ĭĬī*Įĥm*ĭĮ.';\nlet simpleBdd;\nexport function getSimpleBdd() {\n    if (!simpleBdd) {\n        simpleBdd = minimalStringToSimpleBdd(minimalBddString);\n    }\n    return simpleBdd;\n}\nexport const resolveInput = (input) => {\n    return resolveWithSimpleBdd(getSimpleBdd(), stateResolveFunctionByIndex, input);\n};\n//# sourceMappingURL=bdd.generated.js.map","import { getStateSet } from './states/index.js';\nimport { actionFunctions, orderedActionList } from './actions/index.js';\nimport { resolveInput } from './bdd/bdd.generated.js';\nexport * from './states/index.js';\nexport * from './util.js';\nexport * from './actions/index.js';\nexport function calculateActionFromMap(stateSetToActionMap, input) {\n    const stateSet = getStateSet(input);\n    const actionName = stateSetToActionMap.get(stateSet);\n    if (!actionName) {\n        return {\n            action: 'runFullQueryAgain',\n            stateSet\n        };\n    }\n    else {\n        return {\n            action: actionName,\n            stateSet\n        };\n    }\n}\nexport function calculateActionName(input) {\n    const resolvedActionId = resolveInput(input);\n    return orderedActionList[resolvedActionId];\n}\nexport function calculateActionFunction(input) {\n    const actionName = calculateActionName(input);\n    return actionFunctions[actionName];\n}\n/**\n * for performance reasons,\n * @mutates the input\n * @returns the new results\n */\nexport function runAction(action, queryParams, changeEvent, previousResults, keyDocumentMap) {\n    const fn = actionFunctions[action];\n    fn({\n        queryParams,\n        changeEvent,\n        previousResults,\n        keyDocumentMap\n    });\n    return previousResults;\n}\n//# sourceMappingURL=index.js.map","import { hasLimit, isFindOne, hasSkip, wasResultsEmpty, isDelete, isInsert, isUpdate, wasLimitReached, sortParamsChanged, wasInResult, wasFirst, wasLast, wasSortedBeforeFirst, wasSortedAfterLast, isSortedBeforeFirst, isSortedAfterLast, wasMatching, doesMatchNow } from './state-resolver.js';\nexport * from './state-resolver.js';\n/**\n * all states ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nexport const orderedStateList = [\n    'isInsert',\n    'isUpdate',\n    'isDelete',\n    'hasLimit',\n    'isFindOne',\n    'hasSkip',\n    'wasResultsEmpty',\n    'wasLimitReached',\n    'wasFirst',\n    'wasLast',\n    'sortParamsChanged',\n    'wasInResult',\n    'wasSortedBeforeFirst',\n    'wasSortedAfterLast',\n    'isSortedBeforeFirst',\n    'isSortedAfterLast',\n    'wasMatching',\n    'doesMatchNow'\n];\nexport const stateResolveFunctions = {\n    isInsert,\n    isUpdate,\n    isDelete,\n    hasLimit,\n    isFindOne,\n    hasSkip,\n    wasResultsEmpty,\n    wasLimitReached,\n    wasFirst,\n    wasLast,\n    sortParamsChanged,\n    wasInResult,\n    wasSortedBeforeFirst,\n    wasSortedAfterLast,\n    isSortedBeforeFirst,\n    isSortedAfterLast,\n    wasMatching,\n    doesMatchNow\n};\nexport const stateResolveFunctionByIndex = {\n    0: isInsert,\n    1: isUpdate,\n    2: isDelete,\n    3: hasLimit,\n    4: isFindOne,\n    5: hasSkip,\n    6: wasResultsEmpty,\n    7: wasLimitReached,\n    8: wasFirst,\n    9: wasLast,\n    10: sortParamsChanged,\n    11: wasInResult,\n    12: wasSortedBeforeFirst,\n    13: wasSortedAfterLast,\n    14: isSortedBeforeFirst,\n    15: isSortedAfterLast,\n    16: wasMatching,\n    17: doesMatchNow\n};\nexport function resolveState(stateName, input) {\n    const fn = stateResolveFunctions[stateName];\n    if (!fn) {\n        throw new Error('resolveState() has no function for ' + stateName);\n    }\n    return fn(input);\n}\nexport function getStateSet(input) {\n    let set = '';\n    for (let i = 0; i < orderedStateList.length; i++) {\n        const name = orderedStateList[i];\n        const value = resolveState(name, input);\n        const add = value ? '1' : '0';\n        set += add;\n    }\n    return set;\n}\nexport function logStateSet(stateSet) {\n    orderedStateList.forEach((state, index) => {\n        console.log('state: ' + state + ' : ' + stateSet[index]);\n    });\n}\n//# sourceMappingURL=index.js.map","import { getProperty, lastOfArray } from '../util.js';\nexport const hasLimit = (input) => {\n    return !!input.queryParams.limit;\n};\nexport const isFindOne = (input) => {\n    return input.queryParams.limit === 1;\n};\nexport const hasSkip = (input) => {\n    if (input.queryParams.skip && input.queryParams.skip > 0) {\n        return true;\n    }\n    else {\n        return false;\n    }\n};\nexport const isDelete = (input) => {\n    return input.changeEvent.operation === 'DELETE';\n};\nexport const isInsert = (input) => {\n    return input.changeEvent.operation === 'INSERT';\n};\nexport const isUpdate = (input) => {\n    return input.changeEvent.operation === 'UPDATE';\n};\nexport const wasLimitReached = (input) => {\n    return hasLimit(input) && input.previousResults.length >= input.queryParams.limit;\n};\nexport const sortParamsChanged = (input) => {\n    const sortFields = input.queryParams.sortFields;\n    const prev = input.changeEvent.previous;\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    if (!prev) {\n        return true;\n    }\n    for (let i = 0; i < sortFields.length; i++) {\n        const field = sortFields[i];\n        const beforeData = getProperty(prev, field);\n        const afterData = getProperty(doc, field);\n        if (beforeData !== afterData) {\n            return true;\n        }\n    }\n    return false;\n};\nexport const wasInResult = (input) => {\n    const id = input.changeEvent.id;\n    if (input.keyDocumentMap) {\n        const has = input.keyDocumentMap.has(id);\n        return has;\n    }\n    else {\n        const primary = input.queryParams.primaryKey;\n        const results = input.previousResults;\n        for (let i = 0; i < results.length; i++) {\n            const item = results[i];\n            if (item[primary] === id) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\nexport const wasFirst = (input) => {\n    const first = input.previousResults[0];\n    if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    else {\n        return false;\n    }\n};\nexport const wasLast = (input) => {\n    const last = lastOfArray(input.previousResults);\n    if (last && last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    else {\n        return false;\n    }\n};\nexport const wasSortedBeforeFirst = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev) {\n        return false;\n    }\n    const first = input.previousResults[0];\n    if (!first) {\n        return false;\n    }\n    /**\n     * If the changed document is the same as the first,\n     * we cannot sort-compare them, because it might end in a non-deterministic\n     * sort order. Because both document could be equal.\n     * So instead we have to return true.\n     */\n    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    const comp = input.queryParams.sortComparator(prev, first);\n    return comp < 0;\n};\nexport const wasSortedAfterLast = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev) {\n        return false;\n    }\n    const last = lastOfArray(input.previousResults);\n    if (!last) {\n        return false;\n    }\n    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    const comp = input.queryParams.sortComparator(prev, last);\n    return comp > 0;\n};\nexport const isSortedBeforeFirst = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    const first = input.previousResults[0];\n    if (!first) {\n        return false;\n    }\n    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    const comp = input.queryParams.sortComparator(doc, first);\n    return comp < 0;\n};\nexport const isSortedAfterLast = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    const last = lastOfArray(input.previousResults);\n    if (!last) {\n        return false;\n    }\n    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    const comp = input.queryParams.sortComparator(doc, last);\n    return comp > 0;\n};\nexport const wasMatching = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev) {\n        return false;\n    }\n    return input.queryParams.queryMatcher(prev);\n};\nexport const doesMatchNow = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    const ret = input.queryParams.queryMatcher(doc);\n    return ret;\n};\nexport const wasResultsEmpty = (input) => {\n    return input.previousResults.length === 0;\n};\n//# sourceMappingURL=state-resolver.js.map","export function lastOfArray(ar) {\n    return ar[ar.length - 1];\n}\n/**\n * @link https://stackoverflow.com/a/5915122\n */\nexport function randomOfArray(items) {\n    return items[Math.floor(Math.random() * items.length)];\n}\nexport function shuffleArray(arr) {\n    return arr.slice().sort(() => (Math.random() - 0.5));\n}\n/**\n * normalizes sort-field\n * in: '-age'\n * out: 'age'\n */\nexport function normalizeSortField(field) {\n    if (field.startsWith('-')) {\n        return field.substr(1);\n    }\n    else {\n        return field;\n    }\n}\nexport function getSortFieldsOfQuery(query) {\n    if (!query.sort) {\n        // if no sort-order is set, use the primary key\n        return ['_id'];\n    }\n    return query.sort.map(maybeArray => {\n        if (Array.isArray(maybeArray)) {\n            return maybeArray[0].map((field) => normalizeSortField(field));\n        }\n        else {\n            return normalizeSortField(maybeArray);\n        }\n    });\n}\n/**\n *  @link https://stackoverflow.com/a/1431113\n */\nexport function replaceCharAt(str, index, replacement) {\n    return str.substr(0, index) + replacement + str.substr(index + replacement.length);\n}\nexport function mapToObject(map) {\n    const ret = {};\n    map.forEach((value, key) => {\n        ret[key] = value;\n    });\n    return ret;\n}\nexport function objectToMap(object) {\n    const ret = new Map();\n    Object.entries(object).forEach(([k, v]) => {\n        ret.set(k, v);\n    });\n    return ret;\n}\nexport function cloneMap(map) {\n    const ret = new Map();\n    map.forEach((value, key) => {\n        ret[key] = value;\n    });\n    return ret;\n}\n/**\n * does a flat copy on the objects,\n * is about 3 times faster then using deepClone\n * @link https://jsperf.com/object-rest-spread-vs-clone/2\n */\nexport function flatClone(obj) {\n    return Object.assign({}, obj);\n}\nexport function ensureNotFalsy(obj) {\n    if (!obj) {\n        throw new Error('ensureNotFalsy() is falsy');\n    }\n    return obj;\n}\nexport function mergeSets(sets) {\n    let ret = new Set();\n    sets.forEach(set => {\n        ret = new Set([...ret, ...set]);\n    });\n    return ret;\n}\n/**\n * @link https://stackoverflow.com/a/12830454/3443137\n */\nexport function roundToTwoDecimals(num) {\n    return parseFloat(num.toFixed(2));\n}\nexport function isObject(value) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\nexport function getProperty(object, path, value) {\n    if (Array.isArray(path)) {\n        path = path.join('.');\n    }\n    if (!isObject(object) || typeof path !== 'string') {\n        return value === undefined ? object : value;\n    }\n    const pathArray = path.split('.');\n    if (pathArray.length === 0) {\n        return value;\n    }\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n        if (isStringIndex(object, key)) {\n            object = index === pathArray.length - 1 ? undefined : null;\n        }\n        else {\n            object = object[key];\n        }\n        if (object === undefined || object === null) {\n            // `object` is either `undefined` or `null` so we want to stop the loop, and\n            // if this is not the last bit of the path, and\n            // if it didn't return `undefined`\n            // it would return `null` if `object` is `null`\n            // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n            if (index !== pathArray.length - 1) {\n                return value;\n            }\n            break;\n        }\n    }\n    return object === undefined ? value : object;\n}\nfunction isStringIndex(object, key) {\n    if (typeof key !== 'number' && Array.isArray(object)) {\n        const index = Number.parseInt(key, 10);\n        return Number.isInteger(index) && object[index] === object[key];\n    }\n    return false;\n}\n//# sourceMappingURL=util.js.map","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict'\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require('./lib/utils')\nconst SCHEMES = require('./lib/schemes')\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(components)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?', components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#', components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host)\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports.default = fastUri\nmodule.exports.fastUri = fastUri\n","'use strict'\n\nconst UUID_REG = /^[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n","'use strict'\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n","'use strict'\n\nconst { HEX } = require('./scopedChars')\n\nconst IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)$/u\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(IPV4_REG) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host)\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","import {\n  getOperator,\n  initOptions,\n  ProcessingMode\n} from \"./core\";\nimport { Lazy } from \"./lazy\";\nimport { assert, cloneDeep, isEmpty } from \"./util\";\nclass Aggregator {\n  #pipeline;\n  #options;\n  constructor(pipeline, options) {\n    this.#pipeline = pipeline;\n    this.#options = initOptions(options);\n  }\n  /**\n   * Returns an {@link Iterator} for lazy evaluation of the pipeline.\n   *\n   * @param collection An array or iterator object\n   * @returns {Iterator} an iterator object\n   */\n  stream(collection, options) {\n    let iter = Lazy(collection);\n    const opts = options ?? this.#options;\n    const mode = opts.processingMode;\n    if (mode & ProcessingMode.CLONE_INPUT) iter.map(cloneDeep);\n    const stages = new Array();\n    if (!isEmpty(this.#pipeline)) {\n      for (const opExpr of this.#pipeline) {\n        const opKeys = Object.keys(opExpr);\n        const opName = opKeys[0];\n        const call = getOperator(\"pipeline\", opName, opts);\n        assert(\n          opKeys.length === 1 && !!call,\n          `invalid pipeline operator ${opName}`\n        );\n        stages.push(opName);\n        iter = call(iter, opExpr[opName], opts);\n      }\n    }\n    if (mode & ProcessingMode.CLONE_OUTPUT) iter.map(cloneDeep);\n    return iter;\n  }\n  /**\n   * Return the results of the aggregation as an array.\n   *\n   * @param collection\n   */\n  run(collection, options) {\n    return this.stream(collection, options).value();\n  }\n}\nexport {\n  Aggregator\n};\n","import {\n  assert,\n  has,\n  isArray,\n  isFunction,\n  isNil,\n  isObject,\n  isOperator,\n  isString,\n  resolve\n} from \"./util\";\nvar ProcessingMode = /* @__PURE__ */ ((ProcessingMode2) => {\n  ProcessingMode2[ProcessingMode2[\"CLONE_OFF\"] = 0] = \"CLONE_OFF\";\n  ProcessingMode2[ProcessingMode2[\"CLONE_INPUT\"] = 1] = \"CLONE_INPUT\";\n  ProcessingMode2[ProcessingMode2[\"CLONE_OUTPUT\"] = 2] = \"CLONE_OUTPUT\";\n  ProcessingMode2[ProcessingMode2[\"CLONE_ALL\"] = 3] = \"CLONE_ALL\";\n  return ProcessingMode2;\n})(ProcessingMode || {});\nclass ComputeOptions {\n  #options;\n  /** Reference to the root object when processing subgraphs of the object. */\n  #root;\n  #local;\n  constructor(options, root, local) {\n    this.#options = options;\n    this.update(root, local);\n  }\n  /**\n   * Initialize new ComputeOptions.\n   * @returns {ComputeOptions}\n   */\n  static init(options, root, local) {\n    return !(options instanceof ComputeOptions) ? new ComputeOptions(options, root, local) : new ComputeOptions(options.#options, options.root ?? root, {\n      ...options.#local,\n      ...local,\n      variables: Object.assign(\n        {},\n        options.#local?.variables,\n        local?.variables\n      )\n    });\n  }\n  /**\n   * Updates the internal state.\n   *\n   * @param root The new root context for this object.\n   * @param local The new local state to merge into current if it exists.\n   * @returns\n   */\n  update(root, local) {\n    this.#root = root;\n    const variables = Object.assign(\n      {},\n      this.#local?.variables,\n      local?.variables\n    );\n    if (Object.keys(variables).length) {\n      this.#local = { ...local, variables };\n    } else {\n      this.#local = local ?? {};\n    }\n    return this;\n  }\n  getOptions() {\n    return Object.freeze({\n      ...this.#options,\n      context: Context.from(this.#options.context)\n    });\n  }\n  get root() {\n    return this.#root;\n  }\n  get local() {\n    return this.#local;\n  }\n  get idKey() {\n    return this.#options.idKey;\n  }\n  get collation() {\n    return this.#options?.collation;\n  }\n  get processingMode() {\n    return this.#options?.processingMode || 0 /* CLONE_OFF */;\n  }\n  get useStrictMode() {\n    return this.#options?.useStrictMode;\n  }\n  get scriptEnabled() {\n    return this.#options?.scriptEnabled;\n  }\n  get useGlobalContext() {\n    return this.#options?.useGlobalContext;\n  }\n  get hashFunction() {\n    return this.#options?.hashFunction;\n  }\n  get collectionResolver() {\n    return this.#options?.collectionResolver;\n  }\n  get jsonSchemaValidator() {\n    return this.#options?.jsonSchemaValidator;\n  }\n  get variables() {\n    return this.#options?.variables;\n  }\n  get context() {\n    return this.#options?.context;\n  }\n}\nfunction initOptions(options) {\n  return options instanceof ComputeOptions ? options.getOptions() : Object.freeze({\n    idKey: \"_id\",\n    scriptEnabled: true,\n    useStrictMode: true,\n    useGlobalContext: true,\n    processingMode: 0 /* CLONE_OFF */,\n    ...options,\n    context: options?.context ? Context.from(options?.context) : Context.init()\n  });\n}\nvar OperatorType = /* @__PURE__ */ ((OperatorType2) => {\n  OperatorType2[\"ACCUMULATOR\"] = \"accumulator\";\n  OperatorType2[\"EXPRESSION\"] = \"expression\";\n  OperatorType2[\"PIPELINE\"] = \"pipeline\";\n  OperatorType2[\"PROJECTION\"] = \"projection\";\n  OperatorType2[\"QUERY\"] = \"query\";\n  OperatorType2[\"WINDOW\"] = \"window\";\n  return OperatorType2;\n})(OperatorType || {});\nclass Context {\n  #operators = /* @__PURE__ */ new Map();\n  constructor() {\n  }\n  static init() {\n    return new Context();\n  }\n  static from(ctx) {\n    const instance = Context.init();\n    if (isNil(ctx)) return instance;\n    ctx.#operators.forEach((v, k) => instance.addOperators(k, v));\n    return instance;\n  }\n  addOperators(type, operators) {\n    if (!this.#operators.has(type)) this.#operators.set(type, {});\n    for (const [name, fn] of Object.entries(operators)) {\n      if (!this.getOperator(type, name)) {\n        this.#operators.get(type)[name] = fn;\n      }\n    }\n    return this;\n  }\n  getOperator(type, name) {\n    const ops = this.#operators.get(type) ?? {};\n    return ops[name] ?? null;\n  }\n  addAccumulatorOps(ops) {\n    return this.addOperators(\"accumulator\", ops);\n  }\n  addExpressionOps(ops) {\n    return this.addOperators(\"expression\", ops);\n  }\n  addQueryOps(ops) {\n    return this.addOperators(\"query\", ops);\n  }\n  addPipelineOps(ops) {\n    return this.addOperators(\"pipeline\", ops);\n  }\n  addProjectionOps(ops) {\n    return this.addOperators(\"projection\", ops);\n  }\n  addWindowOps(ops) {\n    return this.addOperators(\"window\", ops);\n  }\n}\nconst GLOBAL_CONTEXT = Context.init();\nfunction useOperators(type, operators) {\n  for (const [name, fn] of Object.entries(operators)) {\n    assert(\n      isFunction(fn) && isOperator(name),\n      `'${name}' is not a valid operator`\n    );\n    const currentFn = getOperator(type, name, null);\n    assert(\n      !currentFn || fn === currentFn,\n      `${name} already exists for '${type}' operators. Cannot change operator function once registered.`\n    );\n  }\n  switch (type) {\n    case \"accumulator\":\n      GLOBAL_CONTEXT.addAccumulatorOps(operators);\n      break;\n    case \"expression\":\n      GLOBAL_CONTEXT.addExpressionOps(operators);\n      break;\n    case \"pipeline\":\n      GLOBAL_CONTEXT.addPipelineOps(operators);\n      break;\n    case \"projection\":\n      GLOBAL_CONTEXT.addProjectionOps(operators);\n      break;\n    case \"query\":\n      GLOBAL_CONTEXT.addQueryOps(operators);\n      break;\n    case \"window\":\n      GLOBAL_CONTEXT.addWindowOps(operators);\n      break;\n  }\n}\nfunction getOperator(type, name, options) {\n  const { context: ctx, useGlobalContext: fallback } = options || {};\n  const fn = ctx ? ctx.getOperator(type, name) : null;\n  return !fn && fallback ? GLOBAL_CONTEXT.getOperator(type, name) : fn;\n}\nfunction computeValue(obj, expr, operator, options) {\n  const copts = ComputeOptions.init(options, obj);\n  return !!operator && isOperator(operator) ? computeOperator(obj, expr, operator, copts) : computeExpression(obj, expr, copts);\n}\nconst SYSTEM_VARS = [\"$$ROOT\", \"$$CURRENT\", \"$$REMOVE\", \"$$NOW\"];\nfunction computeExpression(obj, expr, options) {\n  if (isString(expr) && expr.length > 0 && expr[0] === \"$\") {\n    if (REDACT_ACTIONS.includes(expr)) return expr;\n    let ctx = options.root;\n    const arr = expr.split(\".\");\n    if (SYSTEM_VARS.includes(arr[0])) {\n      switch (arr[0]) {\n        case \"$$ROOT\":\n          break;\n        case \"$$CURRENT\":\n          ctx = obj;\n          break;\n        case \"$$REMOVE\":\n          ctx = void 0;\n          break;\n        case \"$$NOW\":\n          ctx = /* @__PURE__ */ new Date();\n          break;\n      }\n      expr = expr.slice(arr[0].length + 1);\n    } else if (arr[0].slice(0, 2) === \"$$\") {\n      ctx = Object.assign(\n        {},\n        // global vars\n        options.variables,\n        // current item is added before local variables because the binding may be changed.\n        { this: obj },\n        // local vars\n        options?.local?.variables\n      );\n      const name = arr[0].slice(2);\n      assert(has(ctx, name), `Use of undefined variable: ${name}`);\n      expr = expr.slice(2);\n    } else {\n      expr = expr.slice(1);\n    }\n    return expr === \"\" ? ctx : resolve(ctx, expr);\n  }\n  if (isArray(expr)) {\n    return expr.map((item) => computeExpression(obj, item, options));\n  }\n  if (isObject(expr)) {\n    const result = {};\n    const elems = Object.entries(expr);\n    for (const [key, val] of elems) {\n      if (isOperator(key)) {\n        assert(elems.length == 1, \"expression must have single operator.\");\n        return computeOperator(obj, val, key, options);\n      }\n      result[key] = computeExpression(obj, val, options);\n    }\n    return result;\n  }\n  return expr;\n}\nfunction computeOperator(obj, expr, operator, options) {\n  const callExpression = getOperator(\n    \"expression\",\n    operator,\n    options\n  );\n  if (callExpression) return callExpression(obj, expr, options);\n  const callAccumulator = getOperator(\n    \"accumulator\",\n    operator,\n    options\n  );\n  assert(!!callAccumulator, `accumulator '${operator}' is not registered.`);\n  if (!isArray(obj)) {\n    obj = computeExpression(obj, expr, options);\n    expr = null;\n  }\n  assert(isArray(obj), `arguments must resolve to array for ${operator}.`);\n  return callAccumulator(obj, expr, options);\n}\nconst REDACT_ACTIONS = [\"$$KEEP\", \"$$PRUNE\", \"$$DESCEND\"];\nfunction redact(obj, expr, options) {\n  const action = computeValue(obj, expr, null, options);\n  switch (action) {\n    case \"$$KEEP\":\n      return obj;\n    case \"$$PRUNE\":\n      return void 0;\n    case \"$$DESCEND\": {\n      if (!has(expr, \"$cond\")) return obj;\n      const output = {};\n      for (const [key, value] of Object.entries(obj)) {\n        if (isArray(value)) {\n          const res = new Array();\n          for (let elem of value) {\n            if (isObject(elem)) {\n              elem = redact(elem, expr, options.update(elem));\n            }\n            if (!isNil(elem)) res.push(elem);\n          }\n          output[key] = res;\n        } else if (isObject(value)) {\n          const res = redact(\n            value,\n            expr,\n            options.update(value)\n          );\n          if (!isNil(res)) output[key] = res;\n        } else {\n          output[key] = value;\n        }\n      }\n      return output;\n    }\n    default:\n      return action;\n  }\n}\nexport {\n  ComputeOptions,\n  Context,\n  OperatorType,\n  ProcessingMode,\n  computeValue,\n  getOperator,\n  initOptions,\n  redact,\n  useOperators\n};\n","import {\n  ProcessingMode\n} from \"./core\";\nimport { concat, Lazy } from \"./lazy\";\nimport { $limit } from \"./operators/pipeline/limit\";\nimport { $project } from \"./operators/pipeline/project\";\nimport { $skip } from \"./operators/pipeline/skip\";\nimport { $sort } from \"./operators/pipeline/sort\";\nimport { cloneDeep, has } from \"./util\";\nconst OPERATORS = { $sort, $skip, $limit };\nclass Cursor {\n  #source;\n  #predicate;\n  #projection;\n  #options;\n  #operators = {};\n  #result = null;\n  #buffer = [];\n  constructor(source, predicate, projection, options) {\n    this.#source = source;\n    this.#predicate = predicate;\n    this.#projection = projection;\n    this.#options = options;\n  }\n  /** Returns the iterator from running the query */\n  fetch() {\n    if (this.#result) return this.#result;\n    this.#result = Lazy(this.#source).filter(this.#predicate);\n    const mode = this.#options.processingMode;\n    if (mode & ProcessingMode.CLONE_INPUT) this.#result.map(cloneDeep);\n    for (const op of [\"$sort\", \"$skip\", \"$limit\"]) {\n      if (has(this.#operators, op)) {\n        this.#result = OPERATORS[op](\n          this.#result,\n          this.#operators[op],\n          this.#options\n        );\n      }\n    }\n    if (Object.keys(this.#projection).length) {\n      this.#result = $project(this.#result, this.#projection, this.#options);\n    }\n    if (mode & ProcessingMode.CLONE_OUTPUT) this.#result.map(cloneDeep);\n    return this.#result;\n  }\n  /** Returns an iterator with the buffered data included */\n  fetchAll() {\n    const buffered = Lazy([...this.#buffer]);\n    this.#buffer = [];\n    return concat(buffered, this.fetch());\n  }\n  /**\n   * Return remaining objects in the cursor as an array. This method exhausts the cursor\n   * @returns {Array}\n   */\n  all() {\n    return this.fetchAll().value();\n  }\n  /**\n   * Returns the number of objects return in the cursor. This method exhausts the cursor\n   * @returns {Number}\n   */\n  count() {\n    return this.all().length;\n  }\n  /**\n   * Returns a cursor that begins returning results only after passing or skipping a number of documents.\n   * @param {Number} n the number of results to skip.\n   * @return {Cursor} Returns the cursor, so you can chain this call.\n   */\n  skip(n) {\n    this.#operators[\"$skip\"] = n;\n    return this;\n  }\n  /**\n   * Constrains the size of a cursor's result set.\n   * @param {Number} n the number of results to limit to.\n   * @return {Cursor} Returns the cursor, so you can chain this call.\n   */\n  limit(n) {\n    this.#operators[\"$limit\"] = n;\n    return this;\n  }\n  /**\n   * Returns results ordered according to a sort specification.\n   * @param {AnyObject} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending\n   * @return {Cursor} Returns the cursor, so you can chain this call.\n   */\n  sort(modifier) {\n    this.#operators[\"$sort\"] = modifier;\n    return this;\n  }\n  /**\n   * Specifies the collation for the cursor returned by the `mingo.Query.find`\n   * @param {*} spec\n   */\n  collation(spec) {\n    this.#options = { ...this.#options, collation: spec };\n    return this;\n  }\n  /**\n   * Returns the next document in a cursor.\n   * @returns {AnyObject | Boolean}\n   */\n  next() {\n    if (this.#buffer.length > 0) {\n      return this.#buffer.pop();\n    }\n    const o = this.fetch().next();\n    if (o.done) return;\n    return o.value;\n  }\n  /**\n   * Returns true if the cursor has documents and can be iterated.\n   * @returns {boolean}\n   */\n  hasNext() {\n    if (this.#buffer.length > 0) return true;\n    const o = this.fetch().next();\n    if (o.done) return false;\n    this.#buffer.push(o.value);\n    return true;\n  }\n  /**\n   * Applies a function to each document in a cursor and collects the return values in an array.\n   * @param fn\n   * @returns {Array}\n   */\n  map(fn) {\n    return this.all().map(fn);\n  }\n  /**\n   * Applies a JavaScript function for every document in a cursor.\n   * @param fn\n   */\n  forEach(fn) {\n    this.all().forEach(fn);\n  }\n  [Symbol.iterator]() {\n    return this.fetchAll();\n  }\n}\nexport {\n  Cursor\n};\n","import { isArray, MingoError } from \"./util\";\nfunction Lazy(source) {\n  return source instanceof Iterator ? source : new Iterator(source);\n}\nfunction concat(...iterators) {\n  let index = 0;\n  return Lazy(() => {\n    while (index < iterators.length) {\n      const o = iterators[index].next();\n      if (!o.done) return o;\n      index++;\n    }\n    return { done: true };\n  });\n}\nfunction isGenerator(o) {\n  return !!o && typeof o === \"object\" && o?.next instanceof Function;\n}\nfunction dropItem(array, i) {\n  const rest = array.slice(i + 1);\n  array.splice(i);\n  Array.prototype.push.apply(array, rest);\n}\nconst DONE = new Error();\nvar Action = /* @__PURE__ */ ((Action2) => {\n  Action2[Action2[\"MAP\"] = 0] = \"MAP\";\n  Action2[Action2[\"FILTER\"] = 1] = \"FILTER\";\n  Action2[Action2[\"TAKE\"] = 2] = \"TAKE\";\n  Action2[Action2[\"DROP\"] = 3] = \"DROP\";\n  return Action2;\n})(Action || {});\nfunction createCallback(nextFn, iteratees, buffer) {\n  let done = false;\n  let index = -1;\n  let bufferIndex = 0;\n  return function(storeResult) {\n    try {\n      outer: while (!done) {\n        let o = nextFn();\n        index++;\n        let i = -1;\n        const size = iteratees.length;\n        let innerDone = false;\n        while (++i < size) {\n          const r = iteratees[i];\n          switch (r.action) {\n            case 0 /* MAP */:\n              o = r.func(o, index);\n              break;\n            case 1 /* FILTER */:\n              if (!r.func(o, index)) continue outer;\n              break;\n            case 2 /* TAKE */:\n              --r.count;\n              if (!r.count) innerDone = true;\n              break;\n            case 3 /* DROP */:\n              --r.count;\n              if (!r.count) dropItem(iteratees, i);\n              continue outer;\n            default:\n              break outer;\n          }\n        }\n        done = innerDone;\n        if (storeResult) {\n          buffer[bufferIndex++] = o;\n        } else {\n          return { value: o, done: false };\n        }\n      }\n    } catch (e) {\n      if (e !== DONE) throw e;\n    }\n    done = true;\n    return { done };\n  };\n}\nclass Iterator {\n  /**\n   * @param {*} source An iterable object or function.\n   *    Array - return one element per cycle\n   *    Object{next:Function} - call next() for the next value (this also handles generator functions)\n   *    Function - call to return the next value\n   * @param {Function} fn An optional transformation function\n   */\n  constructor(source) {\n    this.#iteratees = [];\n    this.#yieldedValues = [];\n    this.isDone = false;\n    let nextVal;\n    if (source instanceof Function) {\n      source = { next: source };\n    }\n    if (isGenerator(source)) {\n      const src = source;\n      nextVal = () => {\n        const o = src.next();\n        if (o.done) throw DONE;\n        return o.value;\n      };\n    } else if (isArray(source)) {\n      const data = source;\n      const size = data.length;\n      let index = 0;\n      nextVal = () => {\n        if (index < size) return data[index++];\n        throw DONE;\n      };\n    } else if (!(source instanceof Function)) {\n      throw new MingoError(\n        `Lazy must be initialized with an array, generator, or function.`\n      );\n    }\n    this.#getNext = createCallback(\n      nextVal,\n      this.#iteratees,\n      this.#yieldedValues\n    );\n  }\n  #iteratees;\n  #yieldedValues;\n  #getNext;\n  /**\n   * Add an iteratee to this lazy sequence\n   */\n  push(action, value) {\n    if (typeof value === \"function\") {\n      this.#iteratees.push({ action, func: value });\n    } else if (typeof value === \"number\") {\n      this.#iteratees.push({ action, count: value });\n    }\n    return this;\n  }\n  next() {\n    return this.#getNext();\n  }\n  // Iteratees methods\n  /**\n   * Transform each item in the sequence to a new value\n   * @param {Function} f\n   */\n  map(f) {\n    return this.push(0 /* MAP */, f);\n  }\n  /**\n   * Select only items matching the given predicate\n   * @param {Function} pred\n   */\n  filter(predicate) {\n    return this.push(1 /* FILTER */, predicate);\n  }\n  /**\n   * Take given numbe for values from sequence\n   * @param {Number} n A number greater than 0\n   */\n  take(n) {\n    return n > 0 ? this.push(2 /* TAKE */, n) : this;\n  }\n  /**\n   * Drop a number of values from the sequence\n   * @param {Number} n Number of items to drop greater than 0\n   */\n  drop(n) {\n    return n > 0 ? this.push(3 /* DROP */, n) : this;\n  }\n  // Transformations\n  /**\n   * Returns a new lazy object with results of the transformation\n   * The entire sequence is realized.\n   *\n   * @param {Callback<Source, Any[]>} fn Tranform function of type (Array) => (Any)\n   */\n  transform(fn) {\n    const self = this;\n    let iter;\n    return Lazy(() => {\n      if (!iter) {\n        iter = Lazy(fn(self.value()));\n      }\n      return iter.next();\n    });\n  }\n  // Terminal methods\n  /**\n   * Returns the fully realized values of the iterators.\n   * The return value will be an array unless `lazy.first()` was used.\n   * The realized values are cached for subsequent calls.\n   */\n  value() {\n    if (!this.isDone) {\n      this.isDone = this.#getNext(true).done;\n    }\n    return this.#yieldedValues;\n  }\n  /**\n   * Execute the funcion for each value. Will stop when an execution returns false.\n   * @param {Function} f\n   * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true\n   */\n  each(f) {\n    for (; ; ) {\n      const o = this.next();\n      if (o.done) break;\n      if (f(o.value) === false) return false;\n    }\n    return true;\n  }\n  /**\n   * Returns the reduction of sequence according the reducing function\n   *\n   * @param {*} f a reducing function\n   * @param {*} initialValue\n   */\n  reduce(f, initialValue) {\n    let o = this.next();\n    if (initialValue === void 0 && !o.done) {\n      initialValue = o.value;\n      o = this.next();\n    }\n    while (!o.done) {\n      initialValue = f(initialValue, o.value);\n      o = this.next();\n    }\n    return initialValue;\n  }\n  /**\n   * Returns the number of matched items in the sequence\n   */\n  size() {\n    return this.reduce(\n      (acc, _) => ++acc,\n      0\n    );\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n}\nexport {\n  Iterator,\n  Lazy,\n  concat\n};\n","import {\n  computeValue\n} from \"../core\";\nimport { Query } from \"../query\";\nimport {\n  compare as mingoCmp,\n  ensureArray,\n  flatten,\n  intersection,\n  isArray,\n  isBoolean,\n  isDate,\n  isEmpty,\n  isEqual,\n  isNil,\n  isNumber,\n  isObject,\n  isOperator,\n  isRegExp,\n  isString,\n  MingoError,\n  resolve,\n  truthy,\n  typeOf\n} from \"../util\";\nfunction createQueryOperator(predicate) {\n  const f = (selector, value, options) => {\n    const opts = { unwrapArray: true };\n    const depth = Math.max(1, selector.split(\".\").length - 1);\n    return (obj) => {\n      const lhs = resolve(obj, selector, opts);\n      return predicate(lhs, value, { ...options, depth });\n    };\n  };\n  return f;\n}\nfunction createExpressionOperator(predicate) {\n  return (obj, expr, options) => {\n    const args = computeValue(obj, expr, null, options);\n    return predicate(...args);\n  };\n}\nfunction $eq(a, b, options) {\n  if (isEqual(a, b)) return true;\n  if (isNil(a) && isNil(b)) return true;\n  if (isArray(a)) {\n    return a.some((v) => isEqual(v, b)) || flatten(a, options?.depth).some((v) => isEqual(v, b));\n  }\n  return false;\n}\nfunction $ne(a, b, options) {\n  return !$eq(a, b, options);\n}\nfunction $in(a, b, options) {\n  if (isNil(a)) return b.some((v) => v === null);\n  return intersection([ensureArray(a), b], options?.hashFunction).length > 0;\n}\nfunction $nin(a, b, options) {\n  return !$in(a, b, options);\n}\nfunction $lt(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) < 0);\n}\nfunction $lte(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) <= 0);\n}\nfunction $gt(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) > 0);\n}\nfunction $gte(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) >= 0);\n}\nfunction $mod(a, b, _options) {\n  return ensureArray(a).some(\n    (x) => b.length === 2 && x % b[0] === b[1]\n  );\n}\nfunction $regex(a, b, options) {\n  const lhs = ensureArray(a);\n  const match = (x) => isString(x) && truthy(b.exec(x), options?.useStrictMode);\n  return lhs.some(match) || flatten(lhs, 1).some(match);\n}\nfunction $all(values, queries, options) {\n  if (!isArray(values) || !isArray(queries) || !values.length || !queries.length) {\n    return false;\n  }\n  let matched = true;\n  for (const query of queries) {\n    if (!matched) break;\n    if (isObject(query) && Object.keys(query).includes(\"$elemMatch\")) {\n      matched = $elemMatch(values, query[\"$elemMatch\"], options);\n    } else if (isRegExp(query)) {\n      matched = values.some((s) => typeof s === \"string\" && query.test(s));\n    } else {\n      matched = values.some((v) => isEqual(query, v));\n    }\n  }\n  return matched;\n}\nfunction $size(a, b, _options) {\n  return Array.isArray(a) && a.length === b;\n}\nfunction isNonBooleanOperator(name) {\n  return isOperator(name) && [\"$and\", \"$or\", \"$nor\"].indexOf(name) === -1;\n}\nfunction $elemMatch(a, b, options) {\n  if (isArray(a) && !isEmpty(a)) {\n    let format = (x) => x;\n    let criteria = b;\n    if (Object.keys(b).every(isNonBooleanOperator)) {\n      criteria = { temp: b };\n      format = (x) => ({ temp: x });\n    }\n    const query = new Query(criteria, options);\n    for (let i = 0, len = a.length; i < len; i++) {\n      if (query.test(format(a[i]))) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nconst isNull = (a) => a === null;\nconst compareFuncs = {\n  array: isArray,\n  boolean: isBoolean,\n  bool: isBoolean,\n  date: isDate,\n  number: isNumber,\n  int: isNumber,\n  long: isNumber,\n  double: isNumber,\n  decimal: isNumber,\n  null: isNull,\n  object: isObject,\n  regexp: isRegExp,\n  regex: isRegExp,\n  string: isString,\n  // added for completeness\n  undefined: isNil,\n  // deprecated\n  function: (_) => {\n    throw new MingoError(\"unsupported type key `function`.\");\n  },\n  // Mongo identifiers\n  1: isNumber,\n  //double\n  2: isString,\n  3: isObject,\n  4: isArray,\n  6: isNil,\n  // deprecated\n  8: isBoolean,\n  9: isDate,\n  10: isNull,\n  11: isRegExp,\n  16: isNumber,\n  //int\n  18: isNumber,\n  //long\n  19: isNumber\n  //decimal\n};\nfunction compareType(a, b, _) {\n  const f = compareFuncs[b];\n  return f ? f(a) : false;\n}\nfunction $type(a, b, options) {\n  return isArray(b) ? b.findIndex((t) => compareType(a, t, options)) >= 0 : compareType(a, b, options);\n}\nfunction compare(a, b, f) {\n  return ensureArray(a).some((x) => typeOf(x) === typeOf(b) && f(x, b));\n}\nexport {\n  $all,\n  $elemMatch,\n  $eq,\n  $gt,\n  $gte,\n  $in,\n  $lt,\n  $lte,\n  $mod,\n  $ne,\n  $nin,\n  $regex,\n  $size,\n  $type,\n  createExpressionOperator,\n  createQueryOperator\n};\n","function stddev(data, sampled = true) {\n  const sum = data.reduce((acc, n) => acc + n, 0);\n  const N = data.length || 1;\n  const avg = sum / N;\n  return Math.sqrt(\n    data.reduce((acc, n) => acc + Math.pow(n - avg, 2), 0) / (N - Number(sampled))\n  );\n}\nfunction covariance(dataset, sampled = true) {\n  if (!dataset) return null;\n  if (dataset.length < 2) return sampled ? null : 0;\n  let meanX = 0;\n  let meanY = 0;\n  for (const [x, y] of dataset) {\n    meanX += x;\n    meanY += y;\n  }\n  meanX /= dataset.length;\n  meanY /= dataset.length;\n  let result = 0;\n  for (const [x, y] of dataset) {\n    result += (x - meanX) * (y - meanY);\n  }\n  return result / (dataset.length - Number(sampled));\n}\nexport {\n  covariance,\n  stddev\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../core\";\nimport { assert } from \"../../util\";\nconst $accumulator = (collection, expr, options) => {\n  assert(\n    !!options && options.scriptEnabled,\n    \"$accumulator operator requires 'scriptEnabled' option to be true\"\n  );\n  if (collection.length == 0) return expr.initArgs;\n  const copts = ComputeOptions.init(options);\n  const initArgs = computeValue(\n    {},\n    expr.initArgs || [],\n    null,\n    copts.update(copts?.local?.groupId || {})\n  );\n  let state = expr.init.call(null, ...initArgs);\n  for (const doc of collection) {\n    const args = computeValue(\n      doc,\n      expr.accumulateArgs,\n      null,\n      copts.update(doc)\n    );\n    state = expr.accumulate.call(null, ...[state, ...args]);\n  }\n  return expr.finalize ? expr.finalize.call(null, state) : state;\n};\nexport {\n  $accumulator\n};\n","import { unique } from \"../../util\";\nimport { $push } from \"./push\";\nconst $addToSet = (collection, expr, options) => {\n  return unique(\n    $push(collection, expr, options),\n    options?.hashFunction\n  );\n};\nexport {\n  $addToSet\n};\n","import { isNumber } from \"../../util\";\nimport { $push } from \"./push\";\nconst $avg = (collection, expr, options) => {\n  const data = $push(collection, expr, options).filter(isNumber);\n  const sum = data.reduce((acc, n) => acc + n, 0);\n  return sum / (data.length || 1);\n};\nexport {\n  $avg\n};\n","import { $bottomN } from \"./bottomN\";\nconst $bottom = (collection, expr, options) => $bottomN(collection, { ...expr, n: 1 }, options);\nexport {\n  $bottom\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../core\";\nimport { Lazy } from \"../../lazy\";\nimport { $sort } from \"../pipeline/sort\";\nimport { $push } from \"./push\";\nconst $bottomN = (collection, expr, options) => {\n  const copts = ComputeOptions.init(options);\n  const { n, sortBy } = computeValue(\n    copts.local.groupId,\n    expr,\n    null,\n    copts\n  );\n  const result = $sort(Lazy(collection), sortBy, options).value();\n  const m = result.length;\n  const p = n;\n  return $push(m <= p ? result : result.slice(m - p), expr.output, copts);\n};\nexport {\n  $bottomN\n};\n","const $count = (collection, _expr, _options) => collection.length;\nexport {\n  $count\n};\n","import { covariance } from \"./_internal\";\nimport { $push } from \"./push\";\nconst $covariancePop = (collection, expr, options) => covariance($push(collection, expr, options), false);\nexport {\n  $covariancePop\n};\n","import { covariance } from \"./_internal\";\nimport { $push } from \"./push\";\nconst $covarianceSamp = (collection, expr, options) => covariance($push(collection, expr, options), true);\nexport {\n  $covarianceSamp\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../core\";\nconst $first = (collection, expr, options) => {\n  if (collection.length === 0) return void 0;\n  const copts = ComputeOptions.init(options).update(collection[0]);\n  return computeValue(collection[0], expr, null, copts);\n};\nexport {\n  $first\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../core\";\nimport { $push } from \"./push\";\nconst $firstN = (collection, expr, options) => {\n  const copts = ComputeOptions.init(options);\n  const m = collection.length;\n  const n = computeValue(copts?.local?.groupId, expr.n, null, copts);\n  return $push(\n    m <= n ? collection : collection.slice(0, n),\n    expr.input,\n    options\n  );\n};\nexport {\n  $firstN\n};\n","export * from \"./accumulator\";\nexport * from \"./addToSet\";\nexport * from \"./avg\";\nexport * from \"./bottom\";\nexport * from \"./bottomN\";\nexport * from \"./count\";\nexport * from \"./covariancePop\";\nexport * from \"./covarianceSamp\";\nexport * from \"./first\";\nexport * from \"./firstN\";\nexport * from \"./last\";\nexport * from \"./lastN\";\nexport * from \"./max\";\nexport * from \"./maxN\";\nexport * from \"./median\";\nexport * from \"./mergeObjects\";\nexport * from \"./min\";\nexport * from \"./minN\";\nexport * from \"./percentile\";\nexport * from \"./push\";\nexport * from \"./stdDevPop\";\nexport * from \"./stdDevSamp\";\nexport * from \"./sum\";\nexport * from \"./top\";\nexport * from \"./topN\";\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../core\";\nconst $last = (collection, expr, options) => {\n  if (collection.length === 0) return void 0;\n  const obj = collection[collection.length - 1];\n  const copts = ComputeOptions.init(options).update(obj);\n  return computeValue(obj, expr, null, copts);\n};\nexport {\n  $last\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../core\";\nimport { $push } from \"./push\";\nconst $lastN = (collection, expr, options) => {\n  const copts = ComputeOptions.init(options);\n  const m = collection.length;\n  const n = computeValue(copts?.local?.groupId, expr.n, null, copts);\n  return $push(\n    m <= n ? collection : collection.slice(m - n),\n    expr.input,\n    options\n  );\n};\nexport {\n  $lastN\n};\n","import { assert, compare, isArray, isEmpty, isNil } from \"../../util\";\nimport { $push } from \"./push\";\nconst $max = (collection, expr, options) => {\n  const items = $push(collection, expr, options);\n  if (isEmpty(items)) return null;\n  assert(isArray(items), \"$max: input must resolve to array\");\n  let max = items[0];\n  for (const n of items) {\n    if (isNil(n) || isNaN(n)) continue;\n    if (compare(n, max) >= 0) max = n;\n  }\n  return max;\n};\nexport {\n  $max\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../core\";\nimport { compare, isNil } from \"../../util\";\nimport { $push } from \"./push\";\nconst $maxN = (collection, expr, options) => {\n  const copts = ComputeOptions.init(options);\n  const m = collection.length;\n  const n = computeValue(copts?.local?.groupId, expr.n, null, copts);\n  const arr = $push(collection, expr.input, options).filter((o) => !isNil(o));\n  arr.sort((a, b) => -1 * compare(a, b));\n  return m <= n ? arr : arr.slice(0, n);\n};\nexport {\n  $maxN\n};\n","import { $percentile } from \"./percentile\";\nconst $median = (collection, expr, options) => $percentile(collection, { ...expr, p: [0.5] }, options).pop();\nexport {\n  $median\n};\n","import { computeValue } from \"../../core\";\nimport { $mergeObjects as __mergeObjects } from \"../expression/object/mergeObjects\";\nconst $mergeObjects = (collection, expr, options) => {\n  const arr = computeValue(collection, expr, null, options);\n  return __mergeObjects(null, arr, options);\n};\nexport {\n  $mergeObjects\n};\n","import { assert, compare, isArray, isEmpty, isNil } from \"../../util\";\nimport { $push } from \"./push\";\nconst $min = (collection, expr, options) => {\n  const items = $push(collection, expr, options);\n  if (isEmpty(items)) return null;\n  assert(isArray(items), \"$min: input must resolve to array\");\n  let min = items[0];\n  for (const n of items) {\n    if (isNil(n) || isNaN(n)) continue;\n    if (compare(n, min) <= 0) min = n;\n  }\n  return min;\n};\nexport {\n  $min\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../core\";\nimport { compare, isNil } from \"../../util\";\nimport { $push } from \"./push\";\nconst $minN = (collection, expr, options) => {\n  const copts = ComputeOptions.init(options);\n  const m = collection.length;\n  const n = computeValue(copts?.local?.groupId, expr.n, null, copts);\n  const arr = $push(collection, expr.input, options).filter((o) => !isNil(o));\n  arr.sort(compare);\n  return m <= n ? arr : arr.slice(0, n);\n};\nexport {\n  $minN\n};\n","import { assert, findInsertIndex, isNumber } from \"../../util\";\nimport { $push } from \"./push\";\nconst $percentile = (collection, expr, options) => {\n  const X = $push(collection, expr.input, options).filter(isNumber).sort();\n  const centiles = $push(expr.p, \"$$CURRENT\", options).filter(isNumber);\n  const method = expr.method || \"approximate\";\n  return centiles.map((p) => {\n    assert(\n      p > 0 && p <= 1,\n      `percentile value must be between 0 (exclusive) and 1 (inclusive): invalid '${p}'.`\n    );\n    const r = p * (X.length - 1) + 1;\n    const ri = Math.floor(r);\n    const result = r === ri ? X[r - 1] : X[ri - 1] + r % 1 * (X[ri] - X[ri - 1] || 0);\n    switch (method) {\n      case \"exact\":\n        return result;\n      case \"approximate\": {\n        const i = findInsertIndex(X, result);\n        return i / X.length >= p ? X[Math.max(i - 1, 0)] : X[i];\n      }\n    }\n  });\n};\nexport {\n  $percentile\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../core\";\nimport { isNil } from \"../../util\";\nconst $push = (collection, expr, options) => {\n  if (isNil(expr)) return collection;\n  const copts = ComputeOptions.init(options);\n  return collection.map(\n    (obj) => computeValue(obj, expr, null, copts.update(obj))\n  );\n};\nexport {\n  $push\n};\n","import { isNumber } from \"../../util\";\nimport { stddev } from \"./_internal\";\nimport { $push } from \"./push\";\nconst $stdDevPop = (collection, expr, options) => stddev($push(collection, expr, options).filter(isNumber), false);\nexport {\n  $stdDevPop\n};\n","import { isNumber } from \"../../util\";\nimport { stddev } from \"./_internal\";\nimport { $push } from \"./push\";\nconst $stdDevSamp = (collection, expr, options) => stddev($push(collection, expr, options).filter(isNumber), true);\nexport {\n  $stdDevSamp\n};\n","import { isArray, isNumber } from \"../../util\";\nimport { $push } from \"./push\";\nconst $sum = (collection, expr, options) => {\n  if (!isArray(collection)) return 0;\n  if (isNumber(expr)) return collection.length * expr;\n  const nums = $push(collection, expr, options).filter(isNumber);\n  return nums.reduce((acc, n) => acc + n, 0);\n};\nexport {\n  $sum\n};\n","import { $topN } from \"./topN\";\nconst $top = (collection, expr, options) => $topN(collection, { ...expr, n: 1 }, options);\nexport {\n  $top\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../core\";\nimport { Lazy } from \"../../lazy\";\nimport { $sort } from \"../pipeline/sort\";\nimport { $push } from \"./push\";\nconst $topN = (collection, expr, options) => {\n  const copts = ComputeOptions.init(options);\n  const { n, sortBy } = computeValue(\n    copts.local.groupId,\n    expr,\n    null,\n    copts\n  );\n  const result = $sort(Lazy(collection), sortBy, options).take(n).value();\n  return $push(result, expr.output, copts);\n};\nexport {\n  $topN\n};\n","function truncate(num, places = 0, roundOff = false) {\n  const sign = Math.abs(num) === num ? 1 : -1;\n  num = Math.abs(num);\n  let result = Math.trunc(num);\n  const decimals = parseFloat((num - result).toFixed(places + 1));\n  if (places === 0) {\n    const firstDigit = Math.trunc(10 * decimals);\n    if (roundOff && ((result & 1) === 1 && firstDigit >= 5 || firstDigit > 5)) {\n      result++;\n    }\n  } else if (places > 0) {\n    const offset = Math.pow(10, places);\n    let remainder = Math.trunc(decimals * offset);\n    const lastDigit = Math.trunc(decimals * offset * 10) % 10;\n    if (roundOff && lastDigit > 5) {\n      remainder += 1;\n    }\n    result = (result * offset + remainder) / offset;\n  } else if (places < 0) {\n    const offset = Math.pow(10, -1 * places);\n    let excess = result % offset;\n    result = Math.max(0, result - excess);\n    if (roundOff && sign === -1) {\n      while (excess > 10) {\n        excess -= excess % 10;\n      }\n      if (result > 0 && excess >= 5) {\n        result += offset;\n      }\n    }\n  }\n  return result * sign;\n}\nexport {\n  truncate\n};\n","import { computeValue } from \"../../../core\";\nimport { isNil } from \"../../../util\";\nconst $abs = (obj, expr, options) => {\n  const n = computeValue(obj, expr, null, options);\n  return isNil(n) ? null : Math.abs(n);\n};\nexport {\n  $abs\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isDate } from \"../../../util\";\nconst $add = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  let hasDate = false;\n  let sum = 0;\n  for (const n of args) {\n    if (isDate(n)) {\n      assert(!hasDate, \"'$add' can only have one date value\");\n      hasDate = true;\n    }\n    sum += +n;\n  }\n  return hasDate ? new Date(sum) : sum;\n};\nexport {\n  $add\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isNumber } from \"../../../util\";\nconst $ceil = (obj, expr, options) => {\n  const n = computeValue(obj, expr, null, options);\n  if (isNil(n)) return null;\n  assert(isNumber(n) || isNaN(n), \"$ceil expression must resolve to a number.\");\n  return Math.ceil(n);\n};\nexport {\n  $ceil\n};\n","import { computeValue } from \"../../../core\";\nconst $divide = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  return args[0] / args[1];\n};\nexport {\n  $divide\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isNumber } from \"../../../util\";\nconst $exp = (obj, expr, options) => {\n  const n = computeValue(obj, expr, null, options);\n  if (isNil(n)) return null;\n  assert(isNumber(n) || isNaN(n), \"$exp expression must resolve to a number.\");\n  return Math.exp(n);\n};\nexport {\n  $exp\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isNumber } from \"../../../util\";\nconst $floor = (obj, expr, options) => {\n  const n = computeValue(obj, expr, null, options);\n  if (isNil(n)) return null;\n  assert(\n    isNumber(n) || isNaN(n),\n    \"$floor expression must resolve to a number.\"\n  );\n  return Math.floor(n);\n};\nexport {\n  $floor\n};\n","export * from \"./abs\";\nexport * from \"./add\";\nexport * from \"./ceil\";\nexport * from \"./divide\";\nexport * from \"./exp\";\nexport * from \"./floor\";\nexport * from \"./ln\";\nexport * from \"./log\";\nexport * from \"./log10\";\nexport * from \"./mod\";\nexport * from \"./multiply\";\nexport * from \"./pow\";\nexport * from \"./round\";\nexport * from \"./sqrt\";\nexport * from \"./subtract\";\nexport * from \"./trunc\";\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isNumber } from \"../../../util\";\nconst $ln = (obj, expr, options) => {\n  const n = computeValue(obj, expr, null, options);\n  if (isNil(n)) return null;\n  assert(isNumber(n) || isNaN(n), \"$ln expression must resolve to a number.\");\n  return Math.log(n);\n};\nexport {\n  $ln\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil, isNumber } from \"../../../util\";\nconst $log = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const msg = \"$log expression must resolve to array(2) of numbers\";\n  assert(isArray(args) && args.length === 2, msg);\n  if (args.some(isNil)) return null;\n  assert(args.some(isNaN) || args.every(isNumber), msg);\n  return Math.log10(args[0]) / Math.log10(args[1]);\n};\nexport {\n  $log\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isNumber } from \"../../../util\";\nconst $log10 = (obj, expr, options) => {\n  const n = computeValue(obj, expr, null, options);\n  if (isNil(n)) return null;\n  assert(\n    isNumber(n) || isNaN(n),\n    \"$log10 expression must resolve to a number.\"\n  );\n  return Math.log10(n);\n};\nexport {\n  $log10\n};\n","import { computeValue } from \"../../../core\";\nconst $mod = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  return args[0] % args[1];\n};\nexport {\n  $mod\n};\n","import { computeValue } from \"../../../core\";\nconst $multiply = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  return args.reduce((acc, num) => acc * num, 1);\n};\nexport {\n  $multiply\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNumber } from \"../../../util\";\nconst $pow = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  assert(\n    isArray(args) && args.length === 2 && args.every(isNumber),\n    \"$pow expression must resolve to array(2) of numbers\"\n  );\n  assert(\n    !(args[0] === 0 && args[1] < 0),\n    \"$pow cannot raise 0 to a negative exponent\"\n  );\n  return Math.pow(args[0], args[1]);\n};\nexport {\n  $pow\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isNumber } from \"../../../util\";\nimport { truncate } from \"./_internal\";\nconst $round = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const num = args[0];\n  const place = args[1];\n  if (isNil(num) || isNaN(num) || Math.abs(num) === Infinity) return num;\n  assert(isNumber(num), \"$round expression must resolve to a number.\");\n  return truncate(num, place, true);\n};\nexport {\n  $round\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isNumber } from \"../../../util\";\nconst $sqrt = (obj, expr, options) => {\n  const n = computeValue(obj, expr, null, options);\n  if (isNil(n)) return null;\n  assert(\n    isNumber(n) && n > 0 || isNaN(n),\n    \"$sqrt expression must resolve to non-negative number.\"\n  );\n  return Math.sqrt(n);\n};\nexport {\n  $sqrt\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isDate, isNumber } from \"../../../util\";\nconst $subtract = (obj, expr, options) => {\n  const [a, b] = computeValue(obj, expr, null, options);\n  if (isNumber(a) && isNumber(b) || isDate(a) && isDate(b)) return +a - +b;\n  if (isDate(a) && isNumber(b)) return new Date(+a - b);\n  assert(false, \"$subtract: must resolve to number/date.\");\n};\nexport {\n  $subtract\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isNumber } from \"../../../util\";\nimport { truncate } from \"./_internal\";\nconst $trunc = (obj, expr, options) => {\n  const arr = computeValue(obj, expr, null, options);\n  const num = arr[0];\n  const places = arr[1];\n  if (isNil(num) || isNaN(num) || Math.abs(num) === Infinity) return num;\n  assert(isNumber(num), \"$trunc expression must resolve to a number.\");\n  assert(\n    isNil(places) || isNumber(places) && places > -20 && places < 100,\n    \"$trunc expression has invalid place\"\n  );\n  return truncate(num, places, false);\n};\nexport {\n  $trunc\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil } from \"../../../util\";\nconst $arrayElemAt = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  assert(\n    isArray(args) && args.length === 2,\n    \"$arrayElemAt expression must resolve to array(2)\"\n  );\n  if (args.some(isNil)) return null;\n  const index = args[1];\n  const arr = args[0];\n  if (index < 0 && Math.abs(index) <= arr.length) {\n    return arr[(index + arr.length) % arr.length];\n  } else if (index >= 0 && index < arr.length) {\n    return arr[index];\n  }\n  return void 0;\n};\nexport {\n  $arrayElemAt\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, has, isArray, isObject } from \"../../../util\";\nconst $arrayToObject = (obj, expr, options) => {\n  const arr = computeValue(obj, expr, null, options);\n  assert(isArray(arr), \"$arrayToObject: expression must resolve to an array\");\n  return arr.reduce((newObj, val) => {\n    while (isArray(val) && val.length === 1) val = val[0];\n    if (isArray(val) && val.length == 2) {\n      newObj[val[0]] = val[1];\n    } else {\n      const valObj = val;\n      assert(\n        isObject(valObj) && has(valObj, \"k\") && has(valObj, \"v\"),\n        \"$arrayToObject expression is invalid.\"\n      );\n      newObj[valObj.k] = valObj.v;\n    }\n    return newObj;\n  }, {});\n};\nexport {\n  $arrayToObject\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil } from \"../../../util\";\nconst $concatArrays = (obj, expr, options) => {\n  const nArray = computeValue(obj, expr, null, options);\n  assert(isArray(nArray), \"$concatArrays: input must resolve to an array\");\n  let size = 0;\n  for (const arr of nArray) {\n    if (isNil(arr)) return null;\n    size += arr.length;\n  }\n  const result = new Array(size);\n  let i = 0;\n  for (const arr of nArray) for (const item of arr) result[i++] = item;\n  return result;\n};\nexport {\n  $concatArrays\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../../core\";\nimport { assert, isArray, isNil, truthy } from \"../../../util\";\nconst $filter = (obj, expr, options) => {\n  const input = computeValue(obj, expr.input, null, options);\n  if (isNil(input)) return null;\n  assert(isArray(input), \"$filter 'input' expression must resolve to an array\");\n  const copts = ComputeOptions.init(options, obj);\n  const k = expr.as || \"this\";\n  const local = {\n    variables: { [k]: null }\n  };\n  return input.filter((o) => {\n    local.variables[k] = o;\n    const b = computeValue(\n      obj,\n      expr.cond,\n      null,\n      copts.update(copts.root, local)\n    );\n    return truthy(b, options.useStrictMode);\n  });\n};\nexport {\n  $filter\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, flatten, isArray, isNil } from \"../../../util\";\nimport { $first as __first } from \"../../accumulator/first\";\nconst $first = (obj, expr, options) => {\n  if (isArray(obj)) return __first(obj, expr, options);\n  const arr = computeValue(obj, expr, null, options);\n  if (isNil(arr)) return null;\n  assert(\n    isArray(arr) && arr.length > 0,\n    \"$first must resolve to a non-empty array.\"\n  );\n  return flatten(arr)[0];\n};\nexport {\n  $first\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil } from \"../../../util\";\nimport { $firstN as __firstN } from \"../../accumulator/firstN\";\nconst $firstN = (obj, expr, options) => {\n  if (isArray(obj)) return __firstN(obj, expr, options);\n  const { input, n } = computeValue(obj, expr, null, options);\n  if (isNil(input)) return null;\n  assert(isArray(input), \"Must resolve to an array/null or missing\");\n  return __firstN(input, { n, input: \"$$this\" }, options);\n};\nexport {\n  $firstN\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isEqual } from \"../../../util\";\nconst $in = (obj, expr, options) => {\n  const [item, arr] = computeValue(obj, expr, null, options);\n  assert(isArray(arr), \"$in second argument must be an array\");\n  return arr.some((v) => isEqual(v, item));\n};\nexport {\n  $in\n};\n","export * from \"./arrayElemAt\";\nexport * from \"./arrayToObject\";\nexport * from \"./concatArrays\";\nexport * from \"./filter\";\nexport * from \"./first\";\nexport * from \"./firstN\";\nexport * from \"./in\";\nexport * from \"./indexOfArray\";\nexport * from \"./isArray\";\nexport * from \"./last\";\nexport * from \"./lastN\";\nexport * from \"./map\";\nexport * from \"./maxN\";\nexport * from \"./minN\";\nexport * from \"./nin\";\nexport * from \"./range\";\nexport * from \"./reduce\";\nexport * from \"./reverseArray\";\nexport * from \"./size\";\nexport * from \"./slice\";\nexport * from \"./sortArray\";\nexport * from \"./zip\";\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isEqual, isNil } from \"../../../util\";\nconst $indexOfArray = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  if (isNil(args)) return null;\n  let arr = args[0];\n  const searchValue = args[1];\n  if (isNil(arr)) return null;\n  assert(isArray(arr), \"$indexOfArray expression must resolve to an array.\");\n  const start = args[2] || 0;\n  let end = args[3];\n  if (isNil(end)) end = arr.length;\n  if (start > end) return -1;\n  assert(start >= 0 && end >= 0, \"$indexOfArray expression is invalid\");\n  if (start > 0 || end < arr.length) {\n    arr = arr.slice(start, end);\n  }\n  let index = -1;\n  arr.some((v, i) => {\n    const b = isEqual(v, searchValue);\n    if (b) index = i;\n    return b;\n  });\n  return index + start;\n};\nexport {\n  $indexOfArray\n};\n","import { computeValue } from \"../../../core\";\nimport { isArray } from \"../../../util\";\nconst $isArray = (obj, expr, options) => isArray(computeValue(obj, expr[0], null, options));\nexport {\n  $isArray\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, flatten, isArray, isNil } from \"../../../util\";\nimport { $last as __last } from \"../../accumulator/last\";\nconst $last = (obj, expr, options) => {\n  if (isArray(obj)) return __last(obj, expr, options);\n  const arr = computeValue(obj, expr, null, options);\n  if (isNil(arr)) return null;\n  assert(\n    isArray(arr) && arr.length > 0,\n    \"$last must resolve to a non-empty array.\"\n  );\n  return flatten(arr)[arr.length - 1];\n};\nexport {\n  $last\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil } from \"../../../util\";\nimport { $lastN as __lastN } from \"../../accumulator/lastN\";\nconst $lastN = (obj, expr, options) => {\n  if (isArray(obj)) return __lastN(obj, expr, options);\n  const { input, n } = computeValue(obj, expr, null, options);\n  if (isNil(input)) return null;\n  assert(isArray(input), \"Must resolve to an array/null or missing\");\n  return __lastN(input, { n, input: \"$$this\" }, options);\n};\nexport {\n  $lastN\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../../core\";\nimport { assert, isArray, isNil } from \"../../../util\";\nconst $map = (obj, expr, options) => {\n  const input = computeValue(obj, expr.input, null, options);\n  if (isNil(input)) return null;\n  assert(isArray(input), `$map 'input' expression must resolve to an array`);\n  const copts = ComputeOptions.init(options);\n  const k = expr.as || \"this\";\n  return input.map((o) => {\n    return computeValue(\n      obj,\n      expr.in,\n      null,\n      copts.update(copts.root, {\n        variables: { [k]: o }\n      })\n    );\n  });\n};\nexport {\n  $map\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil } from \"../../../util\";\nimport { $maxN as __maxN } from \"../../accumulator/maxN\";\nconst $maxN = (obj, expr, options) => {\n  if (isArray(obj)) return __maxN(obj, expr, options);\n  const { input, n } = computeValue(obj, expr, null, options);\n  if (isNil(input)) return null;\n  assert(isArray(input), \"Must resolve to an array/null or missing\");\n  return __maxN(input, { n, input: \"$$this\" }, options);\n};\nexport {\n  $maxN\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil } from \"../../../util\";\nimport { $minN as __minN } from \"../../accumulator/minN\";\nconst $minN = (obj, expr, options) => {\n  if (isArray(obj)) return __minN(obj, expr, options);\n  const { input, n } = computeValue(obj, expr, null, options);\n  if (isNil(input)) return null;\n  assert(isArray(input), \"Must resolve to an array/null or missing\");\n  return __minN(input, { n, input: \"$$this\" }, options);\n};\nexport {\n  $minN\n};\n","import { $nin as __nin, createExpressionOperator } from \"../../_predicates\";\nconst $nin = createExpressionOperator(__nin);\nexport {\n  $nin\n};\n","import { computeValue } from \"../../../core\";\nconst $range = (obj, expr, options) => {\n  const arr = computeValue(obj, expr, null, options);\n  const start = arr[0];\n  const end = arr[1];\n  const step = arr[2] || 1;\n  const result = new Array();\n  let counter = start;\n  while (counter < end && step > 0 || counter > end && step < 0) {\n    result.push(counter);\n    counter += step;\n  }\n  return result;\n};\nexport {\n  $range\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../../core\";\nimport { assert, isArray, isNil } from \"../../../util\";\nconst $reduce = (obj, expr, options) => {\n  const copts = ComputeOptions.init(options);\n  const input = computeValue(obj, expr.input, null, copts);\n  const initialValue = computeValue(obj, expr.initialValue, null, copts);\n  const inExpr = expr[\"in\"];\n  if (isNil(input)) return null;\n  assert(isArray(input), \"$reduce 'input' expression must resolve to an array\");\n  return input.reduce((acc, n) => {\n    return computeValue(\n      n,\n      inExpr,\n      null,\n      copts.update(copts.root, {\n        variables: { value: acc }\n      })\n    );\n  }, initialValue);\n};\nexport {\n  $reduce\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil } from \"../../../util\";\nconst $reverseArray = (obj, expr, options) => {\n  const arr = computeValue(obj, expr, null, options);\n  if (isNil(arr)) return null;\n  assert(isArray(arr), \"$reverseArray expression must resolve to an array\");\n  const result = arr.slice(0);\n  result.reverse();\n  return result;\n};\nexport {\n  $reverseArray\n};\n","import { computeValue } from \"../../../core\";\nimport { isArray } from \"../../../util\";\nconst $size = (obj, expr, options) => {\n  const value = computeValue(obj, expr, null, options);\n  return isArray(value) ? value.length : void 0;\n};\nexport {\n  $size\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil } from \"../../../util\";\nconst $slice = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const arr = args[0];\n  let skip = args[1];\n  let limit = args[2];\n  if (isNil(limit)) {\n    if (skip < 0) {\n      skip = Math.max(0, arr.length + skip);\n    } else {\n      limit = skip;\n      skip = 0;\n    }\n  } else {\n    if (skip < 0) {\n      skip = Math.max(0, arr.length + skip);\n    }\n    assert(\n      limit > 0,\n      `Invalid argument for $slice operator. Limit must be a positive number`\n    );\n    limit += skip;\n  }\n  return arr.slice(skip, limit);\n};\nexport {\n  $slice\n};\n","import { computeValue } from \"../../../core\";\nimport { Lazy } from \"../../../lazy\";\nimport { assert, compare, isArray, isNil, isObject } from \"../../../util\";\nimport { $sort } from \"../../pipeline/sort\";\nconst $sortArray = (obj, expr, options) => {\n  const { input, sortBy } = computeValue(obj, expr, null, options);\n  if (isNil(input)) return null;\n  assert(isArray(input), \"$sortArray expression must resolve to an array\");\n  if (isObject(sortBy)) {\n    return $sort(Lazy(input), sortBy, options).value();\n  }\n  const result = [...input];\n  result.sort(compare);\n  if (sortBy === -1) result.reverse();\n  return result;\n};\nexport {\n  $sortArray\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isBoolean, isNil } from \"../../../util\";\nconst $zip = (obj, expr, options) => {\n  const inputs = computeValue(obj, expr.inputs, null, options);\n  const useLongestLength = expr.useLongestLength || false;\n  if (isNil(inputs)) return null;\n  assert(isArray(inputs), \"'inputs' expression must resolve to an array\");\n  assert(isBoolean(useLongestLength), \"'useLongestLength' must be a boolean\");\n  if (isArray(expr.defaults)) {\n    assert(\n      useLongestLength,\n      \"'useLongestLength' must be set to true to use 'defaults'\"\n    );\n  }\n  let zipCount = 0;\n  for (const arr of inputs) {\n    if (isNil(arr)) return null;\n    assert(\n      isArray(arr),\n      \"'inputs' expression values must resolve to an array or null\"\n    );\n    zipCount = useLongestLength ? Math.max(zipCount, arr.length) : Math.min(zipCount || arr.length, arr.length);\n  }\n  const result = [];\n  const defaults = expr.defaults || [];\n  for (let i = 0; i < zipCount; i++) {\n    const temp = inputs.map((val, index) => {\n      return isNil(val[i]) ? defaults[index] || null : val[i];\n    });\n    result.push(temp);\n  }\n  return result;\n};\nexport {\n  $zip\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil, isNumber } from \"../../../util\";\nconst bitwise = (op, compute) => (obj, expr, options) => {\n  assert(isArray(expr), `${op}: expression must be an array.`);\n  const nums = computeValue(obj, expr, null, options);\n  if (nums.some(isNil)) return null;\n  assert(\n    nums.every(isNumber),\n    `${op}: expression must evalue to array of numbers.`\n  );\n  return compute(nums);\n};\nexport {\n  bitwise\n};\n","import { bitwise } from \"./_internal\";\nconst $bitAnd = bitwise(\n  \"$bitAnd\",\n  (nums) => nums.reduce((a, b) => a & b, -1)\n);\nexport {\n  $bitAnd\n};\n","import { computeValue } from \"../../../core\";\nimport { isNil, isNumber, MingoError } from \"../../../util\";\nconst $bitNot = (obj, expr, options) => {\n  const n = computeValue(obj, expr, null, options);\n  if (isNil(n)) return null;\n  if (isNumber(n)) return ~n;\n  throw new MingoError(\"$bitNot: expression must evaluate to a number.\");\n};\nexport {\n  $bitNot\n};\n","import { bitwise } from \"./_internal\";\nconst $bitOr = bitwise(\n  \"$bitOr\",\n  (nums) => nums.reduce((a, b) => a | b, 0)\n);\nexport {\n  $bitOr\n};\n","import { bitwise } from \"./_internal\";\nconst $bitXor = bitwise(\n  \"$bitXor\",\n  (nums) => nums.reduce((a, b) => a ^ b, 0)\n);\nexport {\n  $bitXor\n};\n","export * from \"./bitAnd\";\nexport * from \"./bitNot\";\nexport * from \"./bitOr\";\nexport * from \"./bitXor\";\n","import { computeValue } from \"../../../core\";\nimport { truthy } from \"../../../util\";\nconst $and = (obj, expr, options) => {\n  const value = computeValue(obj, expr, null, options);\n  return truthy(value, options.useStrictMode) && value.every((v) => truthy(v, options.useStrictMode));\n};\nexport {\n  $and\n};\n","export * from \"./and\";\nexport * from \"./not\";\nexport * from \"./or\";\n","import { computeValue } from \"../../../core\";\nimport { assert, ensureArray } from \"../../../util\";\nconst $not = (obj, expr, options) => {\n  const booleanExpr = ensureArray(expr);\n  if (booleanExpr.length == 0) return false;\n  assert(booleanExpr.length == 1, \"Expression $not takes exactly 1 argument\");\n  return !computeValue(obj, booleanExpr[0], null, options);\n};\nexport {\n  $not\n};\n","import { computeValue } from \"../../../core\";\nimport { truthy } from \"../../../util\";\nconst $or = (obj, expr, options) => {\n  const value = computeValue(obj, expr, null, options);\n  const strict = options.useStrictMode;\n  return truthy(value, strict) && value.some((v) => truthy(v, strict));\n};\nexport {\n  $or\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, compare, isArray } from \"../../../util\";\nconst $cmp = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  assert(\n    isArray(args) && args.length == 2,\n    \"$cmp: expression must resolve to array of size 2.\"\n  );\n  return compare(args[0], args[1]);\n};\nexport {\n  $cmp\n};\n","import { $eq as __eq, createExpressionOperator } from \"../../_predicates\";\nconst $eq = createExpressionOperator(__eq);\nexport {\n  $eq\n};\n","import { $gt as __gt, createExpressionOperator } from \"../../_predicates\";\nconst $gt = createExpressionOperator(__gt);\nexport {\n  $gt\n};\n","import { $gte as __gte, createExpressionOperator } from \"../../_predicates\";\nconst $gte = createExpressionOperator(__gte);\nexport {\n  $gte\n};\n","export * from \"./cmp\";\nexport * from \"./eq\";\nexport * from \"./gt\";\nexport * from \"./gte\";\nexport * from \"./lt\";\nexport * from \"./lte\";\nexport * from \"./ne\";\n","import { $lt as __lt, createExpressionOperator } from \"../../_predicates\";\nconst $lt = createExpressionOperator(__lt);\nexport {\n  $lt\n};\n","import { $lte as __lte, createExpressionOperator } from \"../../_predicates\";\nconst $lte = createExpressionOperator(__lte);\nexport {\n  $lte\n};\n","import { $ne as __ne, createExpressionOperator } from \"../../_predicates\";\nconst $ne = createExpressionOperator(__ne);\nexport {\n  $ne\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isObject, truthy } from \"../../../util\";\nconst $cond = (obj, expr, options) => {\n  let ifExpr;\n  let thenExpr;\n  let elseExpr;\n  const errorMsg = \"$cond: invalid arguments\";\n  if (isArray(expr)) {\n    assert(expr.length === 3, errorMsg);\n    ifExpr = expr[0];\n    thenExpr = expr[1];\n    elseExpr = expr[2];\n  } else {\n    assert(isObject(expr), errorMsg);\n    ifExpr = expr.if;\n    thenExpr = expr.then;\n    elseExpr = expr.else;\n  }\n  const condition = truthy(\n    computeValue(obj, ifExpr, null, options),\n    options.useStrictMode\n  );\n  return computeValue(obj, condition ? thenExpr : elseExpr, null, options);\n};\nexport {\n  $cond\n};\n","import { computeValue } from \"../../../core\";\nimport { isNil } from \"../../../util\";\nconst $ifNull = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  return args.find((arg) => !isNil(arg)) ?? args[args.length - 1];\n};\nexport {\n  $ifNull\n};\n","export * from \"./cond\";\nexport * from \"./ifNull\";\nexport * from \"./switch\";\n","import { computeValue } from \"../../../core\";\nimport { truthy } from \"../../../util\";\nconst $switch = (obj, expr, options) => {\n  let thenExpr = null;\n  expr.branches.some((b) => {\n    const condition = truthy(\n      computeValue(obj, b.case, null, options),\n      options.useStrictMode\n    );\n    if (condition) thenExpr = b.then;\n    return condition;\n  });\n  return computeValue(\n    obj,\n    thenExpr !== null ? thenExpr : expr.default,\n    null,\n    options\n  );\n};\nexport {\n  $switch\n};\n","import { computeValue } from \"../../../core\";\nimport { assert } from \"../../../util\";\nconst $function = (obj, expr, options) => {\n  assert(\n    options.scriptEnabled,\n    \"$function operator requires 'scriptEnabled' option to be true\"\n  );\n  const fn = computeValue(obj, expr, null, options);\n  return fn.body.apply(null, fn.args);\n};\nexport {\n  $function\n};\n","export * from \"./function\";\n","import { computeValue } from \"../../../core\";\nimport { isDate, isNil, isNumber, MingoError } from \"../../../util\";\nconst LEAP_YEAR_REF_POINT = -1e9;\nconst DAYS_PER_WEEK = 7;\nconst isLeapYear = (y) => (y & 3) == 0 && (y % 100 != 0 || y % 400 == 0);\nconst DAYS_IN_YEAR = [\n  365,\n  366\n  /*leap*/\n];\nconst daysInYear = (year) => DAYS_IN_YEAR[+isLeapYear(year)];\nconst DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst daysInMonth = (d) => DAYS_IN_MONTH[d.getUTCMonth()] + Number(\n  d.getUTCMonth() === 1 && isLeapYear(d.getUTCFullYear())\n);\nconst YEAR_DAYS_OFFSET = [\n  [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n  [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335]\n  /*leap*/\n];\nconst dayOfYear = (d) => YEAR_DAYS_OFFSET[+isLeapYear(d.getUTCFullYear())][d.getUTCMonth()] + d.getUTCDate();\nconst isoWeekday = (date, startOfWeek = \"sun\") => {\n  const dow = date.getUTCDay() || 7;\n  return (dow - ISO_WEEKDAY_MAP[startOfWeek] + DAYS_PER_WEEK) % DAYS_PER_WEEK;\n};\nconst p = (y) => (y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400)) % 7;\nconst weeks = (y) => 52 + Number(p(y) == 4 || p(y - 1) == 3);\nfunction isoWeek(d) {\n  const dow = d.getUTCDay() || 7;\n  const w = Math.floor((10 + dayOfYear(d) - dow) / 7);\n  if (w < 1) return weeks(d.getUTCFullYear() - 1);\n  if (w > weeks(d.getUTCFullYear())) return 1;\n  return w;\n}\nfunction isoWeekYear(d) {\n  return d.getUTCFullYear() - Number(d.getUTCMonth() === 0 && d.getUTCDate() == 1 && d.getUTCDay() < 1);\n}\nconst MINUTES_PER_HOUR = 60;\nconst MILLIS_PER_DAY = 1e3 * 60 * 60 * 24;\nconst TIMEUNIT_IN_MILLIS = {\n  week: MILLIS_PER_DAY * DAYS_PER_WEEK,\n  day: MILLIS_PER_DAY,\n  hour: 1e3 * 60 * 60,\n  minute: 1e3 * 60,\n  second: 1e3,\n  millisecond: 1\n};\nconst DAYS_OF_WEEK = [\n  \"monday\",\n  \"mon\",\n  \"tuesday\",\n  \"tue\",\n  \"wednesday\",\n  \"wed\",\n  \"thursday\",\n  \"thu\",\n  \"friday\",\n  \"fri\",\n  \"saturday\",\n  \"sat\",\n  \"sunday\",\n  \"sun\"\n];\nconst DAYS_OF_WEEK_SET = new Set(DAYS_OF_WEEK);\nconst ISO_WEEKDAY_MAP = Object.freeze({\n  mon: 1,\n  tue: 2,\n  wed: 3,\n  thu: 4,\n  fri: 5,\n  sat: 6,\n  sun: 7\n});\nconst DATE_FORMAT = \"%Y-%m-%dT%H:%M:%S.%LZ\";\nconst DATE_PART_INTERVAL = [\n  [\"year\", 0, 9999],\n  [\"month\", 1, 12],\n  [\"day\", 1, 31],\n  [\"hour\", 0, 23],\n  [\"minute\", 0, 59],\n  [\"second\", 0, 59],\n  [\"millisecond\", 0, 999]\n];\nconst DATE_SYM_TABLE = Object.freeze({\n  \"%Y\": { name: \"year\", padding: 4, re: /([0-9]{4})/ },\n  \"%G\": { name: \"year\", padding: 4, re: /([0-9]{4})/ },\n  \"%m\": { name: \"month\", padding: 2, re: /(0[1-9]|1[012])/ },\n  \"%d\": { name: \"day\", padding: 2, re: /(0[1-9]|[12][0-9]|3[01])/ },\n  \"%H\": { name: \"hour\", padding: 2, re: /([01][0-9]|2[0-3])/ },\n  \"%M\": { name: \"minute\", padding: 2, re: /([0-5][0-9])/ },\n  \"%S\": { name: \"second\", padding: 2, re: /([0-5][0-9]|60)/ },\n  \"%L\": { name: \"millisecond\", padding: 3, re: /([0-9]{3})/ },\n  \"%u\": { name: \"weekday\", padding: 1, re: /([1-7])/ },\n  \"%U\": { name: \"week\", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },\n  \"%V\": { name: \"isoWeek\", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },\n  \"%z\": {\n    name: \"timezone\",\n    padding: 2,\n    re: /(([+-][01][0-9]|2[0-3]):?([0-5][0-9])?)/\n  },\n  \"%Z\": { name: \"minuteOffset\", padding: 3, re: /([+-][0-9]{3})/ }\n  // \"%%\": \"%\",\n});\nconst TIMEZONE_RE = /^[a-zA-Z_]+\\/[a-zA-Z_]+$/;\nfunction parseTimezone(tzstr) {\n  if (isNil(tzstr)) return 0;\n  if (TIMEZONE_RE.test(tzstr)) {\n    const date = /* @__PURE__ */ new Date();\n    const utcDate = new Date(date.toLocaleString(\"en-US\", { timeZone: \"UTC\" }));\n    const tzDate = new Date(date.toLocaleString(\"en-US\", { timeZone: tzstr }));\n    return (tzDate.getTime() - utcDate.getTime()) / 6e4;\n  }\n  const m = DATE_SYM_TABLE[\"%z\"].re.exec(tzstr);\n  if (!m) {\n    throw new MingoError(`Timezone '${tzstr}' is invalid or not supported`);\n  }\n  const hr = parseInt(m[2]) || 0;\n  const min = parseInt(m[3]) || 0;\n  return (Math.abs(hr * MINUTES_PER_HOUR) + min) * (hr < 0 ? -1 : 1);\n}\nfunction formatTimezone(minuteOffset) {\n  return (minuteOffset < 0 ? \"-\" : \"+\") + padDigits(Math.abs(Math.floor(minuteOffset / MINUTES_PER_HOUR)), 2) + padDigits(Math.abs(minuteOffset) % MINUTES_PER_HOUR, 2);\n}\nfunction adjustDate(d, minuteOffset) {\n  d.setUTCMinutes(d.getUTCMinutes() + minuteOffset);\n}\nfunction computeDate(obj, expr, options) {\n  if (isDate(obj)) return obj;\n  const d = computeValue(obj, expr, null, options);\n  if (isDate(d)) return new Date(d);\n  if (isNumber(d)) return new Date(d * 1e3);\n  if (d.date) {\n    const date = isDate(d.date) ? new Date(d.date) : new Date(d.date * 1e3);\n    if (d.timezone) {\n      adjustDate(date, parseTimezone(d.timezone));\n    }\n    return date;\n  }\n  throw Error(`cannot convert ${JSON.stringify(expr)} to date`);\n}\nfunction padDigits(n, digits) {\n  return new Array(Math.max(digits - String(n).length + 1, 0)).join(\"0\") + n.toString();\n}\nconst leapYearsSinceReferencePoint = (year) => {\n  const yearsSinceReferencePoint = year - LEAP_YEAR_REF_POINT;\n  return Math.trunc(yearsSinceReferencePoint / 4) - Math.trunc(yearsSinceReferencePoint / 100) + Math.trunc(yearsSinceReferencePoint / 400);\n};\nfunction daysBetweenYears(startYear, endYear) {\n  return Math.trunc(\n    leapYearsSinceReferencePoint(endYear - 1) - leapYearsSinceReferencePoint(startYear - 1) + (endYear - startYear) * DAYS_IN_YEAR[0]\n  );\n}\nconst dateDiffYear = (start, end) => end.getUTCFullYear() - start.getUTCFullYear();\nconst dateDiffMonth = (start, end) => end.getUTCMonth() - start.getUTCMonth() + dateDiffYear(start, end) * 12;\nconst dateDiffQuarter = (start, end) => {\n  const a = Math.trunc(start.getUTCMonth() / 3);\n  const b = Math.trunc(end.getUTCMonth() / 3);\n  return b - a + dateDiffYear(start, end) * 4;\n};\nconst dateDiffDay = (start, end) => dayOfYear(end) - dayOfYear(start) + daysBetweenYears(start.getUTCFullYear(), end.getUTCFullYear());\nconst dateDiffWeek = (start, end, startOfWeek) => {\n  const wk = (startOfWeek || \"sun\").substring(0, 3);\n  return Math.trunc(\n    (dateDiffDay(start, end) + isoWeekday(start, wk) - isoWeekday(end, wk)) / DAYS_PER_WEEK\n  );\n};\nconst dateDiffHour = (start, end) => end.getUTCHours() - start.getUTCHours() + dateDiffDay(start, end) * 24;\nconst addMonth = (d, amount) => {\n  const m = d.getUTCMonth() + amount;\n  const yearOffset = Math.floor(m / 12);\n  if (m < 0) {\n    const month = m % 12 + 12;\n    d.setUTCFullYear(d.getUTCFullYear() + yearOffset, month, d.getUTCDate());\n  } else {\n    d.setUTCFullYear(d.getUTCFullYear() + yearOffset, m % 12, d.getUTCDate());\n  }\n};\nconst dateAdd = (date, unit, amount, _timezone) => {\n  const d = new Date(date);\n  switch (unit) {\n    case \"year\":\n      d.setUTCFullYear(d.getUTCFullYear() + amount);\n      break;\n    case \"quarter\":\n      addMonth(d, 3 * amount);\n      break;\n    case \"month\":\n      addMonth(d, amount);\n      break;\n    default:\n      d.setTime(d.getTime() + TIMEUNIT_IN_MILLIS[unit] * amount);\n  }\n  return d;\n};\nexport {\n  DATE_FORMAT,\n  DATE_PART_INTERVAL,\n  DATE_SYM_TABLE,\n  DAYS_OF_WEEK,\n  DAYS_OF_WEEK_SET,\n  DAYS_PER_WEEK,\n  LEAP_YEAR_REF_POINT,\n  MILLIS_PER_DAY,\n  MINUTES_PER_HOUR,\n  TIMEUNIT_IN_MILLIS,\n  adjustDate,\n  computeDate,\n  dateAdd,\n  dateDiffDay,\n  dateDiffHour,\n  dateDiffMonth,\n  dateDiffQuarter,\n  dateDiffWeek,\n  dateDiffYear,\n  dayOfYear,\n  daysBetweenYears,\n  daysInMonth,\n  daysInYear,\n  formatTimezone,\n  isLeapYear,\n  isoWeek,\n  isoWeekYear,\n  isoWeekday,\n  padDigits,\n  parseTimezone\n};\n","import { computeValue } from \"../../../core\";\nimport { dateAdd } from \"./_internal\";\nconst $dateAdd = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  return dateAdd(args.startDate, args.unit, args.amount, args.timezone);\n};\nexport {\n  $dateAdd\n};\n","import { computeValue } from \"../../../core\";\nimport {\n  adjustDate,\n  dateDiffDay,\n  dateDiffHour,\n  dateDiffMonth,\n  dateDiffQuarter,\n  dateDiffWeek,\n  dateDiffYear,\n  parseTimezone,\n  TIMEUNIT_IN_MILLIS\n} from \"./_internal\";\nconst $dateDiff = (obj, expr, options) => {\n  const { startDate, endDate, unit, timezone, startOfWeek } = computeValue(\n    obj,\n    expr,\n    null,\n    options\n  );\n  const d1 = new Date(startDate);\n  const d2 = new Date(endDate);\n  const minuteOffset = parseTimezone(timezone);\n  adjustDate(d1, minuteOffset);\n  adjustDate(d2, minuteOffset);\n  switch (unit) {\n    case \"year\":\n      return dateDiffYear(d1, d2);\n    case \"quarter\":\n      return dateDiffQuarter(d1, d2);\n    case \"month\":\n      return dateDiffMonth(d1, d2);\n    case \"week\":\n      return dateDiffWeek(d1, d2, startOfWeek);\n    case \"day\":\n      return dateDiffDay(d1, d2);\n    case \"hour\":\n      return dateDiffHour(d1, d2);\n    case \"minute\":\n      d1.setUTCSeconds(0);\n      d1.setUTCMilliseconds(0);\n      d2.setUTCSeconds(0);\n      d2.setUTCMilliseconds(0);\n      return Math.round(\n        (d2.getTime() - d1.getTime()) / TIMEUNIT_IN_MILLIS[unit]\n      );\n    default:\n      return Math.round(\n        (d2.getTime() - d1.getTime()) / TIMEUNIT_IN_MILLIS[unit]\n      );\n  }\n};\nexport {\n  $dateDiff\n};\n","import { computeValue } from \"../../../core\";\nimport {\n  DATE_PART_INTERVAL,\n  isLeapYear,\n  MINUTES_PER_HOUR,\n  parseTimezone\n} from \"./_internal\";\nconst DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst getDaysInMonth = (date) => {\n  return date.month == 2 && isLeapYear(date.year) ? 29 : DAYS_IN_MONTH[date.month - 1];\n};\nconst $dateFromParts = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const minuteOffset = parseTimezone(args.timezone);\n  for (let i = DATE_PART_INTERVAL.length - 1, remainder = 0; i >= 0; i--) {\n    const datePartInterval = DATE_PART_INTERVAL[i];\n    const k = datePartInterval[0];\n    const min = datePartInterval[1];\n    const max = datePartInterval[2];\n    let part = (args[k] || 0) + remainder;\n    remainder = 0;\n    const limit = max + 1;\n    if (k == \"hour\") part += Math.floor(minuteOffset / MINUTES_PER_HOUR) * -1;\n    if (k == \"minute\") part += minuteOffset % MINUTES_PER_HOUR * -1;\n    if (part < min) {\n      const delta = min - part;\n      remainder = -1 * Math.ceil(delta / limit);\n      part = limit - delta % limit;\n    } else if (part > max) {\n      part += min;\n      remainder = Math.trunc(part / limit);\n      part %= limit;\n    }\n    args[k] = part;\n  }\n  args.day = Math.min(args.day, getDaysInMonth(args));\n  return new Date(\n    Date.UTC(\n      args.year,\n      args.month - 1,\n      args.day,\n      args.hour,\n      args.minute,\n      args.second,\n      args.millisecond\n    )\n  );\n};\nexport {\n  $dateFromParts\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isObject } from \"../../../util\";\nimport {\n  adjustDate,\n  DATE_FORMAT,\n  DATE_SYM_TABLE,\n  MINUTES_PER_HOUR,\n  parseTimezone\n} from \"./_internal\";\nconst buildMap = (letters, sign) => {\n  const h = {};\n  letters.split(\"\").forEach((v, i) => h[v] = sign * (i + 1));\n  return h;\n};\nconst TZ_LETTER_OFFSETS = {\n  ...buildMap(\"ABCDEFGHIKLM\", 1),\n  ...buildMap(\"NOPQRSTUVWXY\", -1),\n  Z: 0\n};\nconst regexStrip = (s) => s.replace(/^\\//, \"\").replace(/\\/$/, \"\");\nconst REGEX_SPECIAL_CHARS = [\"^\", \".\", \"-\", \"*\", \"?\", \"$\"];\nconst regexQuote = (s) => {\n  REGEX_SPECIAL_CHARS.forEach((c) => {\n    s = s.replace(c, `\\\\${c}`);\n  });\n  return s;\n};\nconst $dateFromString = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  args.format = args.format || DATE_FORMAT;\n  args.onNull = args.onNull || null;\n  let dateString = args.dateString;\n  if (isNil(dateString)) return args.onNull;\n  const separators = args.format.split(/%[YGmdHMSLuVzZ]/);\n  separators.reverse();\n  const matches = args.format.match(\n    /(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%V|%z|%Z)/g\n  );\n  const dateParts = {};\n  let expectedPattern = \"\";\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const formatSpecifier = matches[i];\n    const props = DATE_SYM_TABLE[formatSpecifier];\n    if (isObject(props)) {\n      const m2 = props.re.exec(dateString);\n      const delimiter = separators.pop() || \"\";\n      if (m2 !== null) {\n        dateParts[props.name] = /^\\d+$/.exec(m2[0]) ? parseInt(m2[0]) : m2[0];\n        dateString = dateString.substr(0, m2.index) + dateString.substr(m2.index + m2[0].length);\n        expectedPattern += regexQuote(delimiter) + regexStrip(props.re.toString());\n      } else {\n        dateParts[props.name] = null;\n      }\n    }\n  }\n  if (isNil(dateParts.year) || isNil(dateParts.month) || isNil(dateParts.day) || !new RegExp(\"^\" + expectedPattern + \"[A-Z]?$\").exec(args.dateString)) {\n    return args.onError;\n  }\n  const m = args.dateString.match(/([A-Z])$/);\n  assert(\n    // only one of in-date timeone or timezone argument but not both.\n    !(m && args.timezone),\n    `$dateFromString: you cannot pass in a date/time string with time zone information ('${m && m[0]}') together with a timezone argument`\n  );\n  const minuteOffset = m ? TZ_LETTER_OFFSETS[m[0]] * MINUTES_PER_HOUR : parseTimezone(args.timezone);\n  const d = new Date(\n    Date.UTC(dateParts.year, dateParts.month - 1, dateParts.day, 0, 0, 0)\n  );\n  if (!isNil(dateParts.hour)) d.setUTCHours(dateParts.hour);\n  if (!isNil(dateParts.minute)) d.setUTCMinutes(dateParts.minute);\n  if (!isNil(dateParts.second)) d.setUTCSeconds(dateParts.second);\n  if (!isNil(dateParts.millisecond))\n    d.setUTCMilliseconds(dateParts.millisecond);\n  adjustDate(d, -minuteOffset);\n  return d;\n};\nexport {\n  $dateFromString\n};\n","import { computeValue } from \"../../../core\";\nimport { $dateAdd } from \"./dateAdd\";\nconst $dateSubtract = (obj, expr, options) => {\n  const amount = computeValue(obj, expr?.amount, null, options);\n  return $dateAdd(obj, { ...expr, amount: -1 * amount }, options);\n};\nexport {\n  $dateSubtract\n};\n","import { computeValue } from \"../../../core\";\nimport { adjustDate, isoWeek, isoWeekYear, parseTimezone } from \"./_internal\";\nconst $dateToParts = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const d = new Date(args.date);\n  const tz = parseTimezone(args.timezone);\n  adjustDate(d, tz);\n  const timePart = {\n    hour: d.getUTCHours(),\n    minute: d.getUTCMinutes(),\n    second: d.getUTCSeconds(),\n    millisecond: d.getUTCMilliseconds()\n  };\n  if (args.iso8601 == true) {\n    return Object.assign(timePart, {\n      isoWeekYear: isoWeekYear(d),\n      isoWeek: isoWeek(d),\n      isoDayOfWeek: d.getUTCDay() || 7\n    });\n  }\n  return Object.assign(timePart, {\n    year: d.getUTCFullYear(),\n    month: d.getUTCMonth() + 1,\n    day: d.getUTCDate()\n  });\n};\nexport {\n  $dateToParts\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isObject } from \"../../../util\";\nimport {\n  adjustDate,\n  computeDate,\n  DATE_FORMAT,\n  DATE_SYM_TABLE,\n  formatTimezone,\n  padDigits,\n  parseTimezone\n} from \"./_internal\";\nimport { $dayOfMonth } from \"./dayOfMonth\";\nimport { $hour } from \"./hour\";\nimport { $isoDayOfWeek } from \"./isoDayOfWeek\";\nimport { $isoWeek } from \"./isoWeek\";\nimport { $millisecond } from \"./millisecond\";\nimport { $minute } from \"./minute\";\nimport { $month } from \"./month\";\nimport { $second } from \"./second\";\nimport { $week } from \"./week\";\nimport { $year } from \"./year\";\nconst DATE_FUNCTIONS = {\n  \"%Y\": $year,\n  \"%G\": $year,\n  \"%m\": $month,\n  \"%d\": $dayOfMonth,\n  \"%H\": $hour,\n  \"%M\": $minute,\n  \"%S\": $second,\n  \"%L\": $millisecond,\n  \"%u\": $isoDayOfWeek,\n  \"%U\": $week,\n  \"%V\": $isoWeek\n};\nconst $dateToString = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  if (isNil(args.onNull)) args.onNull = null;\n  if (isNil(args.date)) return args.onNull;\n  const date = computeDate(obj, args.date, options);\n  let format = args.format || DATE_FORMAT;\n  const minuteOffset = parseTimezone(args.timezone);\n  const matches = format.match(/(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%U|%V|%z|%Z)/g);\n  adjustDate(date, minuteOffset);\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const formatSpecifier = matches[i];\n    const props = DATE_SYM_TABLE[formatSpecifier];\n    const operatorFn = DATE_FUNCTIONS[formatSpecifier];\n    let value;\n    if (isObject(props)) {\n      if (props.name === \"timezone\") {\n        value = formatTimezone(minuteOffset);\n      } else if (props.name === \"minuteOffset\") {\n        value = minuteOffset.toString();\n      } else {\n        assert(\n          !!operatorFn,\n          `unsupported date format specifier '${formatSpecifier}'`\n        );\n        value = padDigits(operatorFn(obj, date, options), props.padding);\n      }\n    }\n    format = format.replace(formatSpecifier, value);\n  }\n  return format;\n};\nexport {\n  $dateToString\n};\n","import { computeValue } from \"../../../core\";\nimport { TIME_UNITS } from \"../../../types\";\nimport { assert, isDate, isNil } from \"../../../util\";\nimport {\n  adjustDate,\n  dateAdd,\n  dateDiffDay,\n  dateDiffMonth,\n  dateDiffQuarter,\n  dateDiffWeek,\n  dateDiffYear,\n  DAYS_OF_WEEK_SET,\n  DAYS_PER_WEEK,\n  isoWeekday,\n  parseTimezone,\n  TIMEUNIT_IN_MILLIS\n} from \"./_internal\";\nconst REF_DATE_MILLIS = 9466848e5;\nconst distanceToBinLowerBound = (value, binSize) => {\n  let remainder = value % binSize;\n  if (remainder < 0) {\n    remainder += binSize;\n  }\n  return remainder;\n};\nconst DATE_DIFF_FN = {\n  day: dateDiffDay,\n  month: dateDiffMonth,\n  quarter: dateDiffQuarter,\n  year: dateDiffYear\n};\nconst $dateTrunc = (obj, expr, options) => {\n  const {\n    date,\n    unit,\n    binSize: optBinSize,\n    timezone,\n    startOfWeek: optStartOfWeek\n  } = computeValue(obj, expr, null, options);\n  if (isNil(date) || isNil(unit)) return null;\n  const startOfWeek = (optStartOfWeek ?? \"sun\").toLowerCase().substring(0, 3);\n  assert(\n    isDate(date),\n    \"$dateTrunc: 'date' must resolve to a valid Date object.\"\n  );\n  assert(TIME_UNITS.includes(unit), \"$dateTrunc: unit is invalid.\");\n  assert(\n    unit != \"week\" || DAYS_OF_WEEK_SET.has(startOfWeek),\n    `$dateTrunc: startOfWeek '${startOfWeek}' is not a valid.`\n  );\n  assert(\n    isNil(optBinSize) || optBinSize > 0,\n    \"$dateTrunc requires 'binSize' to be greater than 0, but got value 0.\"\n  );\n  const binSize = optBinSize ?? 1;\n  switch (unit) {\n    case \"millisecond\":\n    case \"second\":\n    case \"minute\":\n    case \"hour\": {\n      const binSizeMillis = binSize * TIMEUNIT_IN_MILLIS[unit];\n      const shiftedDate = date.getTime() - REF_DATE_MILLIS;\n      return new Date(\n        date.getTime() - distanceToBinLowerBound(shiftedDate, binSizeMillis)\n      );\n    }\n    default: {\n      assert(binSize <= 1e11, \"dateTrunc unsupported binSize value\");\n      const d = new Date(date);\n      const refPointDate = new Date(REF_DATE_MILLIS);\n      let distanceFromRefPoint = 0;\n      if (unit == \"week\") {\n        const refPointDayOfWeek = isoWeekday(refPointDate, startOfWeek);\n        const daysToAdjustBy = (DAYS_PER_WEEK - refPointDayOfWeek) % DAYS_PER_WEEK;\n        refPointDate.setTime(\n          refPointDate.getTime() + daysToAdjustBy * TIMEUNIT_IN_MILLIS.day\n        );\n        distanceFromRefPoint = dateDiffWeek(refPointDate, d, startOfWeek);\n      } else {\n        distanceFromRefPoint = DATE_DIFF_FN[unit](refPointDate, d);\n      }\n      const binLowerBoundFromRefPoint = distanceFromRefPoint - distanceToBinLowerBound(distanceFromRefPoint, binSize);\n      const newDate = dateAdd(\n        refPointDate,\n        unit,\n        binLowerBoundFromRefPoint,\n        timezone\n      );\n      const minuteOffset = parseTimezone(timezone);\n      adjustDate(newDate, -minuteOffset);\n      return newDate;\n    }\n  }\n};\nexport {\n  $dateTrunc\n};\n","import { computeDate } from \"./_internal\";\nconst $dayOfMonth = (obj, expr, options) => {\n  return computeDate(obj, expr, options).getUTCDate();\n};\nexport {\n  $dayOfMonth\n};\n","import { computeDate } from \"./_internal\";\nconst $dayOfWeek = (obj, expr, options) => {\n  return computeDate(obj, expr, options).getUTCDay() + 1;\n};\nexport {\n  $dayOfWeek\n};\n","import { computeDate, dayOfYear } from \"./_internal\";\nconst $dayOfYear = (obj, expr, options) => {\n  return dayOfYear(computeDate(obj, expr, options));\n};\nexport {\n  $dayOfYear\n};\n","import { computeDate } from \"./_internal\";\nconst $hour = (obj, expr, options) => {\n  return computeDate(obj, expr, options).getUTCHours();\n};\nexport {\n  $hour\n};\n","export * from \"./dateAdd\";\nexport * from \"./dateDiff\";\nexport * from \"./dateFromParts\";\nexport * from \"./dateFromString\";\nexport * from \"./dateSubtract\";\nexport * from \"./dateToParts\";\nexport * from \"./dateToString\";\nexport * from \"./dateTrunc\";\nexport * from \"./dayOfMonth\";\nexport * from \"./dayOfWeek\";\nexport * from \"./dayOfYear\";\nexport * from \"./hour\";\nexport * from \"./isoDayOfWeek\";\nexport * from \"./isoWeek\";\nexport * from \"./isoWeekYear\";\nexport * from \"./millisecond\";\nexport * from \"./minute\";\nexport * from \"./month\";\nexport * from \"./second\";\nexport * from \"./week\";\nexport * from \"./year\";\n","import { computeDate } from \"./_internal\";\nconst $isoDayOfWeek = (obj, expr, options) => {\n  return computeDate(obj, expr, options).getUTCDay() || 7;\n};\nexport {\n  $isoDayOfWeek\n};\n","import { computeDate, isoWeek } from \"./_internal\";\nconst $isoWeek = (obj, expr, options) => {\n  return isoWeek(computeDate(obj, expr, options));\n};\nexport {\n  $isoWeek\n};\n","import { computeDate, isoWeekYear } from \"./_internal\";\nconst $isoWeekYear = (obj, expr, options) => isoWeekYear(computeDate(obj, expr, options));\nexport {\n  $isoWeekYear\n};\n","import { computeDate } from \"./_internal\";\nconst $millisecond = (obj, expr, options) => {\n  return computeDate(obj, expr, options).getUTCMilliseconds();\n};\nexport {\n  $millisecond\n};\n","import { computeDate } from \"./_internal\";\nconst $minute = (obj, expr, options) => {\n  return computeDate(obj, expr, options).getUTCMinutes();\n};\nexport {\n  $minute\n};\n","import { computeDate } from \"./_internal\";\nconst $month = (obj, expr, options) => {\n  return computeDate(obj, expr, options).getUTCMonth() + 1;\n};\nexport {\n  $month\n};\n","import { computeDate } from \"./_internal\";\nconst $second = (obj, expr, options) => {\n  return computeDate(obj, expr, options).getUTCSeconds();\n};\nexport {\n  $second\n};\n","import { computeDate, isoWeek } from \"./_internal\";\nconst $week = (obj, expr, options) => {\n  const d = computeDate(obj, expr, options);\n  const result = isoWeek(d);\n  if (d.getUTCDay() > 0 && d.getUTCDate() == 1 && d.getUTCMonth() == 0)\n    return 0;\n  if (d.getUTCDay() == 0) return result + 1;\n  return result;\n};\nexport {\n  $week\n};\n","import { computeDate } from \"./_internal\";\nconst $year = (obj, expr, options) => {\n  return computeDate(obj, expr, options).getUTCFullYear();\n};\nexport {\n  $year\n};\n","export * from \"./arithmetic\";\nexport * from \"./array\";\nexport * from \"./bitwise\";\nexport * from \"./boolean\";\nexport * from \"./comparison\";\nexport * from \"./conditional\";\nexport * from \"./custom\";\nexport * from \"./date\";\nexport * from \"./literal\";\nexport * from \"./median\";\nexport * from \"./misc\";\nexport * from \"./object\";\nexport * from \"./percentile\";\nexport * from \"./set\";\nexport * from \"./string\";\nexport * from \"./trignometry\";\nexport * from \"./type\";\nexport * from \"./variable\";\n","const $literal = (_obj, expr, _options) => expr;\nexport {\n  $literal\n};\n","import { computeValue } from \"../../core\";\nimport { $median as __median } from \"../accumulator/median\";\nconst $median = (obj, expr, options) => {\n  const input = computeValue(obj, expr.input, null, options);\n  return __median(input, { input: \"$$CURRENT\" }, options);\n};\nexport {\n  $median\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isObject, isString } from \"../../../util\";\nconst $getField = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const [field, input] = isObject(args) ? [args.field, args.input || obj] : [args, obj];\n  if (isNil(input)) return null;\n  assert(\n    isObject(input),\n    \"$getField expression 'input' must evaluate to an object\"\n  );\n  assert(\n    isString(field),\n    \"$getField expression 'field' must evaluate to a string\"\n  );\n  return input[field];\n};\nexport {\n  $getField\n};\n","export * from \"./getField\";\nexport * from \"./rand\";\nexport * from \"./sampleRate\";\n","const $rand = (_obj, _expr, _options) => Math.random();\nexport {\n  $rand\n};\n","import { computeValue } from \"../../../core\";\nconst $sampleRate = (obj, expr, options) => Math.random() <= computeValue(obj, expr, null, options);\nexport {\n  $sampleRate\n};\n","export * from \"./mergeObjects\";\nexport * from \"./objectToArray\";\nexport * from \"./setField\";\nexport * from \"./unsetField\";\n","import { computeValue } from \"../../../core\";\nimport { isNil } from \"../../../util\";\nconst $mergeObjects = (obj, expr, options) => {\n  const docs = computeValue(obj, expr, null, options) ?? [];\n  const acc = {};\n  for (const o of docs) {\n    if (isNil(o)) continue;\n    for (const k of Object.keys(o)) {\n      if (o[k] !== void 0) acc[k] = o[k];\n    }\n  }\n  return acc;\n};\nexport {\n  $mergeObjects\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isObject, typeOf } from \"../../../util\";\nconst $objectToArray = (obj, expr, options) => {\n  const val = computeValue(obj, expr, null, options);\n  if (isNil(val)) return null;\n  assert(\n    isObject(val),\n    `$objectToArray requires a document input, found: ${typeOf(val)}`\n  );\n  const entries = Object.entries(val);\n  const result = new Array(entries.length);\n  let i = 0;\n  for (const [k, v] of entries) {\n    result[i++] = { k, v };\n  }\n  return result;\n};\nexport {\n  $objectToArray\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isObject, isString } from \"../../../util\";\nconst $setField = (obj, expr, options) => {\n  const { input, field, value } = computeValue(\n    obj,\n    expr,\n    null,\n    options\n  );\n  if (isNil(input)) return null;\n  assert(\n    isObject(input),\n    \"$setField expression 'input' must evaluate to an object\"\n  );\n  assert(\n    isString(field),\n    \"$setField expression 'field' must evaluate to a string\"\n  );\n  const newObj = { ...input };\n  if (expr.value == \"$$REMOVE\") {\n    delete newObj[field];\n  } else {\n    newObj[field] = value;\n  }\n  return newObj;\n};\nexport {\n  $setField\n};\n","import { $setField } from \"./setField\";\nconst $unsetField = (obj, expr, options) => {\n  return $setField(\n    obj,\n    {\n      ...expr,\n      value: \"$$REMOVE\"\n    },\n    options\n  );\n};\nexport {\n  $unsetField\n};\n","import { computeValue } from \"../../core\";\nimport { $percentile as __percentile } from \"../accumulator/percentile\";\nconst $percentile = (obj, expr, options) => {\n  const input = computeValue(obj, expr.input, null, options);\n  return __percentile(input, { ...expr, input: \"$$CURRENT\" }, options);\n};\nexport {\n  $percentile\n};\n","import { computeValue } from \"../../../core\";\nimport { truthy } from \"../../../util\";\nconst $allElementsTrue = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options)[0];\n  return args.every((v) => truthy(v, options.useStrictMode));\n};\nexport {\n  $allElementsTrue\n};\n","import { computeValue } from \"../../../core\";\nimport { truthy } from \"../../../util\";\nconst $anyElementTrue = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options)[0];\n  return args.some((v) => truthy(v, options.useStrictMode));\n};\nexport {\n  $anyElementTrue\n};\n","export * from \"./allElementsTrue\";\nexport * from \"./anyElementTrue\";\nexport * from \"./setDifference\";\nexport * from \"./setEquals\";\nexport * from \"./setIntersection\";\nexport * from \"./setIsSubset\";\nexport * from \"./setUnion\";\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil, ValueMap } from \"../../../util\";\nconst $setDifference = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  if (isNil(args)) return null;\n  assert(isArray(args), \"$setDifference must be an arrays.\");\n  if (args.some(isNil)) return null;\n  assert(args.length == 2, `$setDifference takes exactly 2 arguments.`);\n  assert(args.every(isArray), \"$setDifference operands must be arrays.\");\n  const m = ValueMap.init(options.hashFunction);\n  args[0].forEach((v) => m.set(v, true));\n  args[1].forEach((v) => m.delete(v));\n  return Array.from(m.keys());\n};\nexport {\n  $setDifference\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, ValueMap } from \"../../../util\";\nconst $setEquals = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  assert(\n    isArray(args) && args.every(isArray),\n    \"$setEquals operands must be arrays.\"\n  );\n  const map = ValueMap.init();\n  args[0].every((v, i) => map.set(v, i));\n  for (let i = 1; i < args.length; i++) {\n    const arr = args[i];\n    const set = /* @__PURE__ */ new Set();\n    for (let j = 0; j < arr.length; j++) {\n      const n = map.get(arr[j]) ?? -1;\n      if (n === -1) return false;\n      set.add(n);\n    }\n    if (set.size !== map.size) return false;\n  }\n  return true;\n};\nexport {\n  $setEquals\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, intersection, isArray, isNil } from \"../../../util\";\nconst $setIntersection = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  if (isNil(args)) return null;\n  assert(\n    isArray(args) && args.every(isArray),\n    \"$setIntersection operands must be arrays.\"\n  );\n  return intersection(args, options?.hashFunction);\n};\nexport {\n  $setIntersection\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isArray, ValueMap } from \"../../../util\";\nconst $setIsSubset = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  assert(\n    isArray(args) && args.every(isArray),\n    \"$setIsSubset operands must be arrays.\"\n  );\n  const first = args[0];\n  const second = args[1];\n  const map = ValueMap.init();\n  const set = /* @__PURE__ */ new Set();\n  first.every((v, i) => map.set(v, i));\n  for (const v of second) {\n    set.add(map.get(v) ?? -1);\n    if (set.size > map.size) return true;\n  }\n  set.delete(-1);\n  return set.size == map.size;\n};\nexport {\n  $setIsSubset\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, flatten, isArray, isNil, unique } from \"../../../util\";\nconst $setUnion = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  if (isNil(args)) return null;\n  assert(isArray(args), \"$setUnion operands must be arrays.\");\n  if (args.some(isNil)) return null;\n  return unique(flatten(args), options?.hashFunction);\n};\nexport {\n  $setUnion\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isString } from \"../../../util\";\nconst WHITESPACE_CHARS = [\n  0,\n  // '\\0' Null character\n  32,\n  // ' ', Space\n  9,\n  // '\\t' Horizontal tab\n  10,\n  // '\\n' Line feed/new line\n  11,\n  // '\\v' Vertical tab\n  12,\n  // '\\f' Form feed\n  13,\n  // '\\r' Carriage return\n  160,\n  // Non-breaking space\n  5760,\n  // Ogham space mark\n  8192,\n  // En quad\n  8193,\n  // Em quad\n  8194,\n  // En space\n  8195,\n  // Em space\n  8196,\n  // Three-per-em space\n  8197,\n  // Four-per-em space\n  8198,\n  // Six-per-em space\n  8199,\n  // Figure space\n  8200,\n  // Punctuation space\n  8201,\n  // Thin space\n  8202\n  // Hair space\n];\nfunction trimString(obj, expr, options, trimOpts) {\n  const val = computeValue(obj, expr, null, options);\n  const s = val.input;\n  if (isNil(s)) return null;\n  const codepoints = isNil(val.chars) ? WHITESPACE_CHARS : val.chars.split(\"\").map((c) => c.codePointAt(0));\n  let i = 0;\n  let j = s.length - 1;\n  while (trimOpts.left && i <= j && codepoints.indexOf(s[i].codePointAt(0)) !== -1)\n    i++;\n  while (trimOpts.right && i <= j && codepoints.indexOf(s[j].codePointAt(0)) !== -1)\n    j--;\n  return s.substring(i, j + 1);\n}\nfunction regexSearch(obj, expr, options, reOpts) {\n  const val = computeValue(obj, expr, null, options);\n  if (!isString(val.input)) return [];\n  const regexOptions = val.options;\n  if (regexOptions) {\n    assert(\n      regexOptions.indexOf(\"x\") === -1,\n      \"extended capability option 'x' not supported\"\n    );\n    assert(regexOptions.indexOf(\"g\") === -1, \"global option 'g' not supported\");\n  }\n  let input = val.input;\n  const re = new RegExp(val.regex, regexOptions);\n  let m;\n  const matches = new Array();\n  let offset = 0;\n  while (m = re.exec(input)) {\n    const result = {\n      match: m[0],\n      idx: m.index + offset,\n      captures: []\n    };\n    for (let i = 1; i < m.length; i++) result.captures.push(m[i] || null);\n    matches.push(result);\n    if (!reOpts.global) break;\n    offset = m.index + m[0].length;\n    input = input.substring(offset);\n  }\n  return matches;\n}\nexport {\n  regexSearch,\n  trimString\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isString } from \"../../../util\";\nconst $concat = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  assert(\n    args.every((v) => isString(v) || isNil(v)),\n    \"$concat only supports strings.\"\n  );\n  if (args.some(isNil)) return null;\n  return args.join(\"\");\n};\nexport {\n  $concat\n};\n","export * from \"./concat\";\nexport * from \"./indexOfBytes\";\nexport * from \"./ltrim\";\nexport * from \"./regexFind\";\nexport * from \"./regexFindAll\";\nexport * from \"./regexMatch\";\nexport * from \"./replaceAll\";\nexport * from \"./replaceOne\";\nexport * from \"./rtrim\";\nexport * from \"./split\";\nexport * from \"./strcasecmp\";\nexport * from \"./strLenBytes\";\nexport * from \"./strLenCP\";\nexport * from \"./substr\";\nexport * from \"./substrBytes\";\nexport * from \"./substrCP\";\nexport * from \"./toLower\";\nexport * from \"./toUpper\";\nexport * from \"./trim\";\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isNumber, isString } from \"../../../util\";\nconst $indexOfBytes = (obj, expr, options) => {\n  const arr = computeValue(obj, expr, null, options);\n  const errorMsg = \"$indexOfBytes expression resolves to invalid an argument\";\n  if (isNil(arr[0])) return null;\n  assert(isString(arr[0]) && isString(arr[1]), errorMsg);\n  const str = arr[0];\n  const searchStr = arr[1];\n  let start = arr[2];\n  let end = arr[3];\n  let valid = isNil(start) || isNumber(start) && start >= 0 && Math.round(start) === start;\n  valid = valid && (isNil(end) || isNumber(end) && end >= 0 && Math.round(end) === end);\n  assert(valid, errorMsg);\n  start = start || 0;\n  end = end || str.length;\n  if (start > end) return -1;\n  const index = str.substring(start, end).indexOf(searchStr);\n  return index > -1 ? index + start : index;\n};\nexport {\n  $indexOfBytes\n};\n","import { trimString } from \"./_internal\";\nconst $ltrim = (obj, expr, options) => {\n  return trimString(obj, expr, options, { left: true, right: false });\n};\nexport {\n  $ltrim\n};\n","import { regexSearch } from \"./_internal\";\nconst $regexFind = (obj, expr, options) => {\n  const result = regexSearch(obj, expr, options, { global: false });\n  return result && result.length > 0 ? result[0] : null;\n};\nexport {\n  $regexFind\n};\n","import { regexSearch } from \"./_internal\";\nconst $regexFindAll = (obj, expr, options) => {\n  return regexSearch(obj, expr, options, { global: true });\n};\nexport {\n  $regexFindAll\n};\n","import { regexSearch } from \"./_internal\";\nconst $regexMatch = (obj, expr, options) => {\n  return regexSearch(obj, expr, options, { global: false }).length != 0;\n};\nexport {\n  $regexMatch\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isString } from \"../../../util\";\nconst $replaceAll = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const arr = [args.input, args.find, args.replacement];\n  if (arr.some(isNil)) return null;\n  assert(\n    arr.every(isString),\n    \"$replaceAll expression fields must evaluate to string\"\n  );\n  return args.input.replace(new RegExp(args.find, \"g\"), args.replacement);\n};\nexport {\n  $replaceAll\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isString } from \"../../../util\";\nconst $replaceOne = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const arr = [args.input, args.find, args.replacement];\n  if (arr.some(isNil)) return null;\n  assert(\n    arr.every(isString),\n    \"$replaceOne expression fields must evaluate to string\"\n  );\n  return args.input.replace(args.find, args.replacement);\n};\nexport {\n  $replaceOne\n};\n","import { trimString } from \"./_internal\";\nconst $rtrim = (obj, expr, options) => {\n  return trimString(obj, expr, options, { left: false, right: true });\n};\nexport {\n  $rtrim\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNil, isString } from \"../../../util\";\nconst $split = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  if (isNil(args[0])) return null;\n  assert(\n    args.every(isString),\n    \"$split expression must result to array(2) of strings\"\n  );\n  return args[0].split(args[1]);\n};\nexport {\n  $split\n};\n","import { computeValue } from \"../../../core\";\nconst $strLenBytes = (obj, expr, options) => {\n  return ~-encodeURI(computeValue(obj, expr, null, options)).split(\n    /%..|./\n  ).length;\n};\nexport {\n  $strLenBytes\n};\n","import { computeValue } from \"../../../core\";\nconst $strLenCP = (obj, expr, options) => {\n  return computeValue(obj, expr, null, options).length;\n};\nexport {\n  $strLenCP\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isEqual, isNil, isString } from \"../../../util\";\nconst $strcasecmp = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  let a = args[0];\n  let b = args[1];\n  if (isEqual(a, b) || args.every(isNil)) return 0;\n  assert(\n    args.every(isString),\n    \"$strcasecmp must resolve to array(2) of strings\"\n  );\n  a = a.toUpperCase();\n  b = b.toUpperCase();\n  return a > b && 1 || a < b && -1 || 0;\n};\nexport {\n  $strcasecmp\n};\n","import { computeValue } from \"../../../core\";\nimport { isString } from \"../../../util\";\nconst $substr = (obj, expr, options) => {\n  const [s, start, count] = computeValue(obj, expr, null, options);\n  if (start < 0 || !isString(s)) return \"\";\n  if (count < 0) return s.substring(start);\n  return s.substring(start, start + count);\n};\nexport {\n  $substr\n};\n","import { computeValue } from \"../../../core\";\nimport { assert, isNumber, isString } from \"../../../util\";\nconst UTF8_MASK = [192, 224, 240];\nfunction toUtf8(n) {\n  if (n < 128) return [n];\n  let count = n < 2048 && 1 || n < 65536 && 2 || 3;\n  const offset = UTF8_MASK[count - 1];\n  const utf8 = [(n >> 6 * count) + offset];\n  while (count > 0) utf8.push(128 | n >> 6 * --count & 63);\n  return utf8;\n}\nfunction utf8Encode(s) {\n  const buf = [];\n  for (let i = 0, len = s.length; i < len; i++) {\n    buf.push(toUtf8(s.codePointAt(i)));\n  }\n  return buf;\n}\nconst $substrBytes = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const s = args[0];\n  const index = args[1];\n  const count = args[2];\n  assert(\n    isString(s) && isNumber(index) && index >= 0 && isNumber(count) && count >= 0,\n    \"$substrBytes: invalid arguments\"\n  );\n  const buf = utf8Encode(s);\n  const validIndex = [];\n  let acc = 0;\n  for (let i = 0; i < buf.length; i++) {\n    validIndex.push(acc);\n    acc += buf[i].length;\n  }\n  const begin = validIndex.indexOf(index);\n  const end = validIndex.indexOf(index + count);\n  assert(\n    begin > -1 && end > -1,\n    \"$substrBytes: invalid range, start or end index is a UTF-8 continuation byte.\"\n  );\n  return s.substring(begin, end);\n};\nexport {\n  $substrBytes\n};\n","import { $substr } from \"./substr\";\nconst $substrCP = (obj, expr, options) => {\n  return $substr(obj, expr, options);\n};\nexport {\n  $substrCP\n};\n","import { computeValue } from \"../../../core\";\nimport { isEmpty } from \"../../../util\";\nconst $toLower = (obj, expr, options) => {\n  const value = computeValue(obj, expr, null, options);\n  return isEmpty(value) ? \"\" : value.toLowerCase();\n};\nexport {\n  $toLower\n};\n","import { computeValue } from \"../../../core\";\nimport { isEmpty } from \"../../../util\";\nconst $toUpper = (obj, expr, options) => {\n  const value = computeValue(obj, expr, null, options);\n  return isEmpty(value) ? \"\" : value.toUpperCase();\n};\nexport {\n  $toUpper\n};\n","import { trimString } from \"./_internal\";\nconst $trim = (obj, expr, options) => {\n  return trimString(obj, expr, options, { left: true, right: true });\n};\nexport {\n  $trim\n};\n","import { computeValue } from \"../../../core\";\nimport { MingoError } from \"../../../util\";\nconst FIXED_POINTS = {\n  undefined: null,\n  null: null,\n  NaN: NaN,\n  Infinity: new Error(),\n  \"-Infinity\": new Error()\n};\nfunction createTrignometryOperator(f, fixedPoints = FIXED_POINTS) {\n  const fp = Object.assign({}, FIXED_POINTS, fixedPoints);\n  const keySet = new Set(Object.keys(fp));\n  return (obj, expr, options) => {\n    const n = computeValue(obj, expr, null, options);\n    if (keySet.has(`${n}`)) {\n      const res = fp[`${n}`];\n      if (res instanceof Error) {\n        throw new MingoError(\n          `cannot apply $${f.name} to -inf, value must in (-inf,inf)`\n        );\n      }\n      return res;\n    }\n    return f(n);\n  };\n}\nexport {\n  createTrignometryOperator\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $acos = createTrignometryOperator(Math.acos, {\n  Infinity: Infinity,\n  0: new Error()\n});\nexport {\n  $acos\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $acosh = createTrignometryOperator(Math.acosh, {\n  Infinity: Infinity,\n  0: new Error()\n});\nexport {\n  $acosh\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $asin = createTrignometryOperator(Math.asin);\nexport {\n  $asin\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $asinh = createTrignometryOperator(Math.asinh, {\n  Infinity: Infinity,\n  \"-Infinity\": -Infinity\n});\nexport {\n  $asinh\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $atan = createTrignometryOperator(Math.atan);\nexport {\n  $atan\n};\n","import { computeValue } from \"../../../core\";\nimport { isNil } from \"../../../util\";\nconst $atan2 = (obj, expr, options) => {\n  const [y, x] = computeValue(obj, expr, null, options);\n  if (isNaN(y) || isNil(y)) return y;\n  if (isNaN(x) || isNil(x)) return x;\n  return Math.atan2(y, x);\n};\nexport {\n  $atan2\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $atanh = createTrignometryOperator(Math.atanh, {\n  1: Infinity,\n  \"-1\": -Infinity\n});\nexport {\n  $atanh\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $cos = createTrignometryOperator(Math.cos);\nexport {\n  $cos\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $cosh = createTrignometryOperator(Math.cosh, {\n  \"-Infinity\": Infinity,\n  Infinity: Infinity\n});\nexport {\n  $cosh\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst RADIANS_FACTOR = Math.PI / 180;\nconst $degreesToRadians = createTrignometryOperator(\n  (n) => n * RADIANS_FACTOR,\n  {\n    Infinity: Infinity,\n    \"-Infinity\": Infinity\n  }\n);\nexport {\n  $degreesToRadians\n};\n","export * from \"./acos\";\nexport * from \"./acosh\";\nexport * from \"./asin\";\nexport * from \"./asinh\";\nexport * from \"./atan\";\nexport * from \"./atan2\";\nexport * from \"./atanh\";\nexport * from \"./cos\";\nexport * from \"./cosh\";\nexport * from \"./degreesToRadians\";\nexport * from \"./radiansToDegrees\";\nexport * from \"./sin\";\nexport * from \"./sinh\";\nexport * from \"./tan\";\n","import { createTrignometryOperator } from \"./_internal\";\nconst DEGREES_FACTOR = 180 / Math.PI;\nconst $radiansToDegrees = createTrignometryOperator(\n  (n) => n * DEGREES_FACTOR,\n  {\n    Infinity: Infinity,\n    \"-Infinity\": -Infinity\n  }\n);\nexport {\n  $radiansToDegrees\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $sin = createTrignometryOperator(Math.sin);\nexport {\n  $sin\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $sinh = createTrignometryOperator(Math.sinh, {\n  \"-Infinity\": -Infinity,\n  Infinity: Infinity\n});\nexport {\n  $sinh\n};\n","import { createTrignometryOperator } from \"./_internal\";\nconst $tan = createTrignometryOperator(Math.tan);\nexport {\n  $tan\n};\n","import { computeValue } from \"../../../core\";\nimport { isDate, isNil, isNumber, isString } from \"../../../util\";\nconst MAX_INT = 2147483647;\nconst MIN_INT = -2147483648;\nconst MAX_LONG = Number.MAX_SAFE_INTEGER;\nconst MIN_LONG = Number.MIN_SAFE_INTEGER;\nclass TypeConvertError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\nfunction toInteger(obj, expr, options, min, max) {\n  const val = computeValue(obj, expr, null, options);\n  if (val === true) return 1;\n  if (val === false) return 0;\n  if (isNil(val)) return null;\n  if (isDate(val)) return val.getTime();\n  const n = Number(val);\n  if (isNumber(n) && n >= min && n <= max) {\n    if (!isString(val) || n.toString().indexOf(\".\") === -1) {\n      return Math.trunc(n);\n    }\n  }\n  throw new TypeConvertError(\n    `cannot convert '${val}' to ${max == MAX_INT ? \"int\" : \"long\"}`\n  );\n}\nexport {\n  MAX_INT,\n  MAX_LONG,\n  MIN_INT,\n  MIN_LONG,\n  TypeConvertError,\n  toInteger\n};\n","import { computeValue } from \"../../../core\";\nimport { isNil } from \"../../../util\";\nimport { TypeConvertError } from \"./_internal\";\nimport { $toBool } from \"./toBool\";\nimport { $toDate } from \"./toDate\";\nimport { $toDouble } from \"./toDouble\";\nimport { $toInt } from \"./toInt\";\nimport { $toLong } from \"./toLong\";\nimport { $toString } from \"./toString\";\nconst $convert = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  args.onNull = args.onNull === void 0 ? null : args.onNull;\n  if (isNil(args.input)) return args.onNull;\n  try {\n    switch (args.to) {\n      case 2:\n      case \"string\":\n        return $toString(obj, args.input, options);\n      case 8:\n      case \"boolean\":\n      case \"bool\":\n        return $toBool(obj, args.input, options);\n      case 9:\n      case \"date\":\n        return $toDate(obj, args.input, options);\n      case 1:\n      case 19:\n      case \"double\":\n      case \"decimal\":\n      case \"number\":\n        return $toDouble(obj, args.input, options);\n      case 16:\n      case \"int\":\n        return $toInt(obj, args.input, options);\n      case 18:\n      case \"long\":\n        return $toLong(obj, args.input, options);\n    }\n  } catch {\n  }\n  if (args.onError !== void 0) return args.onError;\n  throw new TypeConvertError(`could not convert to type ${args.to}.`);\n};\nexport {\n  $convert\n};\n","export * from \"./convert\";\nexport * from \"./isNumber\";\nexport * from \"./toBool\";\nexport * from \"./toDate\";\nexport * from \"./toDecimal\";\nexport * from \"./toDouble\";\nexport * from \"./toInt\";\nexport * from \"./toLong\";\nexport * from \"./toString\";\nexport * from \"./type\";\n","import { computeValue } from \"../../../core\";\nimport { isNumber } from \"../../../util\";\nconst $isNumber = (obj, expr, options) => {\n  const n = computeValue(obj, expr, null, options);\n  return isNumber(n);\n};\nexport {\n  $isNumber\n};\n","import { computeValue } from \"../../../core\";\nimport { isNil, isString } from \"../../../util\";\nconst $toBool = (obj, expr, options) => {\n  const val = computeValue(obj, expr, null, options);\n  if (isNil(val)) return null;\n  if (isString(val)) return true;\n  return Boolean(val);\n};\nexport {\n  $toBool\n};\n","import { computeValue } from \"../../../core\";\nimport { isDate, isNil } from \"../../../util\";\nimport { TypeConvertError } from \"./_internal\";\nconst $toDate = (obj, expr, options) => {\n  const val = computeValue(obj, expr, null, options);\n  if (isDate(val)) return val;\n  if (isNil(val)) return null;\n  const d = new Date(val);\n  const n = d.getTime();\n  if (!isNaN(n)) return d;\n  throw new TypeConvertError(`cannot convert '${val}' to date`);\n};\nexport {\n  $toDate\n};\n","import { $toDouble } from \"./toDouble\";\nconst $toDecimal = $toDouble;\nexport {\n  $toDecimal\n};\n","import { computeValue } from \"../../../core\";\nimport { isDate, isNil, isNumber } from \"../../../util\";\nimport { TypeConvertError } from \"./_internal\";\nconst $toDouble = (obj, expr, options) => {\n  const val = computeValue(obj, expr, null, options);\n  if (isNil(val)) return null;\n  if (isDate(val)) return val.getTime();\n  if (val === true) return 1;\n  if (val === false) return 0;\n  const n = Number(val);\n  if (isNumber(n)) return n;\n  throw new TypeConvertError(`cannot convert '${val}' to double/decimal`);\n};\nexport {\n  $toDouble\n};\n","import { MAX_INT, MIN_INT, toInteger } from \"./_internal\";\nconst $toInt = (obj, expr, options) => toInteger(obj, expr, options, MIN_INT, MAX_INT);\nexport {\n  $toInt\n};\n","import { MAX_LONG, MIN_LONG, toInteger } from \"./_internal\";\nconst $toLong = (obj, expr, options) => toInteger(obj, expr, options, MIN_LONG, MAX_LONG);\nexport {\n  $toLong\n};\n","import { computeValue } from \"../../../core\";\nimport { isDate, isNil } from \"../../../util\";\nimport { $dateToString } from \"../date/dateToString\";\nconst $toString = (obj, expr, options) => {\n  const val = computeValue(obj, expr, null, options);\n  if (isNil(val)) return null;\n  if (isDate(val)) {\n    return $dateToString(\n      obj,\n      {\n        date: expr,\n        format: \"%Y-%m-%dT%H:%M:%S.%LZ\"\n      },\n      options\n    );\n  }\n  return val.toString();\n};\nexport {\n  $toString\n};\n","import { computeValue } from \"../../../core\";\nimport { isNumber, isRegExp, typeOf } from \"../../../util\";\nimport { MAX_INT, MIN_INT } from \"./_internal\";\nconst $type = (obj, expr, options) => {\n  const v = computeValue(obj, expr, null, options);\n  if (options.useStrictMode) {\n    if (v === void 0) return \"missing\";\n    if (v === true || v === false) return \"bool\";\n    if (isNumber(v)) {\n      if (v % 1 != 0) return \"double\";\n      return v >= MIN_INT && v <= MAX_INT ? \"int\" : \"long\";\n    }\n    if (isRegExp(v)) return \"regex\";\n  }\n  return typeOf(v);\n};\nexport {\n  $type\n};\n","export * from \"./let\";\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../../core\";\nconst $let = (obj, expr, options) => {\n  const variables = {};\n  for (const [key, val] of Object.entries(expr.vars)) {\n    variables[key] = computeValue(obj, val, null, options);\n  }\n  return computeValue(\n    obj,\n    expr.in,\n    null,\n    ComputeOptions.init(options, obj, { variables })\n  );\n};\nexport {\n  $let\n};\n","const isUnbounded = (window) => {\n  const boundary = window?.documents || window?.range;\n  return !boundary || boundary[0] === \"unbounded\" && boundary[1] === \"unbounded\";\n};\nexport {\n  isUnbounded\n};\n","import { computeValue } from \"../../core\";\nimport { removeValue, setValue } from \"../../util\";\nconst $addFields = (collection, expr, options) => {\n  const newFields = Object.keys(expr);\n  if (newFields.length === 0) return collection;\n  return collection.map((obj) => {\n    const newObj = { ...obj };\n    for (const field of newFields) {\n      const newValue = computeValue(obj, expr[field], null, options);\n      if (newValue !== void 0) {\n        setValue(newObj, field, newValue);\n      } else {\n        removeValue(newObj, field);\n      }\n    }\n    return newObj;\n  });\n};\nexport {\n  $addFields\n};\n","import { computeValue } from \"../../core\";\nimport { Lazy } from \"../../lazy\";\nimport { assert, compare, findInsertIndex, isNil, typeOf } from \"../../util\";\nconst $bucket = (collection, expr, options) => {\n  const bounds = [...expr.boundaries];\n  const defaultKey = expr.default;\n  const lower = bounds[0];\n  const upper = bounds[bounds.length - 1];\n  const outputExpr = expr.output || { count: { $sum: 1 } };\n  assert(bounds.length > 1, \"$bucket must specify at least two boundaries.\");\n  const isValid = bounds.every(\n    (v, i) => i === 0 || typeOf(v) === typeOf(bounds[i - 1]) && compare(v, bounds[i - 1]) > 0\n  );\n  assert(\n    isValid,\n    `$bucket: bounds must be of same type and in ascending order`\n  );\n  if (!isNil(defaultKey) && typeOf(defaultKey) === typeOf(lower)) {\n    assert(\n      compare(defaultKey, upper) >= 0 || compare(defaultKey, lower) < 0,\n      \"$bucket 'default' expression must be out of boundaries range\"\n    );\n  }\n  const createBuckets = () => {\n    const buckets = /* @__PURE__ */ new Map();\n    for (let i = 0; i < bounds.length - 1; i++) {\n      buckets.set(bounds[i], []);\n    }\n    if (!isNil(defaultKey)) buckets.set(defaultKey, []);\n    collection.each((obj) => {\n      const key = computeValue(obj, expr.groupBy, null, options);\n      if (isNil(key) || compare(key, lower) < 0 || compare(key, upper) >= 0) {\n        assert(\n          !isNil(defaultKey),\n          \"$bucket require a default for out of range values\"\n        );\n        buckets.get(defaultKey).push(obj);\n      } else {\n        assert(\n          compare(key, lower) >= 0 && compare(key, upper) < 0,\n          \"$bucket 'groupBy' expression must resolve to a value in range of boundaries\"\n        );\n        const index = findInsertIndex(bounds, key);\n        const boundKey = bounds[Math.max(0, index - 1)];\n        buckets.get(boundKey).push(obj);\n      }\n    });\n    bounds.pop();\n    if (!isNil(defaultKey)) bounds.push(defaultKey);\n    assert(\n      buckets.size === bounds.length,\n      \"bounds and groups must be of equal size.\"\n    );\n    return Lazy(bounds).map((key) => {\n      return {\n        ...computeValue(\n          buckets.get(key),\n          outputExpr,\n          null,\n          options\n        ),\n        _id: key\n      };\n    });\n  };\n  let iterator;\n  return Lazy(() => {\n    if (!iterator) iterator = createBuckets();\n    return iterator.next();\n  });\n};\nexport {\n  $bucket\n};\n","import { computeValue } from \"../../core\";\nimport { Lazy } from \"../../lazy\";\nimport {\n  assert,\n  compare,\n  findInsertIndex,\n  isArray,\n  isEqual,\n  isNil,\n  isNumber\n} from \"../../util\";\nconst $bucketAuto = (collection, expr, options) => {\n  const {\n    buckets: bucketCount,\n    groupBy: groupByExpr,\n    output: optOutputExpr,\n    // Available only if the all groupBy values are numeric and none of them are NaN.\n    granularity\n  } = expr;\n  const outputExpr = optOutputExpr ?? { count: { $sum: 1 } };\n  assert(\n    bucketCount > 0,\n    `$bucketAuto: 'buckets' field must be greater than 0, but found: ${bucketCount}`\n  );\n  if (granularity) {\n    assert(\n      /^(POWERSOF2|1-2-5|E(6|12|24|48|96|192)|R(5|10|20|40|80))$/.test(\n        granularity\n      ),\n      `$bucketAuto: invalid granularity '${granularity}'.`\n    );\n  }\n  const keyMap = /* @__PURE__ */ new Map();\n  const setKey = !granularity ? (o, k) => keyMap.set(o, k) : (_, _2) => {\n  };\n  const sorted = collection.map((o) => {\n    const k = computeValue(o, groupByExpr, null, options) ?? null;\n    assert(\n      !granularity || isNumber(k),\n      \"$bucketAuto: groupBy values must be numeric when granularity is specified.\"\n    );\n    setKey(o, k ?? null);\n    return [k ?? null, o];\n  }).value();\n  sorted.sort((x, y) => {\n    if (isNil(x[0])) return -1;\n    if (isNil(y[0])) return 1;\n    return compare(x[0], y[0]);\n  });\n  let getNext;\n  if (!granularity) {\n    getNext = granularityDefault(sorted, bucketCount, keyMap);\n  } else if (granularity == \"POWERSOF2\") {\n    getNext = granularityPowerOfTwo(\n      sorted,\n      bucketCount\n    );\n  } else {\n    getNext = granularityPreferredSeries(\n      sorted,\n      bucketCount,\n      granularity\n    );\n  }\n  let terminate = false;\n  return Lazy(() => {\n    if (terminate) return { done: true };\n    const { min, max, bucket, done } = getNext();\n    terminate = done;\n    const outFields = computeValue(\n      bucket,\n      outputExpr,\n      null,\n      options\n    );\n    for (const [k, v] of Object.entries(outFields)) {\n      if (isArray(v)) outFields[k] = v.filter((v2) => v2 !== void 0);\n    }\n    return {\n      done: false,\n      value: {\n        ...outFields,\n        _id: { min, max }\n      }\n    };\n  });\n};\nfunction granularityDefault(sorted, bucketCount, keyMap) {\n  const size = sorted.length;\n  const approxBucketSize = Math.max(1, Math.round(sorted.length / bucketCount));\n  let index = 0;\n  let nBuckets = 0;\n  return () => {\n    const isLastBucket = ++nBuckets == bucketCount;\n    const bucket = new Array();\n    while (index < size && (isLastBucket || bucket.length < approxBucketSize || index > 0 && isEqual(sorted[index - 1][0], sorted[index][0]))) {\n      bucket.push(sorted[index++][1]);\n    }\n    const min = keyMap.get(bucket[0]);\n    let max;\n    if (index < size) {\n      max = sorted[index][0];\n    } else {\n      max = keyMap.get(bucket[bucket.length - 1]);\n    }\n    assert(\n      isNil(max) || isNil(min) || min <= max,\n      `error: $bucketAuto boundary must be in order.`\n    );\n    return {\n      min,\n      max,\n      bucket,\n      done: index >= size\n    };\n  };\n}\nfunction granularityPowerOfTwo(sorted, bucketCount) {\n  const size = sorted.length;\n  const approxBucketSize = Math.max(1, Math.round(sorted.length / bucketCount));\n  const roundUp2 = (n) => n === 0 ? 0 : 2 ** (Math.floor(Math.log2(n)) + 1);\n  let index = 0;\n  let min = 0;\n  let max = 0;\n  return () => {\n    const bucket = new Array();\n    const boundValue = roundUp2(max);\n    min = index > 0 ? max : 0;\n    while (bucket.length < approxBucketSize && index < size && (max === 0 || sorted[index][0] < boundValue)) {\n      bucket.push(sorted[index++][1]);\n    }\n    max = max == 0 ? roundUp2(sorted[index - 1][0]) : boundValue;\n    while (index < size && sorted[index][0] < max) {\n      bucket.push(sorted[index++][1]);\n    }\n    return {\n      min,\n      max,\n      bucket,\n      done: index >= size\n    };\n  };\n}\nconst PREFERRED_NUMBERS = Object.freeze({\n  // \"Least rounded\" Renard number series, taken from Wikipedia page on preferred\n  // numbers: https://en.wikipedia.org/wiki/Preferred_number#Renard_numbers\n  R5: [10, 16, 25, 40, 63],\n  R10: [100, 125, 160, 200, 250, 315, 400, 500, 630, 800],\n  R20: [\n    100,\n    112,\n    125,\n    140,\n    160,\n    180,\n    200,\n    224,\n    250,\n    280,\n    315,\n    355,\n    400,\n    450,\n    500,\n    560,\n    630,\n    710,\n    800,\n    900\n  ],\n  R40: [\n    100,\n    106,\n    112,\n    118,\n    125,\n    132,\n    140,\n    150,\n    160,\n    170,\n    180,\n    190,\n    200,\n    212,\n    224,\n    236,\n    250,\n    265,\n    280,\n    300,\n    315,\n    355,\n    375,\n    400,\n    425,\n    450,\n    475,\n    500,\n    530,\n    560,\n    600,\n    630,\n    670,\n    710,\n    750,\n    800,\n    850,\n    900,\n    950\n  ],\n  R80: [\n    103,\n    109,\n    115,\n    122,\n    128,\n    136,\n    145,\n    155,\n    165,\n    175,\n    185,\n    195,\n    206,\n    218,\n    230,\n    243,\n    258,\n    272,\n    290,\n    307,\n    325,\n    345,\n    365,\n    387,\n    412,\n    437,\n    462,\n    487,\n    515,\n    545,\n    575,\n    615,\n    650,\n    690,\n    730,\n    775,\n    825,\n    875,\n    925,\n    975\n  ],\n  // https://en.wikipedia.org/wiki/Preferred_number#1-2-5_series\n  \"1-2-5\": [10, 20, 50],\n  // E series, taken from Wikipedia page on preferred numbers:\n  // https://en.wikipedia.org/wiki/Preferred_number#E_series\n  E6: [10, 15, 22, 33, 47, 68],\n  E12: [10, 12, 15, 18, 22, 27, 33, 39, 47, 56, 68, 82],\n  E24: [\n    10,\n    11,\n    12,\n    13,\n    15,\n    16,\n    18,\n    20,\n    22,\n    24,\n    27,\n    30,\n    33,\n    36,\n    39,\n    43,\n    47,\n    51,\n    56,\n    62,\n    68,\n    75,\n    82,\n    91\n  ],\n  E48: [\n    100,\n    105,\n    110,\n    115,\n    121,\n    127,\n    133,\n    140,\n    147,\n    154,\n    162,\n    169,\n    178,\n    187,\n    196,\n    205,\n    215,\n    226,\n    237,\n    249,\n    261,\n    274,\n    287,\n    301,\n    316,\n    332,\n    348,\n    365,\n    383,\n    402,\n    422,\n    442,\n    464,\n    487,\n    511,\n    536,\n    562,\n    590,\n    619,\n    649,\n    681,\n    715,\n    750,\n    787,\n    825,\n    866,\n    909,\n    953\n  ],\n  E96: [\n    100,\n    102,\n    105,\n    107,\n    110,\n    113,\n    115,\n    118,\n    121,\n    124,\n    127,\n    130,\n    133,\n    137,\n    140,\n    143,\n    147,\n    150,\n    154,\n    158,\n    162,\n    165,\n    169,\n    174,\n    178,\n    182,\n    187,\n    191,\n    196,\n    200,\n    205,\n    210,\n    215,\n    221,\n    226,\n    232,\n    237,\n    243,\n    249,\n    255,\n    261,\n    267,\n    274,\n    280,\n    287,\n    294,\n    301,\n    309,\n    316,\n    324,\n    332,\n    340,\n    348,\n    357,\n    365,\n    374,\n    383,\n    392,\n    402,\n    412,\n    422,\n    432,\n    442,\n    453,\n    464,\n    475,\n    487,\n    499,\n    511,\n    523,\n    536,\n    549,\n    562,\n    576,\n    590,\n    604,\n    619,\n    634,\n    649,\n    665,\n    681,\n    698,\n    715,\n    732,\n    750,\n    768,\n    787,\n    806,\n    825,\n    845,\n    866,\n    887,\n    909,\n    931,\n    953,\n    976\n  ],\n  E192: [\n    100,\n    101,\n    102,\n    104,\n    105,\n    106,\n    107,\n    109,\n    110,\n    111,\n    113,\n    114,\n    115,\n    117,\n    118,\n    120,\n    121,\n    123,\n    124,\n    126,\n    127,\n    129,\n    130,\n    132,\n    133,\n    135,\n    137,\n    138,\n    140,\n    142,\n    143,\n    145,\n    147,\n    149,\n    150,\n    152,\n    154,\n    156,\n    158,\n    160,\n    162,\n    164,\n    165,\n    167,\n    169,\n    172,\n    174,\n    176,\n    178,\n    180,\n    182,\n    184,\n    187,\n    189,\n    191,\n    193,\n    196,\n    198,\n    200,\n    203,\n    205,\n    208,\n    210,\n    213,\n    215,\n    218,\n    221,\n    223,\n    226,\n    229,\n    232,\n    234,\n    237,\n    240,\n    243,\n    246,\n    249,\n    252,\n    255,\n    258,\n    261,\n    264,\n    267,\n    271,\n    274,\n    277,\n    280,\n    284,\n    287,\n    291,\n    294,\n    298,\n    301,\n    305,\n    309,\n    312,\n    316,\n    320,\n    324,\n    328,\n    332,\n    336,\n    340,\n    344,\n    348,\n    352,\n    357,\n    361,\n    365,\n    370,\n    374,\n    379,\n    383,\n    388,\n    392,\n    397,\n    402,\n    407,\n    412,\n    417,\n    422,\n    427,\n    432,\n    437,\n    442,\n    448,\n    453,\n    459,\n    464,\n    470,\n    475,\n    481,\n    487,\n    493,\n    499,\n    505,\n    511,\n    517,\n    523,\n    530,\n    536,\n    542,\n    549,\n    556,\n    562,\n    569,\n    576,\n    583,\n    590,\n    597,\n    604,\n    612,\n    619,\n    626,\n    634,\n    642,\n    649,\n    657,\n    665,\n    673,\n    681,\n    690,\n    698,\n    706,\n    715,\n    723,\n    732,\n    741,\n    750,\n    759,\n    768,\n    777,\n    787,\n    796,\n    806,\n    816,\n    825,\n    835,\n    845,\n    856,\n    866,\n    876,\n    887,\n    898,\n    909,\n    920,\n    931,\n    942,\n    953,\n    965,\n    976,\n    988\n  ]\n});\nconst roundUp = (n, granularity) => {\n  if (n == 0) return 0;\n  const series = PREFERRED_NUMBERS[granularity];\n  const first = series[0];\n  const last = series[series.length - 1];\n  let multiplier = 1;\n  while (n >= last * multiplier) {\n    multiplier *= 10;\n  }\n  let previousMin = 0;\n  while (n < first * multiplier) {\n    previousMin = first * multiplier;\n    multiplier /= 10;\n    if (n >= last * multiplier) {\n      return previousMin;\n    }\n  }\n  assert(\n    n >= first * multiplier && n < last * multiplier,\n    \"$bucketAuto: number out of range of series.\"\n  );\n  const i = findInsertIndex(series, n, (a, b) => {\n    b *= multiplier;\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  const seriesNumber = series[i] * multiplier;\n  return n == seriesNumber ? series[i + 1] * multiplier : seriesNumber;\n};\nfunction granularityPreferredSeries(sorted, bucketCount, granularity) {\n  const size = sorted.length;\n  const approxBucketSize = Math.max(1, Math.round(sorted.length / bucketCount));\n  let index = 0;\n  let nBuckets = 0;\n  let min = 0;\n  let max = 0;\n  return () => {\n    const isLastBucket = ++nBuckets == bucketCount;\n    const bucket = new Array();\n    min = index > 0 ? max : 0;\n    while (index < size && (isLastBucket || bucket.length < approxBucketSize)) {\n      bucket.push(sorted[index++][1]);\n    }\n    max = roundUp(sorted[index - 1][0], granularity);\n    const nItems = bucket.length;\n    while (index < size && (isLastBucket || sorted[index][0] < max)) {\n      bucket.push(sorted[index++][1]);\n    }\n    if (nItems != bucket.length) {\n      max = roundUp(sorted[index - 1][0], granularity);\n    }\n    assert(min < max, `$bucketAuto: ${min} < ${max}.`);\n    return {\n      min,\n      max,\n      bucket,\n      done: index >= size\n    };\n  };\n}\nexport {\n  $bucketAuto\n};\n","import { Lazy } from \"../../lazy\";\nimport { assert, isEmpty, isString } from \"../../util\";\nconst $count = (collection, expr, _options) => {\n  assert(\n    isString(expr) && !isEmpty(expr) && expr.indexOf(\".\") === -1 && expr.trim()[0] !== \"$\",\n    \"Invalid expression value for $count\"\n  );\n  return Lazy([\n    {\n      [expr]: collection.size()\n    }\n  ]);\n};\nexport {\n  $count\n};\n","import { ComputeOptions } from \"../../core\";\nimport { concat, Lazy } from \"../../lazy\";\nimport { TIME_UNITS } from \"../../types\";\nimport {\n  assert,\n  isArray,\n  isDate,\n  isNil,\n  isNumber,\n  isObject,\n  isString,\n  resolve,\n  ValueMap\n} from \"../../util\";\nimport { $dateAdd } from \"../expression/date/dateAdd\";\nimport { $sort } from \"./sort\";\nconst EMPTY_OBJECT = Object.freeze({});\nconst $densify = (collection, expr, options) => {\n  const { step, bounds, unit } = expr.range;\n  if (unit) {\n    assert(TIME_UNITS.includes(unit), \"\");\n    assert(\n      Number.isInteger(step) && step > 0,\n      \"The step parameter in a range statement must be a whole number when densifying a date range.\"\n    );\n  } else {\n    assert(\n      isNumber(step) && step > 0,\n      \"The step parameter in a range statement must be a strictly positive numeric value.\"\n    );\n  }\n  if (isArray(bounds)) {\n    assert(\n      !!bounds && bounds.length === 2,\n      \"A bounding array in a range statement must have exactly two elements.\"\n    );\n    assert(\n      (bounds.every(isNumber) || bounds.every(isDate)) && bounds[0] < bounds[1],\n      \"A bounding array must be an ascending array of either two dates or two numbers.\"\n    );\n    assert(\n      unit && !bounds.some(isNumber),\n      \"Numeric bounds may not have unit parameter.\"\n    );\n  }\n  if (expr.partitionByFields) {\n    assert(\n      isArray(expr.partitionByFields),\n      \"$densify: `partitionByFields` must be an array of strings\"\n    );\n  }\n  collection = $sort(collection, { [expr.field]: 1 }, options);\n  const nilOptions = ComputeOptions.init(options, null);\n  const computeNextValue = (value) => {\n    return isNumber(value) ? value + step : $dateAdd(\n      EMPTY_OBJECT,\n      { startDate: value, unit, amount: step },\n      nilOptions\n    );\n  };\n  const isValidUnit = !!unit && TIME_UNITS.includes(unit);\n  const getFieldValue = (o) => {\n    const v = resolve(o, expr.field);\n    if (isNil(v)) return v;\n    if (isNumber(v)) {\n      assert(\n        !isValidUnit,\n        \"$densify: Encountered non-date value in collection when step has a date unit.\"\n      );\n    } else if (isDate(v)) {\n      assert(\n        isValidUnit,\n        \"$densify: Encountered date value in collection when step does not have a date unit.\"\n      );\n    } else {\n      assert(false, \"$densify: Densify field type must be numeric or a date\");\n    }\n    return v;\n  };\n  const peekItem = new Array();\n  const nilFieldsIterator = Lazy(() => {\n    const item = collection.next();\n    const fieldValue = getFieldValue(item.value);\n    if (isNil(fieldValue)) return item;\n    peekItem.push(item);\n    return { done: true };\n  });\n  const nextDensifyValueMap = ValueMap.init(\n    options.hashFunction\n  );\n  const [lower, upper] = isArray(bounds) ? bounds : [bounds, bounds];\n  let maxFieldValue = void 0;\n  const updateMaxFieldValue = (value) => {\n    maxFieldValue = maxFieldValue === void 0 || maxFieldValue < value ? value : maxFieldValue;\n  };\n  const rootKey = [];\n  const densifyIterator = Lazy(() => {\n    const item = peekItem.length > 0 ? peekItem.pop() : collection.next();\n    if (item.done) return item;\n    let partitionKey = rootKey;\n    if (isArray(expr.partitionByFields)) {\n      partitionKey = expr.partitionByFields.map(\n        (k) => resolve(item.value, k)\n      );\n      assert(\n        partitionKey.every(isString),\n        \"$densify: Partition fields must evaluate to string values.\"\n      );\n    }\n    assert(isObject(item.value), \"$densify: collection must contain documents\");\n    const itemValue = getFieldValue(item.value);\n    if (!nextDensifyValueMap.has(partitionKey)) {\n      if (lower == \"full\") {\n        if (!nextDensifyValueMap.has(rootKey)) {\n          nextDensifyValueMap.set(rootKey, itemValue);\n        }\n        nextDensifyValueMap.set(partitionKey, nextDensifyValueMap.get(rootKey));\n      } else if (lower == \"partition\") {\n        nextDensifyValueMap.set(partitionKey, itemValue);\n      } else {\n        nextDensifyValueMap.set(partitionKey, lower);\n      }\n    }\n    const densifyValue = nextDensifyValueMap.get(partitionKey);\n    if (\n      // current item field value is lower than current densify value.\n      itemValue <= densifyValue || // range value equals or exceeds upper bound\n      upper != \"full\" && upper != \"partition\" && densifyValue >= upper\n    ) {\n      if (densifyValue <= itemValue) {\n        nextDensifyValueMap.set(partitionKey, computeNextValue(densifyValue));\n      }\n      updateMaxFieldValue(itemValue);\n      return item;\n    }\n    nextDensifyValueMap.set(partitionKey, computeNextValue(densifyValue));\n    updateMaxFieldValue(densifyValue);\n    const denseObj = { [expr.field]: densifyValue };\n    if (partitionKey) {\n      partitionKey.forEach((v, i) => {\n        denseObj[expr.partitionByFields[i]] = v;\n      });\n    }\n    peekItem.push(item);\n    return { done: false, value: denseObj };\n  });\n  if (lower !== \"full\") return concat(nilFieldsIterator, densifyIterator);\n  let paritionIndex = -1;\n  let partitionKeysSet = void 0;\n  const fullBoundsIterator = Lazy(() => {\n    if (paritionIndex === -1) {\n      const fullDensifyValue = nextDensifyValueMap.get(rootKey);\n      nextDensifyValueMap.delete(rootKey);\n      partitionKeysSet = Array.from(nextDensifyValueMap.keys());\n      if (partitionKeysSet.length === 0) {\n        partitionKeysSet.push(rootKey);\n        nextDensifyValueMap.set(rootKey, fullDensifyValue);\n      }\n      paritionIndex++;\n    }\n    do {\n      const partitionKey = partitionKeysSet[paritionIndex];\n      const partitionMaxValue = nextDensifyValueMap.get(partitionKey);\n      if (partitionMaxValue < maxFieldValue) {\n        nextDensifyValueMap.set(\n          partitionKey,\n          computeNextValue(partitionMaxValue)\n        );\n        const denseObj = { [expr.field]: partitionMaxValue };\n        partitionKey.forEach((v, i) => {\n          denseObj[expr.partitionByFields[i]] = v;\n        });\n        return { done: false, value: denseObj };\n      }\n      paritionIndex++;\n    } while (paritionIndex < partitionKeysSet.length);\n    return { done: true };\n  });\n  return concat(nilFieldsIterator, densifyIterator, fullBoundsIterator);\n};\nexport {\n  $densify\n};\n","import { Aggregator } from \"../../aggregator\";\nimport { ProcessingMode } from \"../../core\";\nconst $facet = (collection, expr, options) => {\n  return collection.transform((array) => {\n    const o = {};\n    for (const [k, pipeline] of Object.entries(expr)) {\n      o[k] = new Aggregator(pipeline, {\n        ...options,\n        processingMode: ProcessingMode.CLONE_INPUT\n      }).run(array);\n    }\n    return [o];\n  });\n};\nexport {\n  $facet\n};\n","import { initOptions } from \"../../core\";\nimport { assert, has, isObject } from \"../../util\";\nimport { $ifNull } from \"../expression/conditional/ifNull\";\nimport { $linearFill } from \"../window/linearFill\";\nimport { $locf } from \"../window/locf\";\nimport { $addFields } from \"./addFields\";\nimport { $setWindowFields } from \"./setWindowFields\";\nconst FILL_METHODS = {\n  locf: \"$locf\",\n  linear: \"$linearFill\"\n};\nconst $fill = (collection, expr, options) => {\n  assert(!expr.sortBy || isObject(expr.sortBy), \"sortBy must be an object.\");\n  assert(\n    !!expr.sortBy || Object.values(expr.output).every((m) => has(m, \"value\")),\n    \"sortBy required if any output field specifies a 'method'.\"\n  );\n  assert(\n    !(expr.partitionBy && expr.partitionByFields),\n    \"specify either partitionBy or partitionByFields.\"\n  );\n  assert(\n    !expr.partitionByFields || expr?.partitionByFields?.every((s) => s[0] !== \"$\"),\n    \"fields in partitionByFields cannot begin with '$'.\"\n  );\n  options = initOptions(options);\n  options.context.addExpressionOps({ $ifNull });\n  options.context.addWindowOps({ $locf, $linearFill });\n  const partitionExpr = expr.partitionBy || expr?.partitionByFields?.map((s) => \"$\" + s);\n  const valueExpr = {};\n  const methodExpr = {};\n  for (const [k, m] of Object.entries(expr.output)) {\n    if (has(m, \"value\")) {\n      valueExpr[k] = { $ifNull: [`$$CURRENT.${k}`, m[\"value\"]] };\n    } else {\n      const fillOp = FILL_METHODS[m[\"method\"]];\n      assert(!!fillOp, `invalid fill method '${m[\"method\"]}'.`);\n      methodExpr[k] = { [fillOp]: \"$\" + k };\n    }\n  }\n  if (Object.keys(methodExpr).length > 0) {\n    collection = $setWindowFields(\n      collection,\n      {\n        sortBy: expr.sortBy || {},\n        partitionBy: partitionExpr,\n        output: methodExpr\n      },\n      options\n    );\n  }\n  if (Object.keys(valueExpr).length > 0) {\n    collection = $addFields(collection, valueExpr, options);\n  }\n  return collection;\n};\nexport {\n  $fill\n};\n","import { computeValue } from \"../../core\";\nimport { Lazy } from \"../../lazy\";\nimport { flatten, isNil, isString, setValue, ValueMap } from \"../../util\";\nimport { $lookup } from \"./lookup\";\nconst $graphLookup = (collection, expr, options) => {\n  const fromColl = isString(expr.from) ? options?.collectionResolver(expr.from) : expr.from;\n  const {\n    connectFromField,\n    connectToField,\n    as: asField,\n    maxDepth,\n    depthField,\n    restrictSearchWithMatch: matchExpr\n  } = expr;\n  const pipelineExpr = matchExpr ? { pipeline: [{ $match: matchExpr }] } : {};\n  return collection.map((obj) => {\n    const matchObj = {};\n    setValue(\n      matchObj,\n      connectFromField,\n      computeValue(obj, expr.startWith, null, options)\n    );\n    let matches = [matchObj];\n    let i = -1;\n    const map = ValueMap.init(options.hashFunction);\n    do {\n      i++;\n      matches = flatten(\n        $lookup(\n          Lazy(matches),\n          {\n            from: fromColl,\n            localField: connectFromField,\n            foreignField: connectToField,\n            as: asField,\n            ...pipelineExpr\n          },\n          options\n        ).map((o) => o[asField]).value()\n      );\n      const oldSize = map.size;\n      matches.forEach((k) => map.set(k, map.get(k) ?? i));\n      if (oldSize == map.size) break;\n    } while (isNil(maxDepth) || i < maxDepth);\n    const result = new Array(map.size);\n    let n = 0;\n    map.forEach((v, k) => {\n      result[n++] = Object.assign(depthField ? { [depthField]: v } : {}, k);\n    });\n    return { ...obj, [asField]: result };\n  });\n};\nexport {\n  $graphLookup\n};\n","import {\n  ComputeOptions,\n  computeValue\n} from \"../../core\";\nimport { assert, groupBy, has } from \"../../util\";\nconst ID_KEY = \"_id\";\nconst $group = (collection, expr, options) => {\n  assert(has(expr, ID_KEY), \"$group specification must include an '_id'\");\n  const idExpr = expr[ID_KEY];\n  const copts = ComputeOptions.init(options);\n  const newFields = Object.keys(expr).filter((k) => k != ID_KEY);\n  return collection.transform((coll) => {\n    const partitions = groupBy(\n      coll,\n      (obj) => computeValue(obj, idExpr, null, options),\n      options.hashFunction\n    );\n    let i = -1;\n    const partitionKeys = Array.from(partitions.keys());\n    return () => {\n      if (++i === partitions.size) return { done: true };\n      const groupId = partitionKeys[i];\n      const obj = {};\n      if (groupId !== void 0) {\n        obj[ID_KEY] = groupId;\n      }\n      for (const key of newFields) {\n        obj[key] = computeValue(\n          partitions.get(groupId),\n          expr[key],\n          null,\n          copts.update(null, { groupId })\n        );\n      }\n      return { value: obj, done: false };\n    };\n  });\n};\nexport {\n  $group\n};\n","export * from \"./addFields\";\nexport * from \"./bucket\";\nexport * from \"./bucketAuto\";\nexport * from \"./count\";\nexport * from \"./densify\";\nexport * from \"./facet\";\nexport * from \"./fill\";\nexport * from \"./graphLookup\";\nexport * from \"./group\";\nexport * from \"./limit\";\nexport * from \"./lookup\";\nexport * from \"./match\";\nexport * from \"./merge\";\nexport * from \"./out\";\nexport * from \"./project\";\nexport * from \"./redact\";\nexport * from \"./replaceRoot\";\nexport * from \"./replaceWith\";\nexport * from \"./sample\";\nexport * from \"./set\";\nexport * from \"./setWindowFields\";\nexport * from \"./skip\";\nexport * from \"./sort\";\nexport * from \"./sortByCount\";\nexport * from \"./unionWith\";\nexport * from \"./unset\";\nexport * from \"./unwind\";\n","const $limit = (collection, expr, _options) => collection.take(expr);\nexport {\n  $limit\n};\n","import { Aggregator } from \"../../aggregator\";\nimport { computeValue } from \"../../core\";\nimport {\n  ensureArray,\n  flatten,\n  isArray,\n  isString,\n  resolve,\n  ValueMap\n} from \"../../util\";\nconst $lookup = (collection, expr, options) => {\n  const joinColl = isString(expr.from) ? options?.collectionResolver(expr.from) : expr.from;\n  const { let: letExpr, pipeline, foreignField, localField } = expr;\n  const subQueryPipeline = pipeline || [];\n  let lookupEq = (_) => [true, []];\n  if (foreignField && localField) {\n    const map = ValueMap.init(options.hashFunction);\n    for (const doc of joinColl) {\n      ensureArray(resolve(doc, foreignField) ?? null).forEach((v) => {\n        const xs = map.get(v);\n        const arr = xs ?? [];\n        arr.push(doc);\n        if (arr !== xs) map.set(v, arr);\n      });\n    }\n    lookupEq = (o) => {\n      const local = resolve(o, localField) ?? null;\n      if (isArray(local)) {\n        if (subQueryPipeline.length) {\n          return [local.some((v) => map.has(v)), null];\n        }\n        const result2 = Array.from(\n          new Set(flatten(local.map((v) => map.get(v), options.hashFunction)))\n        );\n        return [result2.length > 0, result2];\n      }\n      const result = map.get(local) ?? null;\n      return [result !== null, result ?? []];\n    };\n    if (subQueryPipeline.length === 0) {\n      return collection.map((obj) => {\n        return {\n          ...obj,\n          [expr.as]: lookupEq(obj).pop()\n        };\n      });\n    }\n  }\n  const agg = new Aggregator(subQueryPipeline, options);\n  const opts = { ...options };\n  return collection.map((obj) => {\n    const vars = computeValue(obj, letExpr, null, options);\n    opts.variables = { ...options.variables, ...vars };\n    const [ok, res] = lookupEq(obj);\n    return {\n      ...obj,\n      [expr.as]: ok ? agg.run(joinColl, opts) : res\n    };\n  });\n};\nexport {\n  $lookup\n};\n","import { Query } from \"../../query\";\nconst $match = (collection, expr, options) => {\n  const q = new Query(expr, options);\n  return collection.filter((o) => q.test(o));\n};\nexport {\n  $match\n};\n","import { Aggregator } from \"../../aggregator\";\nimport {\n  ComputeOptions,\n  computeValue\n} from \"../../core\";\nimport {\n  assert,\n  hashCode,\n  isArray,\n  isString,\n  MingoError,\n  resolve,\n  ValueMap\n} from \"../../util\";\nimport { $mergeObjects } from \"../expression\";\nconst $merge = (collection, expr, options) => {\n  const output = isString(expr.into) ? options?.collectionResolver(expr.into) : expr.into;\n  assert(isArray(output), `$merge: option 'into' must resolve to an array`);\n  const onField = expr.on || options.idKey;\n  const getHash = isString(onField) ? (o) => hashCode(resolve(o, onField), options.hashFunction) : (o) => hashCode(onField.map((s) => resolve(o, s), options.hashFunction));\n  const map = ValueMap.init();\n  for (let i = 0; i < output.length; i++) {\n    const obj = output[i];\n    const k = getHash(obj);\n    assert(\n      !map.has(k),\n      \"$merge: 'into' collection must have unique entries for the 'on' field.\"\n    );\n    map.set(k, [obj, i]);\n  }\n  const copts = ComputeOptions.init(options);\n  return collection.map((o) => {\n    const k = getHash(o);\n    if (map.has(k)) {\n      const [target, i] = map.get(k);\n      const variables = computeValue(\n        target,\n        expr.let || { new: \"$$ROOT\" },\n        null,\n        // 'root' is the item from the iteration.\n        copts.update(o)\n      );\n      if (isArray(expr.whenMatched)) {\n        const aggregator = new Aggregator(expr.whenMatched, {\n          ...options,\n          variables\n        });\n        output[i] = aggregator.run([target])[0];\n      } else {\n        switch (expr.whenMatched) {\n          case \"replace\":\n            output[i] = o;\n            break;\n          case \"fail\":\n            throw new MingoError(\n              \"$merge: failed due to matching as specified by 'whenMatched' option.\"\n            );\n          case \"keepExisting\":\n            break;\n          case \"merge\":\n          default:\n            output[i] = $mergeObjects(\n              target,\n              [target, o],\n              // 'root' is the item from the iteration.\n              copts.update(o, { variables })\n            );\n            break;\n        }\n      }\n    } else {\n      switch (expr.whenNotMatched) {\n        case \"discard\":\n          break;\n        case \"fail\":\n          throw new MingoError(\n            \"$merge: failed due to matching as specified by 'whenMatched' option.\"\n          );\n        case \"insert\":\n        default:\n          output.push(o);\n          break;\n      }\n    }\n    return o;\n  });\n};\nexport {\n  $merge\n};\n","import { assert, cloneDeep, isArray, isString } from \"../../util\";\nconst $out = (collection, expr, options) => {\n  const outputColl = isString(expr) ? options?.collectionResolver(expr) : expr;\n  assert(isArray(outputColl), `expression must resolve to an array`);\n  return collection.map((o) => {\n    outputColl.push(cloneDeep(o));\n    return o;\n  });\n};\nexport {\n  $out\n};\n","import {\n  ComputeOptions,\n  computeValue,\n  getOperator\n} from \"../../core\";\nimport {\n  assert,\n  ensureArray,\n  filterMissing,\n  has,\n  isArray,\n  isBoolean,\n  isEmpty,\n  isNumber,\n  isObject,\n  isOperator,\n  isString,\n  merge,\n  removeValue,\n  resolve,\n  resolveGraph,\n  setValue\n} from \"../../util\";\nconst $project = (collection, expr, options) => {\n  if (isEmpty(expr)) return collection;\n  validateExpression(expr, options);\n  return collection.map(createHandler(expr, ComputeOptions.init(options)));\n};\nfunction createHandler(expr, options, isRoot = true) {\n  const idKey = options.idKey;\n  const expressionKeys = Object.keys(expr);\n  const excludedKeys = new Array();\n  const includedKeys = new Array();\n  const handlers = {};\n  for (const key of expressionKeys) {\n    const subExpr = expr[key];\n    if (isNumber(subExpr) || isBoolean(subExpr)) {\n      if (subExpr) {\n        includedKeys.push(key);\n      } else {\n        excludedKeys.push(key);\n      }\n    } else if (isArray(subExpr)) {\n      handlers[key] = (o) => subExpr.map((v) => computeValue(o, v, null, options.update(o)) ?? null);\n    } else if (isObject(subExpr)) {\n      const subExprKeys = Object.keys(subExpr);\n      const operator = subExprKeys.length == 1 ? subExprKeys[0] : \"\";\n      const projectFn = getOperator(\n        \"projection\",\n        operator,\n        options\n      );\n      if (projectFn) {\n        const foundSlice = operator === \"$slice\";\n        if (foundSlice && !ensureArray(subExpr[operator]).every(isNumber)) {\n          handlers[key] = (o) => computeValue(o, subExpr, key, options.update(o));\n        } else {\n          handlers[key] = (o) => projectFn(o, subExpr[operator], key, options.update(o));\n        }\n      } else if (isOperator(operator)) {\n        handlers[key] = (o) => computeValue(o, subExpr[operator], operator, options);\n      } else {\n        validateExpression(subExpr, options);\n        handlers[key] = (o) => {\n          if (!has(o, key)) return computeValue(o, subExpr, null, options);\n          if (isRoot) options.update(o);\n          const target = resolve(o, key);\n          const fn = createHandler(subExpr, options, false);\n          if (isArray(target)) return target.map(fn);\n          if (isObject(target)) return fn(target);\n          return fn(o);\n        };\n      }\n    } else {\n      handlers[key] = isString(subExpr) && subExpr[0] === \"$\" ? (o) => computeValue(o, subExpr, key, options) : (_) => subExpr;\n    }\n  }\n  const handlerKeys = Object.keys(handlers);\n  const idKeyExcluded = excludedKeys.includes(idKey);\n  const idKeyOnlyExcluded = isRoot && idKeyExcluded && excludedKeys.length === 1 && !includedKeys.length && !handlerKeys.length;\n  if (idKeyOnlyExcluded) {\n    return (o) => {\n      const newObj = { ...o };\n      delete newObj[idKey];\n      return newObj;\n    };\n  }\n  const idKeyImplicit = isRoot && !idKeyExcluded && !includedKeys.includes(idKey);\n  const opts = {\n    preserveMissing: true\n  };\n  return (o) => {\n    const newObj = {};\n    if (excludedKeys.length && !includedKeys.length) {\n      merge(newObj, o);\n      for (const k of excludedKeys) {\n        removeValue(newObj, k, { descendArray: true });\n      }\n    }\n    for (const k of includedKeys) {\n      const pathObj = resolveGraph(o, k, opts) ?? {};\n      merge(newObj, pathObj);\n    }\n    if (includedKeys.length) filterMissing(newObj);\n    for (const k of handlerKeys) {\n      const value = handlers[k](o);\n      if (value === void 0) {\n        removeValue(newObj, k, { descendArray: true });\n      } else {\n        setValue(newObj, k, value);\n      }\n    }\n    if (idKeyImplicit && has(o, idKey)) {\n      newObj[idKey] = resolve(o, idKey);\n    }\n    return newObj;\n  };\n}\nfunction validateExpression(expr, options) {\n  let exclusions = false;\n  let inclusions = false;\n  for (const [k, v] of Object.entries(expr)) {\n    assert(!k.startsWith(\"$\"), \"Field names may not start with '$'.\");\n    assert(\n      !k.endsWith(\".$\"),\n      \"Positional projection operator '$' is not supported.\"\n    );\n    if (k === options?.idKey) continue;\n    if (v === 0 || v === false) {\n      exclusions = true;\n    } else if (v === 1 || v === true) {\n      inclusions = true;\n    }\n    assert(\n      !(exclusions && inclusions),\n      \"Projection cannot have a mix of inclusion and exclusion.\"\n    );\n  }\n}\nexport {\n  $project\n};\n","import { ComputeOptions, redact } from \"../../core\";\nconst $redact = (collection, expr, options) => {\n  const copts = ComputeOptions.init(options);\n  return collection.map(\n    (obj) => redact(obj, expr, copts.update(obj))\n  );\n};\nexport {\n  $redact\n};\n","import { computeValue } from \"../../core\";\nimport { assert, isObject } from \"../../util\";\nconst $replaceRoot = (collection, expr, options) => {\n  return collection.map((obj) => {\n    obj = computeValue(obj, expr.newRoot, null, options);\n    assert(isObject(obj), \"$replaceRoot expression must return an object\");\n    return obj;\n  });\n};\nexport {\n  $replaceRoot\n};\n","import { computeValue } from \"../../core\";\nimport { assert, isObject } from \"../../util\";\nconst $replaceWith = (collection, expr, options) => {\n  return collection.map((obj) => {\n    obj = computeValue(obj, expr, null, options);\n    assert(isObject(obj), \"$replaceWith expression must return an object\");\n    return obj;\n  });\n};\nexport {\n  $replaceWith\n};\n","const $sample = (collection, expr, _options) => {\n  return collection.transform((xs) => {\n    const len = xs.length;\n    let i = -1;\n    return () => {\n      if (++i === expr.size) return { done: true };\n      const n = Math.floor(Math.random() * len);\n      return { value: xs[n], done: false };\n    };\n  });\n};\nexport {\n  $sample\n};\n","import { $addFields } from \"./addFields\";\nconst $set = $addFields;\nexport {\n  $set\n};\n","import {\n  getOperator,\n  initOptions\n} from \"../../core\";\nimport { concat, Lazy } from \"../../lazy\";\nimport { assert, isNumber, isOperator, isString } from \"../../util\";\nimport { $function } from \"../expression/custom/function\";\nimport { $dateAdd } from \"../expression/date/dateAdd\";\nimport { isUnbounded } from \"./_internal\";\nimport { $addFields } from \"./addFields\";\nimport { $group } from \"./group\";\nimport { $sort } from \"./sort\";\nconst SORT_REQUIRED_OPS = /* @__PURE__ */ new Set([\n  \"$denseRank\",\n  \"$documentNumber\",\n  \"$first\",\n  \"$last\",\n  \"$linearFill\",\n  \"$rank\",\n  \"$shift\"\n]);\nconst WINDOW_UNBOUNDED_OPS = /* @__PURE__ */ new Set([\n  \"$denseRank\",\n  \"$expMovingAvg\",\n  \"$linearFill\",\n  \"$locf\",\n  \"$rank\",\n  \"$shift\"\n]);\nconst $setWindowFields = (collection, expr, options) => {\n  options = initOptions(options);\n  options.context.addExpressionOps({ $function });\n  for (const outputExpr of Object.values(expr.output)) {\n    const keys = Object.keys(outputExpr);\n    const op = keys.find(isOperator);\n    assert(\n      !!getOperator(\"window\", op, options) || !!getOperator(\"accumulator\", op, options),\n      `'${op}' is not a valid window operator`\n    );\n    assert(\n      keys.length > 0 && keys.length <= 2 && (keys.length == 1 || keys.includes(\"window\")),\n      \"'output' option should have a single window operator.\"\n    );\n    if (outputExpr?.window) {\n      const { documents, range } = outputExpr.window;\n      assert(\n        !!documents && !range || !documents && !!range || !documents && !range,\n        \"'window' option supports only one of 'documents' or 'range'.\"\n      );\n    }\n  }\n  if (expr.sortBy) {\n    collection = $sort(collection, expr.sortBy, options);\n  }\n  collection = $group(\n    collection,\n    {\n      _id: expr.partitionBy,\n      items: { $push: \"$$CURRENT\" }\n    },\n    options\n  );\n  return collection.transform((partitions) => {\n    const iterators = [];\n    const outputConfig = [];\n    for (const [field, outputExpr] of Object.entries(expr.output)) {\n      const op = Object.keys(outputExpr).find(isOperator);\n      const config = {\n        operatorName: op,\n        func: {\n          left: getOperator(\"accumulator\", op, options),\n          right: getOperator(\"window\", op, options)\n        },\n        args: outputExpr[op],\n        field,\n        window: outputExpr.window\n      };\n      assert(\n        !!expr.sortBy || !(SORT_REQUIRED_OPS.has(op) || !config.window),\n        `${SORT_REQUIRED_OPS.has(op) ? `'${op}'` : \"bounded window operation\"} requires a sortBy.`\n      );\n      assert(\n        !config.window || !WINDOW_UNBOUNDED_OPS.has(op),\n        `${op} does not accept a 'window' field.`\n      );\n      outputConfig.push(config);\n    }\n    partitions.forEach((group) => {\n      const items = group.items;\n      let iterator = Lazy(items);\n      const windowResultMap = {};\n      for (const config of outputConfig) {\n        const { func, args, field, window } = config;\n        const makeResultFunc = (getItemsFn) => {\n          let index = -1;\n          return (obj) => {\n            ++index;\n            if (func.left) {\n              return func.left(getItemsFn(obj, index), args, options);\n            } else if (func.right) {\n              return func.right(\n                obj,\n                getItemsFn(obj, index),\n                {\n                  parentExpr: expr,\n                  inputExpr: args,\n                  documentNumber: index + 1,\n                  field\n                },\n                // must use raw options only since it operates over a collection.\n                options\n              );\n            }\n          };\n        };\n        if (window) {\n          const { documents, range, unit } = window;\n          const boundary = documents || range;\n          if (!isUnbounded(window)) {\n            const [begin, end] = boundary;\n            const toBeginIndex = (currentIndex) => {\n              if (begin == \"current\") return currentIndex;\n              if (begin == \"unbounded\") return 0;\n              return Math.max(begin + currentIndex, 0);\n            };\n            const toEndIndex = (currentIndex) => {\n              if (end == \"current\") return currentIndex + 1;\n              if (end == \"unbounded\") return items.length;\n              return end + currentIndex + 1;\n            };\n            const getItems = (current, index) => {\n              if (!!documents || boundary.every(isString)) {\n                return items.slice(toBeginIndex(index), toEndIndex(index));\n              }\n              const sortKey = Object.keys(expr.sortBy)[0];\n              let lower;\n              let upper;\n              if (unit) {\n                const getTime = (amount) => {\n                  return $dateAdd(\n                    current,\n                    {\n                      startDate: new Date(current[sortKey]),\n                      unit,\n                      amount\n                    },\n                    options\n                  ).getTime();\n                };\n                lower = isNumber(begin) ? getTime(begin) : -Infinity;\n                upper = isNumber(end) ? getTime(end) : Infinity;\n              } else {\n                const currentValue = current[sortKey];\n                lower = isNumber(begin) ? currentValue + begin : -Infinity;\n                upper = isNumber(end) ? currentValue + end : Infinity;\n              }\n              let array = items;\n              if (begin == \"current\") array = items.slice(index);\n              if (end == \"current\") array = items.slice(0, index + 1);\n              return array.filter((o) => {\n                const n = +o[sortKey];\n                return n >= lower && n <= upper;\n              });\n            };\n            windowResultMap[field] = makeResultFunc(getItems);\n          }\n        }\n        if (!windowResultMap[field]) {\n          windowResultMap[field] = makeResultFunc((_) => items);\n        }\n        iterator = $addFields(\n          iterator,\n          {\n            [field]: {\n              $function: {\n                body: (obj) => windowResultMap[field](obj),\n                args: [\"$$CURRENT\"]\n              }\n            }\n          },\n          options\n        );\n      }\n      iterators.push(iterator);\n    });\n    return concat(...iterators);\n  });\n};\nexport {\n  $setWindowFields\n};\n","const $skip = (collection, expr, _options) => {\n  return collection.drop(expr);\n};\nexport {\n  $skip\n};\n","import {\n  assert,\n  compare,\n  groupBy,\n  isEmpty,\n  isObject,\n  isString,\n  resolve\n} from \"../../util\";\nconst $sort = (collection, sortKeys, options) => {\n  if (isEmpty(sortKeys) || !isObject(sortKeys)) return collection;\n  let cmp = compare;\n  const collationSpec = options.collation;\n  if (isObject(collationSpec) && isString(collationSpec.locale)) {\n    cmp = collationComparator(collationSpec);\n  }\n  return collection.transform((coll) => {\n    const modifiers = Object.keys(sortKeys);\n    for (const key of modifiers.reverse()) {\n      const groups = groupBy(\n        coll,\n        (obj) => resolve(obj, key),\n        options.hashFunction\n      );\n      const sortedKeys = Array.from(groups.keys()).sort(cmp);\n      if (sortKeys[key] === -1) sortedKeys.reverse();\n      let i = 0;\n      for (const k of sortedKeys) for (const v of groups.get(k)) coll[i++] = v;\n      assert(i == coll.length, \"bug: counter must match collection size.\");\n    }\n    return coll;\n  });\n};\nconst COLLATION_STRENGTH = {\n  // Only strings that differ in base letters compare as unequal. Examples: a ≠ b, a = á, a = A.\n  1: \"base\",\n  //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.\n  // Examples: a ≠ b, a ≠ á, a = A.\n  2: \"accent\",\n  // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.\n  // Other differences may also be taken into consideration. Examples: a ≠ b, a ≠ á, a ≠ A\n  3: \"variant\"\n  // case - Only strings that differ in base letters or case compare as unequal. Examples: a ≠ b, a = á, a ≠ A.\n};\nfunction collationComparator(spec) {\n  const localeOpt = {\n    sensitivity: COLLATION_STRENGTH[spec.strength || 3],\n    caseFirst: spec.caseFirst === \"off\" ? \"false\" : spec.caseFirst || \"false\",\n    numeric: spec.numericOrdering || false,\n    ignorePunctuation: spec.alternate === \"shifted\"\n  };\n  if ((spec.caseLevel || false) === true) {\n    if (localeOpt.sensitivity === \"base\") localeOpt.sensitivity = \"case\";\n    if (localeOpt.sensitivity === \"accent\") localeOpt.sensitivity = \"variant\";\n  }\n  const collator = new Intl.Collator(spec.locale, localeOpt);\n  return (a, b) => {\n    if (!isString(a) || !isString(b)) return compare(a, b);\n    const i = collator.compare(a, b);\n    if (i < 0) return -1;\n    if (i > 0) return 1;\n    return 0;\n  };\n}\nexport {\n  $sort\n};\n","import { $group } from \"./group\";\nimport { $sort } from \"./sort\";\nconst $sortByCount = (collection, expr, options) => {\n  return $sort(\n    $group(collection, { _id: expr, count: { $sum: 1 } }, options),\n    { count: -1 },\n    options\n  );\n};\nexport {\n  $sortByCount\n};\n","import { Aggregator } from \"../../aggregator\";\nimport { concat, Lazy } from \"../../lazy\";\nimport { isString } from \"../../util\";\nconst $unionWith = (collection, expr, options) => {\n  const array = isString(expr.coll) ? options.collectionResolver(expr.coll) : expr.coll;\n  const iterators = [collection];\n  iterators.push(\n    expr.pipeline ? new Aggregator(expr.pipeline, options).stream(array) : Lazy(array)\n  );\n  return concat(...iterators);\n};\nexport {\n  $unionWith\n};\n","import { ensureArray } from \"../../util\";\nimport { $project } from \"./project\";\nconst $unset = (collection, expr, options) => {\n  expr = ensureArray(expr);\n  const doc = {};\n  for (const k of expr) doc[k] = 0;\n  return $project(collection, doc, options);\n};\nexport {\n  $unset\n};\n","import { Iterator, Lazy } from \"../../lazy\";\nimport {\n  isArray,\n  isEmpty,\n  isString,\n  removeValue,\n  resolve,\n  resolveGraph,\n  setValue\n} from \"../../util\";\nconst $unwind = (collection, expr, _options) => {\n  if (isString(expr)) expr = { path: expr };\n  const path = expr.path;\n  const field = path.substring(1);\n  const includeArrayIndex = expr?.includeArrayIndex || false;\n  const preserveNullAndEmptyArrays = expr.preserveNullAndEmptyArrays || false;\n  const format = (o, i) => {\n    if (includeArrayIndex !== false) o[includeArrayIndex] = i;\n    return o;\n  };\n  let value;\n  return Lazy(() => {\n    for (; ; ) {\n      if (value instanceof Iterator) {\n        const tmp = value.next();\n        if (!tmp.done) return tmp;\n      }\n      const wrapper = collection.next();\n      if (wrapper.done) return wrapper;\n      const obj = wrapper.value;\n      value = resolve(obj, field);\n      if (isArray(value)) {\n        if (value.length === 0 && preserveNullAndEmptyArrays === true) {\n          value = null;\n          removeValue(obj, field);\n          return { value: format(obj, null), done: false };\n        } else {\n          value = Lazy(value).map((item, i) => {\n            const newObj = resolveGraph(obj, field, {\n              preserveKeys: true\n            });\n            setValue(newObj, field, item);\n            return format(newObj, i);\n          });\n        }\n      } else if (!isEmpty(value) || preserveNullAndEmptyArrays === true) {\n        return { value: format(obj, null), done: false };\n      }\n    }\n  });\n};\nexport {\n  $unwind\n};\n","import { $all as __all, createQueryOperator } from \"../../_predicates\";\nconst $all = createQueryOperator(__all);\nexport {\n  $all\n};\n","import {\n  $elemMatch as __elemMatch,\n  createQueryOperator\n} from \"../../_predicates\";\nconst $elemMatch = createQueryOperator(__elemMatch);\nexport {\n  $elemMatch\n};\n","export * from \"./all\";\nexport * from \"./elemMatch\";\nexport * from \"./size\";\n","import { $size as __size, createQueryOperator } from \"../../_predicates\";\nconst $size = createQueryOperator(__size);\nexport {\n  $size\n};\n","import { $eq as __eq, createQueryOperator } from \"../../_predicates\";\nconst $eq = createQueryOperator(__eq);\nexport {\n  $eq\n};\n","import { $gt as __gt, createQueryOperator } from \"../../_predicates\";\nconst $gt = createQueryOperator(__gt);\nexport {\n  $gt\n};\n","import { $gte as __gte, createQueryOperator } from \"../../_predicates\";\nconst $gte = createQueryOperator(__gte);\nexport {\n  $gte\n};\n","import { $in as __in, createQueryOperator } from \"../../_predicates\";\nconst $in = createQueryOperator(__in);\nexport {\n  $in\n};\n","import { $eq } from \"./eq\";\nimport { $gt } from \"./gt\";\nimport { $gte } from \"./gte\";\nimport { $in } from \"./in\";\nimport { $lt } from \"./lt\";\nimport { $lte } from \"./lte\";\nimport { $ne } from \"./ne\";\nimport { $nin } from \"./nin\";\nexport {\n  $eq,\n  $gt,\n  $gte,\n  $in,\n  $lt,\n  $lte,\n  $ne,\n  $nin\n};\n","import { $lt as __lt, createQueryOperator } from \"../../_predicates\";\nconst $lt = createQueryOperator(__lt);\nexport {\n  $lt\n};\n","import { $lte as __lte, createQueryOperator } from \"../../_predicates\";\nconst $lte = createQueryOperator(__lte);\nexport {\n  $lte\n};\n","import { $ne as __ne, createQueryOperator } from \"../../_predicates\";\nconst $ne = createQueryOperator(__ne);\nexport {\n  $ne\n};\n","import { $nin as __nin, createQueryOperator } from \"../../_predicates\";\nconst $nin = createQueryOperator(__nin);\nexport {\n  $nin\n};\n","import { isArray, resolve, resolveGraph } from \"../../../util\";\nconst $exists = (selector, value, _options) => {\n  const nested = selector.includes(\".\");\n  const b = !!value;\n  if (!nested || selector.match(/\\.\\d+$/)) {\n    return (o) => resolve(o, selector) !== void 0 === b;\n  }\n  return (o) => {\n    const path = resolveGraph(o, selector, { preserveIndex: true });\n    const val = resolve(path, selector.substring(0, selector.lastIndexOf(\".\")));\n    return isArray(val) ? val.some((v) => v !== void 0) === b : val !== void 0 === b;\n  };\n};\nexport {\n  $exists\n};\n","export * from \"./exists\";\nexport * from \"./type\";\n","import { $type as __type, createQueryOperator } from \"../../_predicates\";\nconst $type = createQueryOperator(__type);\nexport {\n  $type\n};\n","import { computeValue } from \"../../../core\";\nfunction $expr(_, rhs, options) {\n  return (obj) => computeValue(obj, rhs, null, options);\n}\nexport {\n  $expr\n};\n","export * from \"./expr\";\nexport * from \"./jsonSchema\";\nexport * from \"./mod\";\nexport * from \"./regex\";\nexport * from \"./where\";\n","import { MingoError } from \"../../../util\";\nfunction $jsonSchema(_, schema, options) {\n  if (!options?.jsonSchemaValidator) {\n    throw new MingoError(\n      \"Missing option 'jsonSchemaValidator'. Configure to use '$jsonSchema' operator.\"\n    );\n  }\n  const validate = options?.jsonSchemaValidator(schema);\n  return (obj) => validate(obj);\n}\nexport {\n  $jsonSchema\n};\n","import { $mod as __mod, createQueryOperator } from \"../../_predicates\";\nconst $mod = createQueryOperator(__mod);\nexport {\n  $mod\n};\n","import { $regex as __regex, createQueryOperator } from \"../../_predicates\";\nconst $regex = createQueryOperator(__regex);\nexport {\n  $regex\n};\n","import { assert, isFunction, truthy } from \"../../../util\";\nfunction $where(_, rhs, options) {\n  assert(\n    options.scriptEnabled,\n    \"$where operator requires 'scriptEnabled' option to be true\"\n  );\n  const f = rhs;\n  assert(isFunction(f), \"$where only accepts a Function object\");\n  return (obj) => truthy(f.call(obj), options?.useStrictMode);\n}\nexport {\n  $where\n};\n","import { Query } from \"../../../query\";\nimport { assert, isArray } from \"../../../util\";\nconst $and = (_, rhs, options) => {\n  assert(\n    isArray(rhs),\n    \"Invalid expression: $and expects value to be an Array.\"\n  );\n  const queries = rhs.map((expr) => new Query(expr, options));\n  return (obj) => queries.every((q) => q.test(obj));\n};\nexport {\n  $and\n};\n","export * from \"./and\";\nexport * from \"./nor\";\nexport * from \"./not\";\nexport * from \"./or\";\n","import { assert, isArray } from \"../../../util\";\nimport { $or } from \"./or\";\nconst $nor = (_, rhs, options) => {\n  assert(\n    isArray(rhs),\n    \"Invalid expression. $nor expects value to be an array.\"\n  );\n  const f = $or(\"$or\", rhs, options);\n  return (obj) => !f(obj);\n};\nexport {\n  $nor\n};\n","import { Query } from \"../../../query\";\nimport { normalize } from \"../../../util\";\nconst $not = (selector, rhs, options) => {\n  const criteria = {};\n  criteria[selector] = normalize(rhs);\n  const query = new Query(criteria, options);\n  return (obj) => !query.test(obj);\n};\nexport {\n  $not\n};\n","import { Query } from \"../../../query\";\nimport { assert, isArray } from \"../../../util\";\nconst $or = (_, rhs, options) => {\n  assert(isArray(rhs), \"Invalid expression. $or expects value to be an Array\");\n  const queries = rhs.map((expr) => new Query(expr, options));\n  return (obj) => queries.some((q) => q.test(obj));\n};\nexport {\n  $or\n};\n","import { groupBy, isEqual, MingoError } from \"../../util\";\nimport { $push } from \"../accumulator\";\nimport { MILLIS_PER_DAY } from \"../expression/date/_internal\";\nimport { isUnbounded } from \"../pipeline/_internal\";\nconst MILLIS_PER_UNIT = {\n  week: MILLIS_PER_DAY * 7,\n  day: MILLIS_PER_DAY,\n  hour: MILLIS_PER_DAY / 24,\n  minute: 6e4,\n  second: 1e3,\n  millisecond: 1\n};\nconst memo = /* @__PURE__ */ new WeakMap();\nfunction withMemo(collection, expr, cacheFn, fn) {\n  if (!isUnbounded(expr.parentExpr.output[expr.field].window)) {\n    return fn(cacheFn());\n  }\n  if (!memo.has(collection)) {\n    memo.set(collection, { [expr.field]: cacheFn() });\n  }\n  const data = memo.get(collection);\n  if (data[expr.field] === void 0) {\n    data[expr.field] = cacheFn();\n  }\n  let failed = false;\n  try {\n    return fn(data[expr.field]);\n  } catch {\n    failed = true;\n  } finally {\n    if (failed || expr.documentNumber === collection.length) {\n      delete data[expr.field];\n      if (Object.keys(data).length === 0) memo.delete(collection);\n    }\n  }\n}\nfunction rank(_, collection, expr, options, dense) {\n  return withMemo(\n    collection,\n    expr,\n    () => {\n      const sortKey = \"$\" + Object.keys(expr.parentExpr.sortBy)[0];\n      const values = $push(collection, sortKey, options);\n      const groups = groupBy(\n        values,\n        (_2, n) => values[n],\n        options.hashFunction\n      );\n      return { values, groups };\n    },\n    (input) => {\n      const { values, groups: partitions } = input;\n      if (partitions.size == collection.length) {\n        return expr.documentNumber;\n      }\n      const current = values[expr.documentNumber - 1];\n      let i = 0;\n      let offset = 0;\n      for (const key of partitions.keys()) {\n        if (isEqual(current, key)) {\n          return dense ? i + 1 : offset + 1;\n        }\n        i++;\n        offset += partitions.get(key).length;\n      }\n      throw new MingoError(\n        \"rank: invalid return value. please submit a bug report.\"\n      );\n    }\n  );\n}\nexport {\n  MILLIS_PER_UNIT,\n  rank,\n  withMemo\n};\n","import { isNumber } from \"../../util\";\nimport { $push } from \"../accumulator\";\nimport { withMemo } from \"./_internal\";\nconst interpolate = (x1, y1, x2, y2, x) => y1 + (x - x1) * ((y2 - y1) / (x2 - x1));\nconst $linearFill = (_, collection, expr, options) => {\n  return withMemo(\n    collection,\n    expr,\n    () => {\n      const sortKey = \"$\" + Object.keys(expr.parentExpr.sortBy)[0];\n      const points = $push(\n        collection,\n        [sortKey, expr.inputExpr],\n        options\n      ).filter(([x, _2]) => isNumber(+x));\n      if (points.length !== collection.length) return null;\n      let lindex = -1;\n      let rindex = 0;\n      while (rindex < points.length) {\n        while (lindex + 1 < points.length && isNumber(points[lindex + 1][1])) {\n          lindex++;\n          rindex = lindex;\n        }\n        while (rindex + 1 < points.length && !isNumber(points[rindex + 1][1])) {\n          rindex++;\n        }\n        if (rindex + 1 >= points.length) break;\n        rindex++;\n        while (lindex + 1 < rindex) {\n          points[lindex + 1][1] = interpolate(\n            points[lindex][0],\n            points[lindex][1],\n            points[rindex][0],\n            points[rindex][1],\n            points[lindex + 1][0]\n          );\n          lindex++;\n        }\n        lindex = rindex;\n      }\n      return points.map(([_2, y]) => y);\n    },\n    (values) => values[expr.documentNumber - 1]\n  );\n};\nexport {\n  $linearFill\n};\n","import { isNil } from \"../../util\";\nimport { $push } from \"../accumulator/push\";\nimport { withMemo } from \"./_internal\";\nconst $locf = (_, collection, expr, options) => {\n  return withMemo(\n    collection,\n    expr,\n    () => {\n      const values = $push(collection, expr.inputExpr, options);\n      for (let i = 1; i < values.length; i++) {\n        if (isNil(values[i])) values[i] = values[i - 1];\n      }\n      return values;\n    },\n    (series) => series[expr.documentNumber - 1]\n  );\n};\nexport {\n  $locf\n};\n","import { getOperator, initOptions } from \"./core\";\nimport { Cursor } from \"./cursor\";\nimport { assert, cloneDeep, isObject, isOperator, normalize } from \"./util\";\nconst TOP_LEVEL_OPS = new Set(\n  Array.from([\"$and\", \"$or\", \"$nor\", \"$expr\", \"$jsonSchema\"])\n);\nclass Query {\n  #compiled;\n  #options;\n  #condition;\n  constructor(condition, options) {\n    this.#condition = cloneDeep(condition);\n    this.#options = initOptions(options);\n    this.#compiled = [];\n    this.compile();\n  }\n  compile() {\n    assert(\n      isObject(this.#condition),\n      `query criteria must be an object: ${JSON.stringify(this.#condition)}`\n    );\n    const whereOperator = {};\n    for (const [field, expr] of Object.entries(this.#condition)) {\n      if (\"$where\" === field) {\n        assert(\n          this.#options.scriptEnabled,\n          \"$where operator requires 'scriptEnabled' option to be true.\"\n        );\n        Object.assign(whereOperator, { field, expr });\n      } else if (TOP_LEVEL_OPS.has(field)) {\n        this.processOperator(field, field, expr);\n      } else {\n        assert(!isOperator(field), `unknown top level operator: ${field}`);\n        for (const [operator, val] of Object.entries(\n          normalize(expr)\n        )) {\n          this.processOperator(field, operator, val);\n        }\n      }\n      if (whereOperator.field) {\n        this.processOperator(\n          whereOperator.field,\n          whereOperator.field,\n          whereOperator.expr\n        );\n      }\n    }\n  }\n  processOperator(field, operator, value) {\n    const call = getOperator(\"query\", operator, this.#options);\n    assert(!!call, `unknown query operator ${operator}`);\n    this.#compiled.push(call(field, value, this.#options));\n  }\n  /**\n   * Checks if the object passes the query criteria. Returns true if so, false otherwise.\n   *\n   * @param obj The object to test\n   * @returns {boolean}\n   */\n  test(obj) {\n    return this.#compiled.every((p) => p(obj));\n  }\n  /**\n   * Returns a cursor to select matching documents from the input source.\n   *\n   * @param source A source providing a sequence of documents\n   * @param projection An optional projection criteria\n   * @returns {Cursor} A Cursor for iterating over the results\n   */\n  find(collection, projection) {\n    return new Cursor(\n      collection,\n      (o) => this.test(o),\n      projection || {},\n      this.#options\n    );\n  }\n  /**\n   * Remove matched documents from the collection returning the remainder\n   *\n   * @param collection An array of documents\n   * @returns {Array} A new array with matching elements removed\n   */\n  remove(collection) {\n    return collection.reduce((acc, obj) => {\n      if (!this.test(obj)) acc.push(obj);\n      return acc;\n    }, []);\n  }\n}\nexport {\n  Query\n};\n","const TIME_UNITS = [\n  \"year\",\n  \"quarter\",\n  \"month\",\n  \"week\",\n  \"day\",\n  \"hour\",\n  \"minute\",\n  \"second\",\n  \"millisecond\"\n];\nexport {\n  TIME_UNITS\n};\n","class MingoError extends Error {\n}\nconst MISSING = Symbol(\"missing\");\nconst CYCLE_FOUND_ERROR = Object.freeze(\n  new Error(\"mingo: cycle detected while processing object/array\")\n);\nconst DEFAULT_HASH_FUNCTION = (value) => {\n  const s = stringify(value);\n  let hash = 0;\n  let i = s.length;\n  while (i) hash = (hash << 5) - hash ^ s.charCodeAt(--i);\n  return hash >>> 0;\n};\nconst isPrimitive = (v) => typeof v !== \"object\" && typeof v !== \"function\" || v === null;\nconst isScalar = (v) => isPrimitive(v) || isDate(v) || isRegExp(v);\nconst SORT_ORDER = {\n  undefined: 1,\n  null: 2,\n  number: 3,\n  string: 4,\n  symbol: 5,\n  object: 6,\n  array: 7,\n  arraybuffer: 8,\n  boolean: 9,\n  date: 10,\n  regexp: 11,\n  function: 12\n};\nconst compare = (a, b) => {\n  if (a === MISSING) a = void 0;\n  if (b === MISSING) b = void 0;\n  const [u, v] = [a, b].map((n) => SORT_ORDER[typeOf(n)] || 0);\n  if (u !== v) return u - v;\n  if (isEqual(a, b)) return 0;\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\nclass ValueMap extends Map {\n  // The hash function\n  #hashFn = DEFAULT_HASH_FUNCTION;\n  // maps the hashcode to key set\n  #keyMap = /* @__PURE__ */ new Map();\n  // returns a tuple of [<masterKey>, <hash>]. Expects an object key.\n  #unpack = (key) => {\n    const hash = this.#hashFn(key);\n    return [(this.#keyMap.get(hash) || []).find((k) => isEqual(k, key)), hash];\n  };\n  constructor() {\n    super();\n  }\n  /**\n   * Returns a new {@link ValueMap} object.\n   * @param fn An optional custom hash function\n   */\n  static init(fn) {\n    const m = new ValueMap();\n    if (fn) m.#hashFn = fn;\n    return m;\n  }\n  clear() {\n    super.clear();\n    this.#keyMap.clear();\n  }\n  /**\n   * @returns true if an element in the Map existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    if (isPrimitive(key)) return super.delete(key);\n    const [masterKey, hash] = this.#unpack(key);\n    if (!super.delete(masterKey)) return false;\n    this.#keyMap.set(\n      hash,\n      this.#keyMap.get(hash).filter((k) => !isEqual(k, masterKey))\n    );\n    return true;\n  }\n  /**\n   * Returns a specified element from the Map object. If the value that is associated to the provided key is an object, then you will get a reference to that object and any change made to that object will effectively modify it inside the Map.\n   * @returns Returns the element associated with the specified key. If no element is associated with the specified key, undefined is returned.\n   */\n  get(key) {\n    if (isPrimitive(key)) return super.get(key);\n    const [masterKey, _] = this.#unpack(key);\n    return super.get(masterKey);\n  }\n  /**\n   * @returns boolean indicating whether an element with the specified key exists or not.\n   */\n  has(key) {\n    if (isPrimitive(key)) return super.has(key);\n    const [masterKey, _] = this.#unpack(key);\n    return super.has(masterKey);\n  }\n  /**\n   * Adds a new element with a specified key and value to the Map. If an element with the same key already exists, the element will be updated.\n   */\n  set(key, value) {\n    if (isPrimitive(key)) return super.set(key, value);\n    const [masterKey, hash] = this.#unpack(key);\n    if (super.has(masterKey)) {\n      super.set(masterKey, value);\n    } else {\n      super.set(key, value);\n      const keys = this.#keyMap.get(hash) || [];\n      keys.push(key);\n      this.#keyMap.set(hash, keys);\n    }\n    return this;\n  }\n  /**\n   * @returns the number of elements in the Map.\n   */\n  get size() {\n    return super.size;\n  }\n}\nfunction assert(condition, message) {\n  if (!condition) throw new MingoError(message);\n}\nconst STRING_REP = Object.keys(SORT_ORDER).reduce(\n  (memo, k) => {\n    memo[\"[object \" + k[0].toUpperCase() + k.substring(1) + \"]\"] = k;\n    return memo;\n  },\n  {}\n);\nfunction typeOf(v) {\n  const s = Object.prototype.toString.call(v);\n  return s === \"[object Object]\" ? v?.constructor?.name?.toLowerCase() || \"object\" : STRING_REP[s] || s.substring(8, s.length - 1).toLowerCase();\n}\nconst isBoolean = (v) => typeof v === \"boolean\";\nconst isString = (v) => typeof v === \"string\";\nconst isSymbol = (v) => typeof v === \"symbol\";\nconst isNumber = (v) => !isNaN(v) && typeof v === \"number\";\nconst isNotNaN = (v) => !(isNaN(v) && typeof v === \"number\");\nconst isArray = Array.isArray;\nfunction isObject(v) {\n  if (!v) return false;\n  const p = Object.getPrototypeOf(v);\n  return (p === Object.prototype || p === null) && typeOf(v) === \"object\";\n}\nconst isObjectLike = (v) => !isPrimitive(v);\nconst isDate = (v) => v instanceof Date;\nconst isRegExp = (v) => v instanceof RegExp;\nconst isFunction = (v) => typeof v === \"function\";\nconst isNil = (v) => v === null || v === void 0;\nconst truthy = (arg, strict = true) => !!arg || strict && arg === \"\";\nconst isEmpty = (x) => isNil(x) || isString(x) && !x || isArray(x) && x.length === 0 || isObject(x) && Object.keys(x).length === 0;\nconst ensureArray = (x) => isArray(x) ? x : [x];\nconst has = (obj, prop) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop);\nconst isTypedArray = (v) => typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView(v);\nconst cloneDeep = (v, refs) => {\n  if (isNil(v) || isBoolean(v) || isNumber(v) || isString(v)) return v;\n  if (isDate(v)) return new Date(v);\n  if (isRegExp(v)) return new RegExp(v);\n  if (isTypedArray(v)) {\n    const ctor = v.constructor;\n    return new ctor(v);\n  }\n  if (!(refs instanceof Set)) refs = /* @__PURE__ */ new Set();\n  if (refs.has(v)) throw CYCLE_FOUND_ERROR;\n  refs.add(v);\n  try {\n    if (isArray(v)) {\n      const arr = new Array(v.length);\n      for (let i = 0; i < v.length; i++) arr[i] = cloneDeep(v[i], refs);\n      return arr;\n    }\n    if (isObject(v)) {\n      const obj = {};\n      for (const k of Object.keys(v)) obj[k] = cloneDeep(v[k], refs);\n      return obj;\n    }\n  } finally {\n    refs.delete(v);\n  }\n  return v;\n};\nconst isMissing = (v) => v === MISSING;\nfunction merge(target, input) {\n  if (isMissing(target) || isNil(target)) return input;\n  if (isMissing(input) || isNil(input)) return target;\n  if (isPrimitive(target) || isPrimitive(input)) return input;\n  if (isArray(target) && isArray(input)) {\n    assert(\n      target.length === input.length,\n      \"arrays must be of equal length to merge.\"\n    );\n  }\n  for (const k of Object.keys(input)) {\n    target[k] = merge(target[k], input[k]);\n  }\n  return target;\n}\nfunction intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n  const vmaps = [ValueMap.init(hashFunction), ValueMap.init(hashFunction)];\n  if (input.length === 0) return [];\n  if (input.some((arr) => arr.length === 0)) return [];\n  if (input.length === 1) return [...input];\n  input[input.length - 1].forEach((v) => vmaps[0].set(v, true));\n  for (let i = input.length - 2; i > -1; i--) {\n    input[i].forEach((v) => {\n      if (vmaps[0].has(v)) vmaps[1].set(v, true);\n    });\n    if (vmaps[1].size === 0) return [];\n    vmaps.reverse();\n    vmaps[1].clear();\n  }\n  return Array.from(vmaps[0].keys());\n}\nfunction flatten(xs, depth = 1) {\n  const arr = new Array();\n  function flatten2(ys, n) {\n    for (let i = 0, len = ys.length; i < len; i++) {\n      if (isArray(ys[i]) && (n > 0 || n < 0)) {\n        flatten2(ys[i], Math.max(-1, n - 1));\n      } else {\n        arr.push(ys[i]);\n      }\n    }\n  }\n  flatten2(xs, depth);\n  return arr;\n}\nfunction getMembersOf(o) {\n  const props = {};\n  while (o) {\n    for (const k of Object.getOwnPropertyNames(o))\n      if (!(k in props)) props[k] = o[k];\n    o = Object.getPrototypeOf(o);\n  }\n  return props;\n}\nfunction hasCustomString(o) {\n  while (o) {\n    if (Object.getOwnPropertyNames(o).includes(\"toString\"))\n      return o[\"toString\"] !== Object.prototype.toString;\n    o = Object.getPrototypeOf(o);\n  }\n  return false;\n}\nfunction isEqual(a, b) {\n  if (a === b || Object.is(a, b)) return true;\n  if (a === null || b === null) return false;\n  if (typeof a !== typeof b) return false;\n  if (typeof a !== \"object\") return false;\n  if (a.constructor !== b.constructor) return false;\n  if (a instanceof Date) return +a === +b;\n  if (a instanceof RegExp) return a.toString() === b.toString();\n  const ctor = a.constructor;\n  if (ctor === Array || ctor === Object) {\n    const aKeys = Object.keys(a).sort();\n    const bKeys = Object.keys(b).sort();\n    if (aKeys.length !== bKeys.length) return false;\n    for (let i = 0, k = aKeys[i]; i < aKeys.length; k = aKeys[++i]) {\n      if (k !== bKeys[i] || !isEqual(a[k], b[k])) return false;\n    }\n    return true;\n  }\n  return hasCustomString(a) && a.toString() === b.toString();\n}\nfunction unique(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n  const m = ValueMap.init(hashFunction);\n  input.forEach((v) => m.set(v, true));\n  return Array.from(m.keys());\n}\nconst stringify = (v, refs) => {\n  if (v === null) return \"null\";\n  if (v === void 0) return \"undefined\";\n  if (isString(v) || isNumber(v) || isBoolean(v)) return JSON.stringify(v);\n  if (isDate(v)) return v.toISOString();\n  if (isRegExp(v) || isSymbol(v) || isFunction(v))\n    return v.toString();\n  if (!(refs instanceof Set)) refs = /* @__PURE__ */ new Set();\n  if (refs.has(v)) throw CYCLE_FOUND_ERROR;\n  try {\n    refs.add(v);\n    if (isArray(v)) return \"[\" + v.map((s2) => stringify(s2, refs)).join(\",\") + \"]\";\n    if (isObject(v)) {\n      const keys = Object.keys(v).sort();\n      return \"{\" + keys.map((k) => `${k}:${stringify(v[k], refs)}`).join() + \"}\";\n    }\n    const s = hasCustomString(v) ? v.toString() : stringify(getMembersOf(v), refs);\n    return typeOf(v) + \"(\" + s + \")\";\n  } finally {\n    refs.delete(v);\n  }\n};\nfunction hashCode(value, hashFunction) {\n  if (isNil(value)) return null;\n  hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;\n  return hashFunction(value);\n}\nfunction groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {\n  if (collection.length < 1) return /* @__PURE__ */ new Map();\n  const lookup = /* @__PURE__ */ new Map();\n  const result = /* @__PURE__ */ new Map();\n  for (let i = 0; i < collection.length; i++) {\n    const obj = collection[i];\n    const key = keyFn(obj, i);\n    const hash = hashCode(key, hashFunction);\n    if (hash === null) {\n      if (result.has(null)) {\n        result.get(null).push(obj);\n      } else {\n        result.set(null, [obj]);\n      }\n    } else {\n      const existingKey = lookup.has(hash) ? lookup.get(hash).find((k) => isEqual(k, key)) : null;\n      if (isNil(existingKey)) {\n        result.set(key, [obj]);\n        if (lookup.has(hash)) {\n          lookup.get(hash).push(key);\n        } else {\n          lookup.set(hash, [key]);\n        }\n      } else {\n        result.get(existingKey).push(obj);\n      }\n    }\n  }\n  return result;\n}\nconst MAX_ARRAY_PUSH = 5e4;\nfunction into(target, ...rest) {\n  if (isArray(target)) {\n    for (const arr of rest) {\n      let i = Math.ceil(arr.length / MAX_ARRAY_PUSH);\n      let begin = 0;\n      while (i-- > 0) {\n        Array.prototype.push.apply(\n          target,\n          arr.slice(begin, begin + MAX_ARRAY_PUSH)\n        );\n        begin += MAX_ARRAY_PUSH;\n      }\n    }\n    return target;\n  } else {\n    return rest.filter(isObjectLike).reduce((acc, item) => {\n      Object.assign(acc, item);\n      return acc;\n    }, target);\n  }\n}\nfunction getValue(obj, key) {\n  return isObjectLike(obj) ? obj[key] : void 0;\n}\nfunction unwrap(arr, depth) {\n  if (depth < 1) return arr;\n  while (depth-- && arr.length === 1) arr = arr[0];\n  return arr;\n}\nfunction resolve(obj, selector, options) {\n  let depth = 0;\n  function resolve2(o, path) {\n    let value = o;\n    for (let i = 0; i < path.length; i++) {\n      const field = path[i];\n      const isText = /^\\d+$/.exec(field) === null;\n      if (isText && isArray(value)) {\n        if (i === 0 && depth > 0) break;\n        depth += 1;\n        const subpath = path.slice(i);\n        value = value.reduce((acc, item) => {\n          const v = resolve2(item, subpath);\n          if (v !== void 0) acc.push(v);\n          return acc;\n        }, []);\n        break;\n      } else {\n        value = getValue(value, field);\n      }\n      if (value === void 0) break;\n    }\n    return value;\n  }\n  const res = isScalar(obj) ? obj : resolve2(obj, selector.split(\".\"));\n  return isArray(res) && options?.unwrapArray ? unwrap(res, depth) : res;\n}\nfunction resolveGraph(obj, selector, options) {\n  const sep = selector.indexOf(\".\");\n  const key = sep == -1 ? selector : selector.substring(0, sep);\n  const next = selector.substring(sep + 1);\n  const hasNext = sep != -1;\n  if (isArray(obj)) {\n    const isIndex = /^\\d+$/.test(key);\n    const arr = isIndex && options?.preserveIndex ? [...obj] : [];\n    if (isIndex) {\n      const index = parseInt(key);\n      let value2 = getValue(obj, index);\n      if (hasNext) {\n        value2 = resolveGraph(value2, next, options);\n      }\n      if (options?.preserveIndex) {\n        arr[index] = value2;\n      } else {\n        arr.push(value2);\n      }\n    } else {\n      for (const item of obj) {\n        const value2 = resolveGraph(item, selector, options);\n        if (options?.preserveMissing) {\n          arr.push(value2 == void 0 ? MISSING : value2);\n        } else if (value2 != void 0 || options?.preserveIndex) {\n          arr.push(value2);\n        }\n      }\n    }\n    return arr;\n  }\n  const res = options?.preserveKeys ? { ...obj } : {};\n  let value = getValue(obj, key);\n  if (hasNext) {\n    value = resolveGraph(value, next, options);\n  }\n  if (value === void 0) return void 0;\n  res[key] = value;\n  return res;\n}\nfunction filterMissing(obj) {\n  if (isArray(obj)) {\n    for (let i = obj.length - 1; i >= 0; i--) {\n      if (obj[i] === MISSING) {\n        obj.splice(i, 1);\n      } else {\n        filterMissing(obj[i]);\n      }\n    }\n  } else if (isObject(obj)) {\n    for (const k in obj) {\n      if (has(obj, k)) {\n        filterMissing(obj[k]);\n      }\n    }\n  }\n}\nconst NUMBER_RE = /^\\d+$/;\nfunction walk(obj, selector, fn, options) {\n  const names = selector.split(\".\");\n  const key = names[0];\n  const next = names.slice(1).join(\".\");\n  if (names.length === 1) {\n    if (isObject(obj) || isArray(obj) && NUMBER_RE.test(key)) {\n      fn(obj, key);\n    }\n  } else {\n    if (options?.buildGraph && isNil(obj[key])) {\n      obj[key] = {};\n    }\n    const item = obj[key];\n    if (!item) return;\n    const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));\n    if (isArray(item) && options?.descendArray && !isNextArrayIndex) {\n      item.forEach((e) => walk(e, next, fn, options));\n    } else {\n      walk(item, next, fn, options);\n    }\n  }\n}\nfunction setValue(obj, selector, value) {\n  walk(\n    obj,\n    selector,\n    (item, key) => {\n      item[key] = isFunction(value) ? value(item[key]) : value;\n    },\n    { buildGraph: true }\n  );\n}\nfunction removeValue(obj, selector, options) {\n  walk(\n    obj,\n    selector,\n    (item, key) => {\n      if (isArray(item)) {\n        if (/^\\d+$/.test(key)) {\n          item.splice(parseInt(key), 1);\n        } else if (options && options.descendArray) {\n          for (const elem of item) {\n            if (isObject(elem)) {\n              delete elem[key];\n            }\n          }\n        }\n      } else if (isObject(item)) {\n        delete item[key];\n      }\n    },\n    options\n  );\n}\nconst OPERATOR_NAME_PATTERN = /^\\$[a-zA-Z0-9_]+$/;\nfunction isOperator(name) {\n  return OPERATOR_NAME_PATTERN.test(name);\n}\nfunction normalize(expr) {\n  if (isScalar(expr)) {\n    return isRegExp(expr) ? { $regex: expr } : { $eq: expr };\n  }\n  if (isObjectLike(expr)) {\n    if (!Object.keys(expr).some(isOperator)) return { $eq: expr };\n    if (has(expr, \"$regex\")) {\n      const newExpr = { ...expr };\n      newExpr[\"$regex\"] = new RegExp(\n        expr[\"$regex\"],\n        expr[\"$options\"]\n      );\n      delete newExpr[\"$options\"];\n      return newExpr;\n    }\n  }\n  return expr;\n}\nfunction findInsertIndex(sorted, item, comparator = compare) {\n  let lo = 0;\n  let hi = sorted.length - 1;\n  while (lo <= hi) {\n    const mid = Math.round(lo + (hi - lo) / 2);\n    if (comparator(item, sorted[mid]) < 0) {\n      hi = mid - 1;\n    } else if (comparator(item, sorted[mid]) > 0) {\n      lo = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n  return lo;\n}\nexport {\n  MingoError,\n  ValueMap,\n  assert,\n  cloneDeep,\n  compare,\n  ensureArray,\n  filterMissing,\n  findInsertIndex,\n  flatten,\n  groupBy,\n  has,\n  hashCode,\n  intersection,\n  into,\n  isArray,\n  isBoolean,\n  isDate,\n  isEmpty,\n  isEqual,\n  isFunction,\n  isNil,\n  isNotNaN,\n  isNumber,\n  isObject,\n  isObjectLike,\n  isOperator,\n  isRegExp,\n  isString,\n  isSymbol,\n  merge,\n  normalize,\n  removeValue,\n  resolve,\n  resolveGraph,\n  setValue,\n  stringify,\n  truthy,\n  typeOf,\n  unique,\n  walk\n};\n","/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nexport class ObliviousSet {\n    ttl;\n    map = new Map();\n    /**\n     * Creating calls to setTimeout() is expensive,\n     * so we only do that if there is not timeout already open.\n     */\n    _to = false;\n    constructor(ttl) {\n        this.ttl = ttl;\n    }\n    has(value) {\n        return this.map.has(value);\n    }\n    add(value) {\n        this.map.set(value, now());\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        if (!this._to) {\n            this._to = true;\n            setTimeout(() => {\n                this._to = false;\n                removeTooOldValues(this);\n            }, 0);\n        }\n    }\n    clear() {\n        this.map.clear();\n    }\n}\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(obliviousSet) {\n    const olderThen = now() - obliviousSet.ttl;\n    const iterator = obliviousSet.map[Symbol.iterator]();\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n        const next = iterator.next().value;\n        if (!next) {\n            return; // no more elements\n        }\n        const value = next[0];\n        const time = next[1];\n        if (time < olderThen) {\n            obliviousSet.map.delete(value);\n        }\n        else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\nexport function now() {\n    return Date.now();\n}\n//# sourceMappingURL=index.js.map","/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\n\nimport { filter } from 'rxjs/operators';\nimport { appendToArray, requestIdlePromiseNoQueue } from \"./plugins/utils/index.js\";\n\n/**\n * This buffer rembemers previous change events\n * so that queries can use them on .exec()\n * to calculate the new result set via event-reduce instead\n * of running the query against the storage.\n */\nexport var ChangeEventBuffer = /*#__PURE__*/function () {\n  /**\n   * These properties are private to ensure they cannot\n   * be read without first processing the lazy tasks.\n   */\n\n  /**\n   * array with changeEvents\n   * starts with oldest known event, ends with newest\n  */\n\n  function ChangeEventBuffer(collection) {\n    this.subs = [];\n    this.counter = 0;\n    this.eventCounterMap = new WeakMap();\n    this.buffer = [];\n    this.limit = 100;\n    this.tasks = new Set();\n    this.collection = collection;\n    this.subs.push(this.collection.eventBulks$.pipe(filter(bulk => !bulk.isLocal)).subscribe(eventBulk => {\n      this.tasks.add(() => this._handleChangeEvents(eventBulk.events));\n      if (this.tasks.size <= 1) {\n        requestIdlePromiseNoQueue().then(() => {\n          this.processTasks();\n        });\n      }\n    }));\n  }\n  var _proto = ChangeEventBuffer.prototype;\n  _proto.processTasks = function processTasks() {\n    if (this.tasks.size === 0) {\n      return;\n    }\n    var tasks = Array.from(this.tasks);\n    tasks.forEach(task => task());\n    this.tasks.clear();\n  };\n  _proto._handleChangeEvents = function _handleChangeEvents(events) {\n    var counterBefore = this.counter;\n    this.counter = this.counter + events.length;\n    if (events.length > this.limit) {\n      this.buffer = events.slice(events.length * -1);\n    } else {\n      appendToArray(this.buffer, events);\n      this.buffer = this.buffer.slice(this.limit * -1);\n    }\n    var counterBase = counterBefore + 1;\n    var eventCounterMap = this.eventCounterMap;\n    for (var index = 0; index < events.length; index++) {\n      var event = events[index];\n      eventCounterMap.set(event, counterBase + index);\n    }\n  };\n  _proto.getCounter = function getCounter() {\n    this.processTasks();\n    return this.counter;\n  };\n  _proto.getBuffer = function getBuffer() {\n    this.processTasks();\n    return this.buffer;\n  }\n\n  /**\n   * gets the array-index for the given pointer\n   * @return arrayIndex which can be used to iterate from there. If null, pointer is out of lower bound\n   */;\n  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {\n    this.processTasks();\n    var oldestEvent = this.buffer[0];\n    var oldestCounter = this.eventCounterMap.get(oldestEvent);\n    if (pointer < oldestCounter) return null; // out of bounds\n\n    var rest = pointer - oldestCounter;\n    return rest;\n  }\n\n  /**\n   * get all changeEvents which came in later than the pointer-event\n   * @return array with change-events. If null, pointer out of bounds\n   */;\n  _proto.getFrom = function getFrom(pointer) {\n    this.processTasks();\n    var ret = [];\n    var currentIndex = this.getArrayIndexByPointer(pointer);\n    if (currentIndex === null)\n      // out of bounds\n      return null;\n    while (true) {\n      var nextEvent = this.buffer[currentIndex];\n      currentIndex++;\n      if (!nextEvent) {\n        return ret;\n      } else {\n        ret.push(nextEvent);\n      }\n    }\n  };\n  _proto.runFrom = function runFrom(pointer, fn) {\n    this.processTasks();\n    var ret = this.getFrom(pointer);\n    if (ret === null) {\n      throw new Error('out of bounds');\n    } else {\n      ret.forEach(cE => fn(cE));\n    }\n  }\n\n  /**\n   * no matter how many operations are done on one document,\n   * only the last operation has to be checked to calculate the new state\n   * this function reduces the events to the last ChangeEvent of each doc.\n   * This functionality is currently disabled. It is questionable if\n   * pre-merging the events would really be faster or actually slower.\n   */;\n  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {\n    this.processTasks();\n    return changeEvents.slice(0);\n  };\n  _proto.close = function close() {\n    this.tasks.clear();\n    this.subs.forEach(sub => sub.unsubscribe());\n  };\n  return ChangeEventBuffer;\n}();\nexport function createChangeEventBuffer(collection) {\n  return new ChangeEventBuffer(collection);\n}\n//# sourceMappingURL=change-event-buffer.js.map","import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { getFromMapOrThrow, getHeightOfRevision, overwriteGetterForCaching, requestIdlePromiseNoQueue } from \"./plugins/utils/index.js\";\nimport { overwritable } from \"./overwritable.js\";\n\n/**\n * Because we have to create many cache items,\n * we use an array instead of an object with properties\n * for better performance and less memory usage.\n * @link https://stackoverflow.com/questions/17295056/array-vs-object-efficiency-in-javascript\n */\n\n/**\n * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n */\n\n/**\n * The DocumentCache stores RxDocument objects\n * by their primary key and revision.\n * This is useful on client side applications where\n * it is not known how much memory can be used, so\n * we de-duplicate RxDocument states to save memory.\n * To not fill up the memory with old document states, the DocumentCache\n * only contains weak references to the RxDocuments themself.\n * @link https://caniuse.com/?search=weakref\n */\nexport var DocumentCache = /*#__PURE__*/function () {\n  /**\n   * Process stuff lazy to not block the CPU\n   * on critical paths.\n   */\n\n  /**\n   * Some JavaScript runtimes like QuickJS,\n   * so not have a FinalizationRegistry or WeakRef.\n   * Therefore we need a workaround which might waste a lot of memory,\n   * but at least works.\n   */\n\n  function DocumentCache(primaryPath, changes$,\n  /**\n   * A method that can create a RxDocument by the given document data.\n   */\n  documentCreator) {\n    this.cacheItemByDocId = new Map();\n    this.tasks = new Set();\n    this.registry = typeof FinalizationRegistry === 'function' ? new FinalizationRegistry(docMeta => {\n      var docId = docMeta.docId;\n      var cacheItem = this.cacheItemByDocId.get(docId);\n      if (cacheItem) {\n        cacheItem[0].delete(docMeta.revisionHeight);\n        if (cacheItem[0].size === 0) {\n          /**\n           * No state of the document is cached anymore,\n           * so we can clean up.\n           */\n          this.cacheItemByDocId.delete(docId);\n        }\n      }\n    }) : undefined;\n    this.primaryPath = primaryPath;\n    this.changes$ = changes$;\n    this.documentCreator = documentCreator;\n    changes$.subscribe(events => {\n      this.tasks.add(() => {\n        var cacheItemByDocId = this.cacheItemByDocId;\n        for (var index = 0; index < events.length; index++) {\n          var event = events[index];\n          var cacheItem = cacheItemByDocId.get(event.documentId);\n          if (cacheItem) {\n            var documentData = event.documentData;\n            if (!documentData) {\n              documentData = event.previousDocumentData;\n            }\n            cacheItem[1] = documentData;\n          }\n        }\n      });\n      if (this.tasks.size <= 1) {\n        requestIdlePromiseNoQueue().then(() => {\n          this.processTasks();\n        });\n      }\n    });\n  }\n  var _proto = DocumentCache.prototype;\n  _proto.processTasks = function processTasks() {\n    if (this.tasks.size === 0) {\n      return;\n    }\n    var tasks = Array.from(this.tasks);\n    tasks.forEach(task => task());\n    this.tasks.clear();\n  }\n\n  /**\n   * Get the RxDocument from the cache\n   * and create a new one if not exits before.\n   * @overwrites itself with the actual function\n   * because this is @performance relevant.\n   * It is called on each document row for each write and read.\n   */;\n  /**\n   * Throws if not exists\n   */\n  _proto.getLatestDocumentData = function getLatestDocumentData(docId) {\n    this.processTasks();\n    var cacheItem = getFromMapOrThrow(this.cacheItemByDocId, docId);\n    return cacheItem[1];\n  };\n  _proto.getLatestDocumentDataIfExists = function getLatestDocumentDataIfExists(docId) {\n    this.processTasks();\n    var cacheItem = this.cacheItemByDocId.get(docId);\n    if (cacheItem) {\n      return cacheItem[1];\n    }\n  };\n  return _createClass(DocumentCache, [{\n    key: \"getCachedRxDocuments\",\n    get: function () {\n      var fn = getCachedRxDocumentMonad(this);\n      return overwriteGetterForCaching(this, 'getCachedRxDocuments', fn);\n    }\n  }, {\n    key: \"getCachedRxDocument\",\n    get: function () {\n      var fn = getCachedRxDocumentMonad(this);\n      return overwriteGetterForCaching(this, 'getCachedRxDocument', doc => fn([doc])[0]);\n    }\n  }]);\n}();\n\n/**\n * This function is called very very often.\n * This is likely the most important function for RxDB overall performance\n * @hotPath This is one of the most important methods for performance.\n * It is used in many places to transform the raw document data into RxDocuments.\n */\nfunction getCachedRxDocumentMonad(docCache) {\n  var primaryPath = docCache.primaryPath;\n  var cacheItemByDocId = docCache.cacheItemByDocId;\n  var registry = docCache.registry;\n  var deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\n  var documentCreator = docCache.documentCreator;\n  var fn = docsData => {\n    var ret = new Array(docsData.length);\n    var registryTasks = [];\n    for (var index = 0; index < docsData.length; index++) {\n      var docData = docsData[index];\n      var docId = docData[primaryPath];\n      var revisionHeight = getHeightOfRevision(docData._rev);\n      var byRev = void 0;\n      var cachedRxDocumentWeakRef = void 0;\n      var cacheItem = cacheItemByDocId.get(docId);\n      if (!cacheItem) {\n        byRev = new Map();\n        cacheItem = [byRev, docData];\n        cacheItemByDocId.set(docId, cacheItem);\n      } else {\n        byRev = cacheItem[0];\n        cachedRxDocumentWeakRef = byRev.get(revisionHeight);\n      }\n      var cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : undefined;\n      if (!cachedRxDocument) {\n        docData = deepFreezeWhenDevMode(docData);\n        cachedRxDocument = documentCreator(docData);\n        byRev.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));\n        if (registry) {\n          registryTasks.push(cachedRxDocument);\n        }\n      }\n      ret[index] = cachedRxDocument;\n    }\n    if (registryTasks.length > 0 && registry) {\n      /**\n       * Calling registry.register() has shown to have\n       * really bad performance. So we add the cached documents\n       * lazily.\n       */\n      docCache.tasks.add(() => {\n        for (var _index = 0; _index < registryTasks.length; _index++) {\n          var doc = registryTasks[_index];\n          registry.register(doc, {\n            docId: doc.primary,\n            revisionHeight: getHeightOfRevision(doc.revision)\n          });\n        }\n      });\n      if (docCache.tasks.size <= 1) {\n        requestIdlePromiseNoQueue().then(() => {\n          docCache.processTasks();\n        });\n      }\n    }\n    return ret;\n  };\n  return fn;\n}\nexport function mapDocumentsDataToCacheDocs(docCache, docsData) {\n  var getCachedRxDocuments = docCache.getCachedRxDocuments;\n  return getCachedRxDocuments(docsData);\n}\n\n/**\n * Fallback for JavaScript runtimes that do not support WeakRef.\n * The fallback will keep the items in cache forever,\n * but at least works.\n */\nvar HAS_WEAK_REF = typeof WeakRef === 'function';\nvar createWeakRefWithFallback = HAS_WEAK_REF ? createWeakRef : createWeakRefFallback;\nfunction createWeakRef(obj) {\n  return new WeakRef(obj);\n}\nfunction createWeakRefFallback(obj) {\n  return {\n    deref() {\n      return obj;\n    }\n  };\n}\n//# sourceMappingURL=doc-cache.js.map","import { calculateActionName, runAction } from 'event-reduce-js';\nimport { rxChangeEventToEventReduceChangeEvent } from \"./rx-change-event.js\";\nimport { clone, ensureNotFalsy, getFromMapOrCreate } from \"./plugins/utils/index.js\";\nimport { getQueryMatcher, getSortComparator, normalizeMangoQuery } from \"./rx-query-helper.js\";\nexport function getSortFieldsOfQuery(primaryKey, query) {\n  if (!query.sort || query.sort.length === 0) {\n    return [primaryKey];\n  } else {\n    return query.sort.map(part => Object.keys(part)[0]);\n  }\n}\nexport var RXQUERY_QUERY_PARAMS_CACHE = new WeakMap();\nexport function getQueryParams(rxQuery) {\n  return getFromMapOrCreate(RXQUERY_QUERY_PARAMS_CACHE, rxQuery, () => {\n    var collection = rxQuery.collection;\n    var normalizedMangoQuery = normalizeMangoQuery(collection.storageInstance.schema, clone(rxQuery.mangoQuery));\n    var primaryKey = collection.schema.primaryPath;\n\n    /**\n     * Create a custom sort comparator\n     * that uses the hooks to ensure\n     * we send for example compressed documents to be sorted by compressed queries.\n     */\n    var sortComparator = getSortComparator(collection.schema.jsonSchema, normalizedMangoQuery);\n    var useSortComparator = (docA, docB) => {\n      var sortComparatorData = {\n        docA,\n        docB,\n        rxQuery\n      };\n      return sortComparator(sortComparatorData.docA, sortComparatorData.docB);\n    };\n\n    /**\n     * Create a custom query matcher\n     * that uses the hooks to ensure\n     * we send for example compressed documents to match compressed queries.\n     */\n    var queryMatcher = getQueryMatcher(collection.schema.jsonSchema, normalizedMangoQuery);\n    var useQueryMatcher = doc => {\n      var queryMatcherData = {\n        doc,\n        rxQuery\n      };\n      return queryMatcher(queryMatcherData.doc);\n    };\n    var ret = {\n      primaryKey: rxQuery.collection.schema.primaryPath,\n      skip: normalizedMangoQuery.skip,\n      limit: normalizedMangoQuery.limit,\n      sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery),\n      sortComparator: useSortComparator,\n      queryMatcher: useQueryMatcher\n    };\n    return ret;\n  });\n}\nexport function calculateNewResults(rxQuery, rxChangeEvents) {\n  if (!rxQuery.collection.database.eventReduce) {\n    return {\n      runFullQueryAgain: true\n    };\n  }\n  var queryParams = getQueryParams(rxQuery);\n  var previousResults = ensureNotFalsy(rxQuery._result).docsData.slice(0);\n  var previousResultsMap = ensureNotFalsy(rxQuery._result).docsDataMap;\n  var changed = false;\n  var eventReduceEvents = [];\n  for (var index = 0; index < rxChangeEvents.length; index++) {\n    var cE = rxChangeEvents[index];\n    var eventReduceEvent = rxChangeEventToEventReduceChangeEvent(cE);\n    if (eventReduceEvent) {\n      eventReduceEvents.push(eventReduceEvent);\n    }\n  }\n  var foundNonOptimizeable = eventReduceEvents.find(eventReduceEvent => {\n    var stateResolveFunctionInput = {\n      queryParams,\n      changeEvent: eventReduceEvent,\n      previousResults,\n      keyDocumentMap: previousResultsMap\n    };\n    var actionName = calculateActionName(stateResolveFunctionInput);\n    if (actionName === 'runFullQueryAgain') {\n      return true;\n    } else if (actionName !== 'doNothing') {\n      changed = true;\n      runAction(actionName, queryParams, eventReduceEvent, previousResults, previousResultsMap);\n      return false;\n    }\n  });\n  if (foundNonOptimizeable) {\n    return {\n      runFullQueryAgain: true\n    };\n  } else {\n    return {\n      runFullQueryAgain: false,\n      changed,\n      newResults: previousResults\n    };\n  }\n}\n//# sourceMappingURL=event-reduce.js.map","/**\n * hook-functions that can be extended by the plugin\n */\nexport var HOOKS = {\n  /**\n   * Runs before a plugin is added.\n   * Use this to block the usage of non-compatible plugins.\n   */\n  preAddRxPlugin: [],\n  /**\n   * functions that run before the database is created\n   */\n  preCreateRxDatabase: [],\n  /**\n   * runs after the database is created and prepared\n   * but before the instance is returned to the user\n   * @async\n   */\n  createRxDatabase: [],\n  preCreateRxCollection: [],\n  createRxCollection: [],\n  createRxState: [],\n  /**\n  * runs at the end of the close-process of a collection\n  * @async\n  */\n  postCloseRxCollection: [],\n  /**\n   * Runs after a collection is removed.\n   * @async\n   */\n  postRemoveRxCollection: [],\n  /**\n    * functions that get the json-schema as input\n    * to do additionally checks/manipulation\n    */\n  preCreateRxSchema: [],\n  /**\n   * functions that run after the RxSchema is created\n   * gets RxSchema as attribute\n   */\n  createRxSchema: [],\n  prePrepareRxQuery: [],\n  preCreateRxQuery: [],\n  /**\n   * Runs before a query is send to the\n   * prepareQuery function of the storage engine.\n   */\n  prePrepareQuery: [],\n  createRxDocument: [],\n  /**\n   * runs after a RxDocument is created,\n   * cannot be async\n   */\n  postCreateRxDocument: [],\n  /**\n   * Runs before a RxStorageInstance is created\n   * gets the params of createStorageInstance()\n   * as attribute so you can manipulate them.\n   * Notice that you have to clone stuff before mutating the inputs.\n   */\n  preCreateRxStorageInstance: [],\n  preStorageWrite: [],\n  /**\n   * runs on the document-data before the document is migrated\n   * {\n   *   doc: Object, // original doc-data\n   *   migrated: // migrated doc-data after run through migration-strategies\n   * }\n   */\n  preMigrateDocument: [],\n  /**\n   * runs after the migration of a document has been done\n   */\n  postMigrateDocument: [],\n  /**\n   * runs at the beginning of the close-process of a database\n   */\n  preCloseRxDatabase: [],\n  /**\n   * runs after a database has been removed\n   * @async\n   */\n  postRemoveRxDatabase: [],\n  postCleanup: [],\n  /**\n   * runs before the replication writes the rows to master\n   * but before the rows have been modified\n   * @async\n   */\n  preReplicationMasterWrite: [],\n  /**\n   * runs after the replication has been sent to the server\n   * but before the new documents have been handled\n   * @async\n   */\n  preReplicationMasterWriteDocumentsHandle: []\n};\nexport function runPluginHooks(hookKey, obj) {\n  if (HOOKS[hookKey].length > 0) {\n    HOOKS[hookKey].forEach(fun => fun(obj));\n  }\n}\n\n/**\n * We do intentionally not run the hooks in parallel\n * because that makes stuff unpredictable and we use runAsyncPluginHooks()\n * only in places that are not that relevant for performance.\n */\nexport async function runAsyncPluginHooks(hookKey, obj) {\n  for (var fn of HOOKS[hookKey]) {\n    await fn(obj);\n  }\n}\n\n/**\n * used in tests to remove hooks\n */\nexport function _clearHook(type, fun) {\n  HOOKS[type] = HOOKS[type].filter(h => h !== fun);\n}\n//# sourceMappingURL=hooks.js.map","import { isBulkWriteConflictError, rxStorageWriteErrorToRxError } from \"./rx-error.js\";\nimport { clone, ensureNotFalsy, getFromMapOrCreate, getFromMapOrThrow, getHeightOfRevision, stripMetaDataFromDocument } from \"./plugins/utils/index.js\";\nimport { getWrittenDocumentsFromBulkWriteResponse } from \"./rx-storage-helper.js\";\n/**\n * The incremental write queue\n * batches up all incremental writes to a collection\n * so that performance can be improved by:\n * - Running only one write even when there are multiple modifications to the same document.\n * - Run all writes ins a single bulkWrite() call even when there are writes to many documents.\n */\nexport var IncrementalWriteQueue = /*#__PURE__*/function () {\n  function IncrementalWriteQueue(storageInstance, primaryPath,\n  // can be used to run hooks etc.\n  preWrite, postWrite) {\n    this.queueByDocId = new Map();\n    this.isRunning = false;\n    this.storageInstance = storageInstance;\n    this.primaryPath = primaryPath;\n    this.preWrite = preWrite;\n    this.postWrite = postWrite;\n  }\n  var _proto = IncrementalWriteQueue.prototype;\n  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {\n    var docId = lastKnownDocumentState[this.primaryPath];\n    var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n    var ret = new Promise((resolve, reject) => {\n      var item = {\n        lastKnownDocumentState,\n        modifier,\n        resolve,\n        reject\n      };\n      ensureNotFalsy(ar).push(item);\n      this.triggerRun();\n    });\n    return ret;\n  };\n  _proto.triggerRun = async function triggerRun() {\n    if (this.isRunning === true || this.queueByDocId.size === 0) {\n      // already running\n      return;\n    }\n    this.isRunning = true;\n    var writeRows = [];\n\n    /**\n     * 'take over' so that while the async functions runs,\n     * new incremental updates could be added from the outside.\n     */\n    var itemsById = this.queueByDocId;\n    this.queueByDocId = new Map();\n    await Promise.all(Array.from(itemsById.entries()).map(async ([_docId, items]) => {\n      var oldData = findNewestOfDocumentStates(items.map(i => i.lastKnownDocumentState));\n      var newData = oldData;\n      for (var item of items) {\n        try {\n          newData = await item.modifier(\n          /**\n           * We have to clone() each time because the modifier\n           * might throw while it already changed some properties\n           * of the document.\n           */\n          clone(newData));\n        } catch (err) {\n          item.reject(err);\n          item.reject = () => {};\n          item.resolve = () => {};\n        }\n      }\n      try {\n        await this.preWrite(newData, oldData);\n      } catch (err) {\n        /**\n         * If the before-hooks fail,\n         * we reject all of the writes because it is\n         * not possible to determine which one is to blame.\n         */\n        items.forEach(item => item.reject(err));\n        return;\n      }\n      writeRows.push({\n        previous: oldData,\n        document: newData\n      });\n    }));\n    var writeResult = writeRows.length > 0 ? await this.storageInstance.bulkWrite(writeRows, 'incremental-write') : {\n      error: []\n    };\n\n    // process success\n    await Promise.all(getWrittenDocumentsFromBulkWriteResponse(this.primaryPath, writeRows, writeResult).map(result => {\n      var docId = result[this.primaryPath];\n      this.postWrite(result);\n      var items = getFromMapOrThrow(itemsById, docId);\n      items.forEach(item => item.resolve(result));\n    }));\n\n    // process errors\n    writeResult.error.forEach(error => {\n      var docId = error.documentId;\n      var items = getFromMapOrThrow(itemsById, docId);\n      var isConflict = isBulkWriteConflictError(error);\n      if (isConflict) {\n        // had conflict -> retry afterwards\n        var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n        /**\n         * Add the items back to this.queueByDocId\n         * by maintaining the original order.\n         */\n        items.reverse().forEach(item => {\n          item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);\n          ensureNotFalsy(ar).unshift(item);\n        });\n      } else {\n        // other error -> must be thrown\n        var rxError = rxStorageWriteErrorToRxError(error);\n        items.forEach(item => item.reject(rxError));\n      }\n    });\n    this.isRunning = false;\n\n    /**\n     * Always trigger another run\n     * because in between there might be new items\n     * been added to the queue.\n     */\n    return this.triggerRun();\n  };\n  return IncrementalWriteQueue;\n}();\nexport function modifierFromPublicToInternal(publicModifier) {\n  var ret = async docData => {\n    var withoutMeta = stripMetaDataFromDocument(docData);\n    withoutMeta._deleted = docData._deleted;\n    var modified = await publicModifier(withoutMeta);\n    var reattachedMeta = Object.assign({}, modified, {\n      _meta: docData._meta,\n      _attachments: docData._attachments,\n      _rev: docData._rev,\n      _deleted: typeof modified._deleted !== 'undefined' ? modified._deleted : docData._deleted\n    });\n    if (typeof reattachedMeta._deleted === 'undefined') {\n      reattachedMeta._deleted = false;\n    }\n    return reattachedMeta;\n  };\n  return ret;\n}\nexport function findNewestOfDocumentStates(docs) {\n  var newest = docs[0];\n  var newestRevisionHeight = getHeightOfRevision(newest._rev);\n  docs.forEach(doc => {\n    var height = getHeightOfRevision(doc._rev);\n    if (height > newestRevisionHeight) {\n      newest = doc;\n      newestRevisionHeight = height;\n    }\n  });\n  return newest;\n}\n//# sourceMappingURL=incremental-write.js.map","/**\n * functions that can or should be overwritten by plugins\n * IMPORTANT: Do not import any big stuff from RxDB here!\n * An 'overwritable' can be used inside WebWorkers for RxStorage only,\n * and we do not want to have the full RxDB lib bundled in them.\n */\n\nexport var overwritable = {\n  /**\n   * if this method is overwritten with one\n   * that returns true, we do additional checks\n   * which help the developer but have bad performance\n   */\n  isDevMode() {\n    return false;\n  },\n  /**\n   * Deep freezes and object when in dev-mode.\n   * Deep-Freezing has the same performance as deep-cloning, so we only do that in dev-mode.\n   * Also, we can ensure the readonly state via typescript\n   * @link https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n   */\n  deepFreezeWhenDevMode(obj) {\n    return obj;\n  },\n  /**\n   * overwritten to map error-codes to text-messages\n   */\n  tunnelErrorMessage(message) {\n    return \"\\n        RxDB Error-Code: \" + message + \".\\n        Hint: Error messages are not included in RxDB core to reduce build size.\\n        To show the full error messages and to ensure that you do not make any mistakes when using RxDB,\\n        use the dev-mode plugin when you are in development mode: https://rxdb.info/dev-mode.html?console=error\\n        \";\n  }\n};\n//# sourceMappingURL=overwritable.js.map","import { filter, mergeMap, tap } from 'rxjs/operators';\nimport { getPrimaryFieldOfPrimaryKey } from \"./rx-schema-helper.js\";\nimport { flatClone, getFromMapOrCreate, requestIdleCallbackIfAvailable } from \"./plugins/utils/index.js\";\nimport { BehaviorSubject, firstValueFrom } from 'rxjs';\n\n/**\n * Returns the validation errors.\n * If document is fully valid, returns an empty array.\n */\n\n/**\n * cache the validators by the schema string\n * so we can reuse them when multiple collections have the same schema\n *\n * Notice: to make it easier and not dependent on a hash function,\n * we use the plain json string.\n */\nvar VALIDATOR_CACHE_BY_VALIDATOR_KEY = new Map();\n\n/**\n * This factory is used in the validation plugins\n * so that we can reuse the basic storage wrapping code.\n */\nexport function wrappedValidateStorageFactory(\n/**\n * Returns a method that can be used to validate\n * documents and throws when the document is not valid.\n */\ngetValidator,\n/**\n * A string to identify the validation library.\n */\nvalidatorKey) {\n  var VALIDATOR_CACHE = getFromMapOrCreate(VALIDATOR_CACHE_BY_VALIDATOR_KEY, validatorKey, () => new Map());\n  function initValidator(schema) {\n    return getFromMapOrCreate(VALIDATOR_CACHE, JSON.stringify(schema), () => getValidator(schema));\n  }\n  return args => {\n    return Object.assign({}, args.storage, {\n      name: 'validate-' + validatorKey + '-' + args.storage.name,\n      async createStorageInstance(params) {\n        var instance = await args.storage.createStorageInstance(params);\n        var primaryPath = getPrimaryFieldOfPrimaryKey(params.schema.primaryKey);\n\n        /**\n         * Lazy initialize the validator\n         * to save initial page load performance.\n         * Some libraries take really long to initialize the validator\n         * from the schema.\n         */\n        var validatorCached;\n        requestIdleCallbackIfAvailable(() => validatorCached = initValidator(params.schema));\n        var oldBulkWrite = instance.bulkWrite.bind(instance);\n        instance.bulkWrite = (documentWrites, context) => {\n          if (!validatorCached) {\n            validatorCached = initValidator(params.schema);\n          }\n          var errors = [];\n          var continueWrites = [];\n          documentWrites.forEach(row => {\n            var documentId = row.document[primaryPath];\n            var validationErrors = validatorCached(row.document);\n            if (validationErrors.length > 0) {\n              errors.push({\n                status: 422,\n                isError: true,\n                documentId,\n                writeRow: row,\n                validationErrors,\n                schema: instance.schema\n              });\n            } else {\n              continueWrites.push(row);\n            }\n          });\n          var writePromise = continueWrites.length > 0 ? oldBulkWrite(continueWrites, context) : Promise.resolve({\n            error: [],\n            success: []\n          });\n          return writePromise.then(writeResult => {\n            errors.forEach(validationError => {\n              writeResult.error.push(validationError);\n            });\n            return writeResult;\n          });\n        };\n        return instance;\n      }\n    });\n  };\n}\n\n/**\n * Used in plugins to easily modify all in- and outgoing\n * data of that storage instance.\n */\nexport function wrapRxStorageInstance(originalSchema, instance, modifyToStorage, modifyFromStorage, modifyAttachmentFromStorage = v => v) {\n  async function toStorage(docData) {\n    if (!docData) {\n      return docData;\n    }\n    return await modifyToStorage(docData);\n  }\n  async function fromStorage(docData) {\n    if (!docData) {\n      return docData;\n    }\n    return await modifyFromStorage(docData);\n  }\n  async function errorFromStorage(error) {\n    var ret = flatClone(error);\n    ret.writeRow = flatClone(ret.writeRow);\n    if (ret.documentInDb) {\n      ret.documentInDb = await fromStorage(ret.documentInDb);\n    }\n    if (ret.writeRow.previous) {\n      ret.writeRow.previous = await fromStorage(ret.writeRow.previous);\n    }\n    ret.writeRow.document = await fromStorage(ret.writeRow.document);\n    return ret;\n  }\n  var processingChangesCount$ = new BehaviorSubject(0);\n  var wrappedInstance = {\n    databaseName: instance.databaseName,\n    internals: instance.internals,\n    cleanup: instance.cleanup.bind(instance),\n    options: instance.options,\n    close: instance.close.bind(instance),\n    schema: originalSchema,\n    collectionName: instance.collectionName,\n    count: instance.count.bind(instance),\n    remove: instance.remove.bind(instance),\n    originalStorageInstance: instance,\n    bulkWrite: async (documentWrites, context) => {\n      var useRows = [];\n      await Promise.all(documentWrites.map(async row => {\n        var [previous, document] = await Promise.all([row.previous ? toStorage(row.previous) : undefined, toStorage(row.document)]);\n        useRows.push({\n          previous,\n          document\n        });\n      }));\n      var writeResult = await instance.bulkWrite(useRows, context);\n      var ret = {\n        error: []\n      };\n      var promises = [];\n      writeResult.error.forEach(error => {\n        promises.push(errorFromStorage(error).then(err => ret.error.push(err)));\n      });\n      await Promise.all(promises);\n\n      /**\n       * By definition, all change events must be emitted\n       * BEFORE the write call resolves.\n       * To ensure that even when the modifiers are async,\n       * we wait here until the processing queue is empty.\n       */\n      await firstValueFrom(processingChangesCount$.pipe(filter(v => v === 0)));\n      return ret;\n    },\n    query: preparedQuery => {\n      return instance.query(preparedQuery).then(queryResult => {\n        return Promise.all(queryResult.documents.map(doc => fromStorage(doc)));\n      }).then(documents => ({\n        documents: documents\n      }));\n    },\n    getAttachmentData: async (documentId, attachmentId, digest) => {\n      var data = await instance.getAttachmentData(documentId, attachmentId, digest);\n      data = await modifyAttachmentFromStorage(data);\n      return data;\n    },\n    findDocumentsById: (ids, deleted) => {\n      return instance.findDocumentsById(ids, deleted).then(async findResult => {\n        var ret = [];\n        await Promise.all(findResult.map(async doc => {\n          ret.push(await fromStorage(doc));\n        }));\n        return ret;\n      });\n    },\n    getChangedDocumentsSince: !instance.getChangedDocumentsSince ? undefined : (limit, checkpoint) => {\n      return instance.getChangedDocumentsSince(limit, checkpoint).then(async result => {\n        return {\n          checkpoint: result.checkpoint,\n          documents: await Promise.all(result.documents.map(d => fromStorage(d)))\n        };\n      });\n    },\n    changeStream: () => {\n      return instance.changeStream().pipe(tap(() => processingChangesCount$.next(processingChangesCount$.getValue() + 1)), mergeMap(async eventBulk => {\n        var useEvents = await Promise.all(eventBulk.events.map(async event => {\n          var [documentData, previousDocumentData] = await Promise.all([fromStorage(event.documentData), fromStorage(event.previousDocumentData)]);\n          var ev = {\n            operation: event.operation,\n            documentId: event.documentId,\n            documentData: documentData,\n            previousDocumentData: previousDocumentData,\n            isLocal: false\n          };\n          return ev;\n        }));\n        var ret = {\n          id: eventBulk.id,\n          events: useEvents,\n          checkpoint: eventBulk.checkpoint,\n          context: eventBulk.context\n        };\n        return ret;\n      }), tap(() => processingChangesCount$.next(processingChangesCount$.getValue() - 1)));\n    }\n  };\n  return wrappedInstance;\n}\n//# sourceMappingURL=plugin-helpers.js.map","/**\n * this handles how plugins are added to rxdb\n * basically it changes the internal prototypes\n * by passing them to the plugins-functions\n */\nimport { RxSchema } from \"./rx-schema.js\";\nimport { basePrototype as RxDocumentPrototype } from \"./rx-document.js\";\nimport { RxQueryBase } from \"./rx-query.js\";\nimport { RxCollectionBase } from \"./rx-collection.js\";\nimport { RxDatabaseBase } from \"./rx-database.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { HOOKS, runPluginHooks } from \"./hooks.js\";\nimport { newRxError, newRxTypeError } from \"./rx-error.js\";\n\n/**\n * prototypes that can be manipulated with a plugin\n */\nvar PROTOTYPES = {\n  RxSchema: RxSchema.prototype,\n  RxDocument: RxDocumentPrototype,\n  RxQuery: RxQueryBase.prototype,\n  RxCollection: RxCollectionBase.prototype,\n  RxDatabase: RxDatabaseBase.prototype\n};\nvar ADDED_PLUGINS = new Set();\nvar ADDED_PLUGIN_NAMES = new Set();\n\n/**\n * Add a plugin to the RxDB library.\n * Plugins are added globally and cannot be removed.\n */\nexport function addRxPlugin(plugin) {\n  runPluginHooks('preAddRxPlugin', {\n    plugin,\n    plugins: ADDED_PLUGINS\n  });\n\n  // do nothing if added before\n  if (ADDED_PLUGINS.has(plugin)) {\n    return;\n  } else {\n    // ensure no other plugin with the same name was already added\n    if (ADDED_PLUGIN_NAMES.has(plugin.name)) {\n      throw newRxError('PL3', {\n        name: plugin.name,\n        plugin\n      });\n    }\n    ADDED_PLUGINS.add(plugin);\n    ADDED_PLUGIN_NAMES.add(plugin.name);\n  }\n\n  /**\n   * To identify broken configurations,\n   * we only allow RxDB plugins to be passed into addRxPlugin().\n   */\n  if (!plugin.rxdb) {\n    throw newRxTypeError('PL1', {\n      plugin\n    });\n  }\n  if (plugin.init) {\n    plugin.init();\n  }\n\n  // prototype-overwrites\n  if (plugin.prototypes) {\n    Object.entries(plugin.prototypes).forEach(([name, fun]) => {\n      return fun(PROTOTYPES[name]);\n    });\n  }\n  // overwritable-overwrites\n  if (plugin.overwritable) {\n    Object.assign(overwritable, plugin.overwritable);\n  }\n  // extend-hooks\n  if (plugin.hooks) {\n    Object.entries(plugin.hooks).forEach(([name, hooksObj]) => {\n      if (hooksObj.after) {\n        HOOKS[name].push(hooksObj.after);\n      }\n      if (hooksObj.before) {\n        HOOKS[name].unshift(hooksObj.before);\n      }\n    });\n  }\n}\n//# sourceMappingURL=plugin.js.map","import { newRxError } from \"../../rx-error.js\";\nimport { ensureNotFalsy } from \"../utils/index.js\";\nexport function ensureSchemaSupportsAttachments(doc) {\n  var schemaJson = doc.collection.schema.jsonSchema;\n  if (!schemaJson.attachments) {\n    throw newRxError('AT1', {\n      link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n    });\n  }\n}\nexport function assignMethodsToAttachment(attachment) {\n  Object.entries(attachment.doc.collection.attachments).forEach(([funName, fun]) => {\n    Object.defineProperty(attachment, funName, {\n      get: () => fun.bind(attachment)\n    });\n  });\n}\n\n/**\n * Fill up the missing attachment.data of the newDocument\n * so that the new document can be send to somewhere else\n * which could then receive all required attachments data\n * that it did not have before.\n */\nexport async function fillWriteDataForAttachmentsChange(primaryPath, storageInstance, newDocument, originalDocument) {\n  if (!newDocument._attachments || originalDocument && !originalDocument._attachments) {\n    throw new Error('_attachments missing');\n  }\n  var docId = newDocument[primaryPath];\n  var originalAttachmentsIds = new Set(originalDocument && originalDocument._attachments ? Object.keys(originalDocument._attachments) : []);\n  await Promise.all(Object.entries(newDocument._attachments).map(async ([key, value]) => {\n    if ((!originalAttachmentsIds.has(key) || originalDocument && ensureNotFalsy(originalDocument._attachments)[key].digest !== value.digest) && !value.data) {\n      var attachmentDataString = await storageInstance.getAttachmentData(docId, key, value.digest);\n      value.data = attachmentDataString;\n    }\n  }));\n  return newDocument;\n}\n//# sourceMappingURL=attachments-utils.js.map","import { newRxError } from \"../../rx-error.js\";\nimport { fillPrimaryKey, getPrimaryFieldOfPrimaryKey } from \"../../rx-schema-helper.js\";\nexport function ensurePrimaryKeyValid(primaryKey, docData) {\n  if (!primaryKey) {\n    throw newRxError('DOC20', {\n      primaryKey,\n      document: docData\n    });\n  }\n\n  /**\n   * This is required so that we can left-pad\n   * the primaryKey and we are still able to de-left-pad\n   * it to get again the original key.\n   */\n  if (primaryKey !== primaryKey.trim()) {\n    throw newRxError('DOC21', {\n      primaryKey,\n      document: docData\n    });\n  }\n  if (primaryKey.includes('\\r') || primaryKey.includes('\\n')) {\n    throw newRxError('DOC22', {\n      primaryKey,\n      document: docData\n    });\n  }\n  if (primaryKey.includes('\"')) {\n    throw newRxError('DOC23', {\n      primaryKey,\n      document: docData\n    });\n  }\n}\n\n/**\n * Deeply checks if the object contains an\n * instance of the JavaScript Date class.\n * @recursive\n */\nexport function containsDateInstance(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (obj[key] instanceof Date) {\n        return true;\n      }\n      if (typeof obj[key] === 'object' && containsDateInstance(obj[key])) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nexport function checkWriteRows(storageInstance, rows) {\n  var primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);\n  var _loop = function (writeRow) {\n    // ensure that the primary key has not been changed\n    writeRow.document = fillPrimaryKey(primaryPath, storageInstance.schema, writeRow.document);\n\n    /**\n     * Ensure that _meta fields have been merged\n     * and not replaced.\n     * This is important so that when one plugin A\n     * sets a _meta field and another plugin B does a write\n     * to the document, it must be ensured that the\n     * field of plugin A was not removed.\n     */\n    if (writeRow.previous) {\n      Object.keys(writeRow.previous._meta).forEach(metaFieldName => {\n        if (!Object.prototype.hasOwnProperty.call(writeRow.document._meta, metaFieldName)) {\n          throw newRxError('SNH', {\n            dataBefore: writeRow.previous,\n            dataAfter: writeRow.document,\n            args: {\n              metaFieldName\n            }\n          });\n        }\n      });\n    }\n\n    /**\n     * Ensure it can be structured cloned\n     */\n    try {\n      /**\n       * Notice that structuredClone() is not available\n       * in ReactNative, so we test for JSON.stringify() instead\n       * @link https://github.com/pubkey/rxdb/issues/5046#issuecomment-1827374498\n       */\n      if (typeof structuredClone === 'function') {\n        structuredClone(writeRow);\n      } else {\n        JSON.parse(JSON.stringify(writeRow));\n      }\n    } catch (err) {\n      throw newRxError('DOC24', {\n        collection: storageInstance.collectionName,\n        document: writeRow.document\n      });\n    }\n\n    /**\n     * Ensure it does not contain a Date() object\n     */\n    if (containsDateInstance(writeRow.document)) {\n      throw newRxError('DOC24', {\n        collection: storageInstance.collectionName,\n        document: writeRow.document\n      });\n    }\n  };\n  for (var writeRow of rows) {\n    _loop(writeRow);\n  }\n}\n//# sourceMappingURL=check-document.js.map","import { newRxTypeError, newRxError } from \"../../rx-error.js\";\nimport { getPreviousVersions } from \"../../rx-schema.js\";\n\n/**\n * checks if the migrationStrategies are ok, throws if not\n * @throws {Error|TypeError} if not ok\n */\nexport function checkMigrationStrategies(schema, migrationStrategies) {\n  // migrationStrategies must be object not array\n  if (typeof migrationStrategies !== 'object' || Array.isArray(migrationStrategies)) {\n    throw newRxTypeError('COL11', {\n      schema\n    });\n  }\n  var previousVersions = getPreviousVersions(schema);\n\n  // for every previousVersion there must be strategy\n  if (previousVersions.length !== Object.keys(migrationStrategies).length) {\n    throw newRxError('COL12', {\n      have: Object.keys(migrationStrategies),\n      should: previousVersions\n    });\n  }\n\n  // every strategy must have number as property and be a function\n  previousVersions.map(vNr => ({\n    v: vNr,\n    s: migrationStrategies[vNr + 1]\n  })).filter(strategy => typeof strategy.s !== 'function').forEach(strategy => {\n    throw newRxTypeError('COL13', {\n      version: strategy.v,\n      type: typeof strategy,\n      schema\n    });\n  });\n  return true;\n}\n//# sourceMappingURL=check-migration-strategies.js.map","import { newRxError, newRxTypeError } from \"../../rx-error.js\";\nimport { rxCollectionProperties, rxDocumentProperties } from \"./entity-properties.js\";\n\n/**\n * checks if the given static methods are allowed\n * @throws if not allowed\n */\nexport function checkOrmMethods(statics) {\n  if (!statics) {\n    return;\n  }\n  Object.entries(statics).forEach(([k, v]) => {\n    if (typeof k !== 'string') {\n      throw newRxTypeError('COL14', {\n        name: k\n      });\n    }\n    if (k.startsWith('_')) {\n      throw newRxTypeError('COL15', {\n        name: k\n      });\n    }\n    if (typeof v !== 'function') {\n      throw newRxTypeError('COL16', {\n        name: k,\n        type: typeof k\n      });\n    }\n    if (rxCollectionProperties().includes(k) || rxDocumentProperties().includes(k)) {\n      throw newRxError('COL17', {\n        name: k\n      });\n    }\n  });\n}\nexport function checkOrmDocumentMethods(schema, methods) {\n  var topLevelFields = Object.keys(schema.properties);\n  if (!methods) {\n    return;\n  }\n  Object.keys(methods).filter(funName => topLevelFields.includes(funName)).forEach(funName => {\n    throw newRxError('COL18', {\n      funName\n    });\n  });\n}\n//# sourceMappingURL=check-orm.js.map","import { newRxError, newRxTypeError } from \"../../rx-error.js\";\nimport { deepEqual, findUndefinedPath } from \"../utils/index.js\";\nimport { prepareQuery } from \"../../rx-query-helper.js\";\n\n/**\n * accidentally passing a non-valid object into the query params\n * is very hard to debug especially when queries are observed\n * This is why we do some checks here in dev-mode\n */\nexport function checkQuery(args) {\n  var isPlainObject = Object.prototype.toString.call(args.queryObj) === '[object Object]';\n  if (!isPlainObject) {\n    throw newRxTypeError('QU11', {\n      op: args.op,\n      collection: args.collection.name,\n      queryObj: args.queryObj\n    });\n  }\n  var validKeys = ['selector', 'limit', 'skip', 'sort', 'index'];\n  Object.keys(args.queryObj).forEach(key => {\n    if (!validKeys.includes(key)) {\n      throw newRxTypeError('QU11', {\n        op: args.op,\n        collection: args.collection.name,\n        queryObj: args.queryObj,\n        key,\n        args: {\n          validKeys\n        }\n      });\n    }\n  });\n\n  // do not allow skip or limit for count queries\n  if (args.op === 'count' && (args.queryObj.limit || args.queryObj.skip)) {\n    throw newRxError('QU15', {\n      collection: args.collection.name,\n      query: args.queryObj\n    });\n  }\n  ensureObjectDoesNotContainRegExp(args.queryObj);\n}\nexport function checkMangoQuery(args) {\n  var schema = args.rxQuery.collection.schema.jsonSchema;\n  var undefinedFieldPath = findUndefinedPath(args.mangoQuery);\n  if (undefinedFieldPath) {\n    throw newRxError('QU19', {\n      field: undefinedFieldPath,\n      query: args.mangoQuery\n    });\n  }\n\n  /**\n   * Ensure that all top level fields are included in the schema.\n   * TODO this check can be augmented to also check sub-fields.\n   */\n  var massagedSelector = args.mangoQuery.selector;\n  var schemaTopLevelFields = Object.keys(schema.properties);\n  Object.keys(massagedSelector)\n  // do not check operators\n  .filter(fieldOrOperator => !fieldOrOperator.startsWith('$'))\n  // skip this check on non-top-level fields\n  .filter(field => !field.includes('.')).forEach(field => {\n    if (!schemaTopLevelFields.includes(field)) {\n      throw newRxError('QU13', {\n        schema,\n        field,\n        query: args.mangoQuery\n      });\n    }\n  });\n\n  /**\n   * ensure if custom index is set,\n   * it is also defined in the schema\n   */\n  var schemaIndexes = schema.indexes ? schema.indexes : [];\n  var index = args.mangoQuery.index;\n  if (index) {\n    var isInSchema = schemaIndexes.find(schemaIndex => deepEqual(schemaIndex, index));\n    if (!isInSchema) {\n      throw newRxError('QU12', {\n        collection: args.rxQuery.collection.name,\n        query: args.mangoQuery,\n        schema\n      });\n    }\n  }\n\n  /**\n   * Ensure that a count() query can only be used\n   * with selectors that are fully satisfied by the used index.\n   */\n  if (args.rxQuery.op === 'count') {\n    if (!areSelectorsSatisfiedByIndex(args.rxQuery.collection.schema.jsonSchema, args.mangoQuery) && !args.rxQuery.collection.database.allowSlowCount) {\n      throw newRxError('QU14', {\n        collection: args.rxQuery.collection,\n        query: args.mangoQuery\n      });\n    }\n  }\n\n  /**\n   * Ensure that sort only runs on known fields\n   * TODO also check nested fields\n   */\n  if (args.mangoQuery.sort) {\n    args.mangoQuery.sort.map(sortPart => Object.keys(sortPart)[0]).filter(field => !field.includes('.')).forEach(field => {\n      if (!schemaTopLevelFields.includes(field)) {\n        throw newRxError('QU13', {\n          schema,\n          field,\n          query: args.mangoQuery\n        });\n      }\n    });\n  }\n\n  // Do not allow RexExp instances\n  ensureObjectDoesNotContainRegExp(args.mangoQuery);\n}\nexport function areSelectorsSatisfiedByIndex(schema, query) {\n  var preparedQuery = prepareQuery(schema, query);\n  return preparedQuery.queryPlan.selectorSatisfiedByIndex;\n}\n\n/**\n * Ensures that the selector does not contain any RegExp instance.\n * @recursive\n */\nexport function ensureObjectDoesNotContainRegExp(selector) {\n  if (typeof selector !== 'object' || selector === null) {\n    return;\n  }\n  var keys = Object.keys(selector);\n  keys.forEach(key => {\n    var value = selector[key];\n    if (value instanceof RegExp) {\n      throw newRxError('QU16', {\n        field: key,\n        query: selector\n      });\n    } else if (Array.isArray(value)) {\n      value.forEach(item => ensureObjectDoesNotContainRegExp(item));\n    } else {\n      ensureObjectDoesNotContainRegExp(value);\n    }\n  });\n}\n\n/**\n * People often use queries wrong\n * so we have some checks here.\n * For example people use numbers as primary keys\n * which is not allowed.\n */\nexport function isQueryAllowed(args) {\n  if (args.op === 'findOne') {\n    if (typeof args.queryObj === 'number' || Array.isArray(args.queryObj)) {\n      throw newRxTypeError('COL6', {\n        collection: args.collection.name,\n        queryObj: args.queryObj\n      });\n    }\n  } else if (args.op === 'find') {\n    if (typeof args.queryObj === 'string') {\n      throw newRxError('COL5', {\n        collection: args.collection.name,\n        queryObj: args.queryObj\n      });\n    }\n  }\n}\n//# sourceMappingURL=check-query.js.map","/**\n * does additional checks over the schema-json\n * to ensure nothing is broken or not supported\n */\nimport { newRxError } from \"../../rx-error.js\";\nimport { getPrimaryFieldOfPrimaryKey, getSchemaByObjectPath } from \"../../rx-schema-helper.js\";\nimport { appendToArray, flattenObject, getProperty, isMaybeReadonlyArray, trimDots } from \"../../plugins/utils/index.js\";\nimport { rxDocumentProperties } from \"./entity-properties.js\";\n\n/**\n * checks if the fieldname is allowed\n * this makes sure that the fieldnames can be transformed into javascript-vars\n * and does not conquer the observe$ and populate_ fields\n * @throws {Error}\n */\nexport function checkFieldNameRegex(fieldName) {\n  if (fieldName === '_deleted') {\n    return;\n  }\n  if (['properties'].includes(fieldName)) {\n    throw newRxError('SC23', {\n      fieldName\n    });\n  }\n  var regexStr = '^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$';\n  var regex = new RegExp(regexStr);\n  if (\n  /**\n   * It must be allowed to set _id as primaryKey.\n   * This makes it sometimes easier to work with RxDB+CouchDB\n   * @link https://github.com/pubkey/rxdb/issues/681\n   */\n  fieldName !== '_id' && !fieldName.match(regex)) {\n    throw newRxError('SC1', {\n      regex: regexStr,\n      fieldName\n    });\n  }\n}\n\n/**\n * validate that all schema-related things are ok\n */\nexport function validateFieldsDeep(rxJsonSchema) {\n  var primaryPath = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);\n  function checkField(fieldName, schemaObj, path) {\n    if (typeof fieldName === 'string' && typeof schemaObj === 'object' && !Array.isArray(schemaObj) && path.split('.').pop() !== 'patternProperties') checkFieldNameRegex(fieldName);\n\n    // 'item' only allowed it type=='array'\n    if (Object.prototype.hasOwnProperty.call(schemaObj, 'item') && schemaObj.type !== 'array') {\n      throw newRxError('SC2', {\n        fieldName\n      });\n    }\n\n    /**\n     * required fields cannot be set via 'required: true',\n     * but must be set via required: []\n     */\n    if (Object.prototype.hasOwnProperty.call(schemaObj, 'required') && typeof schemaObj.required === 'boolean') {\n      throw newRxError('SC24', {\n        fieldName\n      });\n    }\n\n    // $ref is not allowed\n    if (Object.prototype.hasOwnProperty.call(schemaObj, '$ref')) {\n      throw newRxError('SC40', {\n        fieldName\n      });\n    }\n\n    // if ref given, must be type=='string', type=='array' with string-items or type==['string','null']\n    if (Object.prototype.hasOwnProperty.call(schemaObj, 'ref')) {\n      if (Array.isArray(schemaObj.type)) {\n        if (schemaObj.type.length > 2 || !schemaObj.type.includes('string') || !schemaObj.type.includes('null')) {\n          throw newRxError('SC4', {\n            fieldName\n          });\n        }\n      } else {\n        switch (schemaObj.type) {\n          case 'string':\n            break;\n          case 'array':\n            if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== 'string') {\n              throw newRxError('SC3', {\n                fieldName\n              });\n            }\n            break;\n          default:\n            throw newRxError('SC4', {\n              fieldName\n            });\n        }\n      }\n    }\n    var isNested = path.split('.').length >= 2;\n\n    // nested only\n    if (isNested) {\n      if (schemaObj.default) {\n        throw newRxError('SC7', {\n          path\n        });\n      }\n    }\n\n    // first level\n    if (!isNested) {\n      // if _id is used, it must be primaryKey\n      if (fieldName === '_id' && primaryPath !== '_id') {\n        throw newRxError('COL2', {\n          fieldName\n        });\n      }\n\n      // check underscore fields\n      if (fieldName.charAt(0) === '_') {\n        if (\n        // exceptional allow underscore on these fields.\n        fieldName === '_id' || fieldName === '_deleted') {\n          return;\n        }\n        throw newRxError('SC8', {\n          fieldName\n        });\n      }\n    }\n  }\n  function traverse(currentObj, currentPath) {\n    if (!currentObj || typeof currentObj !== 'object') {\n      return;\n    }\n    Object.keys(currentObj).forEach(attributeName => {\n      var schemaObj = currentObj[attributeName];\n      if (!currentObj.properties && schemaObj && typeof schemaObj === 'object' && !Array.isArray(currentObj)) {\n        checkField(attributeName, schemaObj, currentPath);\n      }\n      var nextPath = currentPath;\n      if (attributeName !== 'properties') nextPath = nextPath + '.' + attributeName;\n      traverse(schemaObj, nextPath);\n    });\n  }\n  traverse(rxJsonSchema, '');\n  return true;\n}\nexport function checkPrimaryKey(jsonSchema) {\n  if (!jsonSchema.primaryKey) {\n    throw newRxError('SC30', {\n      schema: jsonSchema\n    });\n  }\n  function validatePrimarySchemaPart(schemaPart) {\n    if (!schemaPart) {\n      throw newRxError('SC33', {\n        schema: jsonSchema\n      });\n    }\n    var type = schemaPart.type;\n    if (!type || !['string', 'number', 'integer'].includes(type)) {\n      throw newRxError('SC32', {\n        schema: jsonSchema,\n        args: {\n          schemaPart\n        }\n      });\n    }\n  }\n  if (typeof jsonSchema.primaryKey === 'string') {\n    var key = jsonSchema.primaryKey;\n    var schemaPart = jsonSchema.properties[key];\n    validatePrimarySchemaPart(schemaPart);\n  } else {\n    var compositePrimaryKey = jsonSchema.primaryKey;\n    var keySchemaPart = getSchemaByObjectPath(jsonSchema, compositePrimaryKey.key);\n    validatePrimarySchemaPart(keySchemaPart);\n    compositePrimaryKey.fields.forEach(field => {\n      var schemaPart = getSchemaByObjectPath(jsonSchema, field);\n      validatePrimarySchemaPart(schemaPart);\n    });\n  }\n\n  /**\n   * The primary key must have a maxLength set\n   * which is required by some RxStorage implementations\n   * to ensure we can craft custom index strings.\n   */\n  var primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);\n  var primaryPathSchemaPart = jsonSchema.properties[primaryPath];\n  if (!primaryPathSchemaPart.maxLength) {\n    throw newRxError('SC39', {\n      schema: jsonSchema,\n      args: {\n        primaryPathSchemaPart\n      }\n    });\n  } else if (!isFinite(primaryPathSchemaPart.maxLength)) {\n    throw newRxError('SC41', {\n      schema: jsonSchema,\n      args: {\n        primaryPathSchemaPart\n      }\n    });\n  }\n}\n\n/**\n * computes real path of the object path in the collection schema\n */\nfunction getSchemaPropertyRealPath(shortPath) {\n  var pathParts = shortPath.split('.');\n  var realPath = '';\n  for (var i = 0; i < pathParts.length; i += 1) {\n    if (pathParts[i] !== '[]') {\n      realPath = realPath.concat('.properties.'.concat(pathParts[i]));\n    } else {\n      realPath = realPath.concat('.items');\n    }\n  }\n  return trimDots(realPath);\n}\n\n/**\n * does the checking\n * @throws {Error} if something is not ok\n */\nexport function checkSchema(jsonSchema) {\n  if (!jsonSchema.primaryKey) {\n    throw newRxError('SC30', {\n      schema: jsonSchema\n    });\n  }\n  if (!Object.prototype.hasOwnProperty.call(jsonSchema, 'properties')) {\n    throw newRxError('SC29', {\n      schema: jsonSchema\n    });\n  }\n\n  // _rev MUST NOT exist, it is added by RxDB\n  if (jsonSchema.properties._rev) {\n    throw newRxError('SC10', {\n      schema: jsonSchema\n    });\n  }\n\n  // check version\n  if (!Object.prototype.hasOwnProperty.call(jsonSchema, 'version') || typeof jsonSchema.version !== 'number' || jsonSchema.version < 0) {\n    throw newRxError('SC11', {\n      version: jsonSchema.version\n    });\n  }\n  validateFieldsDeep(jsonSchema);\n  checkPrimaryKey(jsonSchema);\n  Object.keys(jsonSchema.properties).forEach(key => {\n    var value = jsonSchema.properties[key];\n    // check primary\n    if (key === jsonSchema.primaryKey) {\n      if (jsonSchema.indexes && jsonSchema.indexes.includes(key)) {\n        throw newRxError('SC13', {\n          value,\n          schema: jsonSchema\n        });\n      }\n      if (value.unique) {\n        throw newRxError('SC14', {\n          value,\n          schema: jsonSchema\n        });\n      }\n      if (jsonSchema.encrypted && jsonSchema.encrypted.includes(key)) {\n        throw newRxError('SC15', {\n          value,\n          schema: jsonSchema\n        });\n      }\n      if (value.type !== 'string') {\n        throw newRxError('SC16', {\n          value,\n          schema: jsonSchema\n        });\n      }\n    }\n\n    // check if RxDocument-property\n    if (rxDocumentProperties().includes(key)) {\n      throw newRxError('SC17', {\n        key,\n        schema: jsonSchema\n      });\n    }\n  });\n\n  // check format of jsonSchema.indexes\n  if (jsonSchema.indexes) {\n    // should be an array\n    if (!isMaybeReadonlyArray(jsonSchema.indexes)) {\n      throw newRxError('SC18', {\n        indexes: jsonSchema.indexes,\n        schema: jsonSchema\n      });\n    }\n    jsonSchema.indexes.forEach(index => {\n      // should contain strings or array of strings\n      if (!(typeof index === 'string' || Array.isArray(index))) {\n        throw newRxError('SC19', {\n          index,\n          schema: jsonSchema\n        });\n      }\n      // if is a compound index it must contain strings\n      if (Array.isArray(index)) {\n        for (var i = 0; i < index.length; i += 1) {\n          if (typeof index[i] !== 'string') {\n            throw newRxError('SC20', {\n              index,\n              schema: jsonSchema\n            });\n          }\n        }\n      }\n\n      /**\n       * To be able to craft custom indexable string with compound fields,\n       * we need to know the maximum fieldlength of the fields values\n       * when they are transformed to strings.\n       * Therefore we need to enforce some properties inside of the schema.\n       */\n      var indexAsArray = isMaybeReadonlyArray(index) ? index : [index];\n      indexAsArray.forEach(fieldName => {\n        var schemaPart = getSchemaByObjectPath(jsonSchema, fieldName);\n        var type = schemaPart.type;\n        switch (type) {\n          case 'string':\n            var maxLength = schemaPart.maxLength;\n            if (!maxLength) {\n              throw newRxError('SC34', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            break;\n          case 'number':\n          case 'integer':\n            var multipleOf = schemaPart.multipleOf;\n            if (!multipleOf) {\n              throw newRxError('SC35', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            var maximum = schemaPart.maximum;\n            var minimum = schemaPart.minimum;\n            if (typeof maximum === 'undefined' || typeof minimum === 'undefined') {\n              throw newRxError('SC37', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            if (!isFinite(maximum) || !isFinite(minimum)) {\n              throw newRxError('SC41', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            break;\n          case 'boolean':\n            /**\n             * If a boolean field is used as an index,\n             * it must be required.\n             */\n            var parentPath = '';\n            var lastPathPart = fieldName;\n            if (fieldName.includes('.')) {\n              var partParts = fieldName.split('.');\n              lastPathPart = partParts.pop();\n              parentPath = partParts.join('.');\n            }\n            var parentSchemaPart = parentPath === '' ? jsonSchema : getSchemaByObjectPath(jsonSchema, parentPath);\n            if (!parentSchemaPart.required || !parentSchemaPart.required.includes(lastPathPart)) {\n              throw newRxError('SC38', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            break;\n          default:\n            throw newRxError('SC36', {\n              fieldName,\n              type: schemaPart.type,\n              schema: jsonSchema\n            });\n        }\n      });\n    });\n  }\n\n  // remove backward-compatibility for index: true\n  Object.keys(flattenObject(jsonSchema)).map(key => {\n    // flattenObject returns only ending paths, we need all paths pointing to an object\n    var split = key.split('.');\n    split.pop(); // all but last\n    return split.join('.');\n  }).filter(key => key !== '').filter((elem, pos, arr) => arr.indexOf(elem) === pos) // unique\n  .filter(key => {\n    // check if this path defines an index\n    var value = getProperty(jsonSchema, key);\n    return value && !!value.index;\n  }).forEach(key => {\n    // replace inner properties\n    key = key.replace('properties.', ''); // first\n    key = key.replace(/\\.properties\\./g, '.'); // middle\n    throw newRxError('SC26', {\n      index: trimDots(key),\n      schema: jsonSchema\n    });\n  });\n\n  /* check types of the indexes */\n  (jsonSchema.indexes || []).reduce((indexPaths, currentIndex) => {\n    if (isMaybeReadonlyArray(currentIndex)) {\n      appendToArray(indexPaths, currentIndex);\n    } else {\n      indexPaths.push(currentIndex);\n    }\n    return indexPaths;\n  }, []).filter((elem, pos, arr) => arr.indexOf(elem) === pos) // from now on working only with unique indexes\n  .map(indexPath => {\n    var realPath = getSchemaPropertyRealPath(indexPath); // real path in the collection schema\n    var schemaObj = getProperty(jsonSchema, realPath); // get the schema of the indexed property\n    if (!schemaObj || typeof schemaObj !== 'object') {\n      throw newRxError('SC21', {\n        index: indexPath,\n        schema: jsonSchema\n      });\n    }\n    return {\n      indexPath,\n      schemaObj\n    };\n  }).filter(index => index.schemaObj.type !== 'string' && index.schemaObj.type !== 'integer' && index.schemaObj.type !== 'number' && index.schemaObj.type !== 'boolean').forEach(index => {\n    throw newRxError('SC22', {\n      key: index.indexPath,\n      type: index.schemaObj.type,\n      schema: jsonSchema\n    });\n  });\n\n  /* ensure encrypted fields exist in the schema */\n  if (jsonSchema.encrypted) {\n    jsonSchema.encrypted.forEach(propPath => {\n      // real path in the collection schema\n      var realPath = getSchemaPropertyRealPath(propPath);\n      // get the schema of the indexed property\n      var schemaObj = getProperty(jsonSchema, realPath);\n      if (!schemaObj || typeof schemaObj !== 'object') {\n        throw newRxError('SC28', {\n          field: propPath,\n          schema: jsonSchema\n        });\n      }\n    });\n  }\n}\n//# sourceMappingURL=check-schema.js.map","import { RXDB_VERSION, hasPremiumFlag, hashStringToNumber } from \"../utils/index.js\";\nvar iframeShown = false;\nvar links = [{\n  text: 'JavaScript Database',\n  url: 'https://rxdb.info/'\n}, {\n  text: 'React Native Database',\n  url: 'https://rxdb.info/react-native-database.html'\n}, {\n  text: 'Local First',\n  url: 'https://rxdb.info/articles/local-first-future.html'\n}, {\n  text: 'Angular IndexedDB',\n  url: 'https://rxdb.info/articles/angular-indexeddb.html'\n}, {\n  text: 'React IndexedDB',\n  url: 'https://rxdb.info/articles/react-indexeddb.html'\n}, {\n  text: 'Firestore Alternative',\n  url: 'https://rxdb.info/articles/firestore-alternative.html'\n}, {\n  text: 'Offline Database',\n  url: 'https://rxdb.info/articles/offline-database.html'\n}, {\n  text: 'JSON Database',\n  url: 'https://rxdb.info/articles/json-database.html'\n}, {\n  text: 'NodeJS Database',\n  url: 'https://rxdb.info/nodejs-database.html'\n}];\n\n/**\n * Adds an iframe to track the results of marketing efforts.\n */\nexport async function addDevModeTrackingIframe() {\n  /**\n   * Only run this in browser AND localhost AND dev-mode.\n   * Make sure this is never used in production by someone.\n   */\n  if (iframeShown || typeof window === 'undefined' || typeof location === 'undefined'\n  // !isLocalHost()\n  ) {\n    return;\n  }\n\n  // do not show if premium flag is set.\n  if (await hasPremiumFlag()) {\n    return;\n  }\n  iframeShown = true;\n\n  /**\n   * Do not use display:none\n   * @link https://medium.com/@zachcaceres/dont-use-display-none-to-hide-iframes-in-safari-b51715eb22c4\n   */\n  var containerDiv = document.createElement('div');\n  containerDiv.style.visibility = 'hidden';\n  containerDiv.style.position = 'absolute';\n  containerDiv.style.top = '0';\n  containerDiv.style.left = '0';\n  containerDiv.style.opacity = '0.1';\n  containerDiv.style.width = '1px';\n  containerDiv.style.height = '1px';\n  containerDiv.style.overflow = 'hidden';\n  var iframe = document.createElement('iframe');\n  iframe.width = '1px';\n  iframe.height = '1px';\n  iframe.src = 'https://rxdb.info/html/dev-mode-iframe.html?version=' + RXDB_VERSION;\n  containerDiv.appendChild(iframe);\n  var hashNr = hashStringToNumber(location.host);\n  var useLinkId = hashNr % links.length;\n  var useLink = links[useLinkId];\n  var link = document.createElement('a');\n  link.href = useLink.url;\n  link.target = '_blank';\n  link.innerText = useLink.text;\n  var p = document.createElement('p');\n  p.innerText = 'This is the iframe which is shown when the RxDB Dev-Mode is enabled. Also see ';\n  p.appendChild(link);\n  containerDiv.appendChild(p);\n  document.body.appendChild(containerDiv);\n}\nfunction isLocalHost() {\n  return location.hostname === 'localhost' || location.hostname.includes('localhost') || location.hostname === '127.0.0.1' || location.hostname === '0.0.0.0' || location.hostname === '[::1]' // IPv6\n  ;\n}\n//# sourceMappingURL=dev-mode-tracking.js.map","import { RxCollectionBase } from \"../../rx-collection.js\";\nimport { RxDatabaseBase } from \"../../rx-database.js\";\nimport { createRxDocumentConstructor, basePrototype } from \"../../rx-document.js\";\n\n/**\n * returns all possible properties of a RxCollection-instance\n */\nvar _rxCollectionProperties;\nexport function rxCollectionProperties() {\n  if (!_rxCollectionProperties) {\n    var pseudoInstance = new RxCollectionBase();\n    var ownProperties = Object.getOwnPropertyNames(pseudoInstance);\n    var prototypeProperties = Object.getOwnPropertyNames(Object.getPrototypeOf(pseudoInstance));\n    _rxCollectionProperties = [...ownProperties, ...prototypeProperties];\n  }\n  return _rxCollectionProperties;\n}\n\n/**\n * returns all possible properties of a RxDatabase-instance\n */\nvar _rxDatabaseProperties;\nexport function rxDatabaseProperties() {\n  if (!_rxDatabaseProperties) {\n    var pseudoInstance = new RxDatabaseBase('pseudoInstance', 'memory');\n    var ownProperties = Object.getOwnPropertyNames(pseudoInstance);\n    var prototypeProperties = Object.getOwnPropertyNames(Object.getPrototypeOf(pseudoInstance));\n    _rxDatabaseProperties = [...ownProperties, ...prototypeProperties];\n    pseudoInstance.close();\n  }\n  return _rxDatabaseProperties;\n}\n\n/**\n * returns all possible properties of a RxDocument\n */\nvar pseudoConstructor = createRxDocumentConstructor(basePrototype);\nvar pseudoRxDocument = new pseudoConstructor();\nvar _rxDocumentProperties;\nexport function rxDocumentProperties() {\n  if (!_rxDocumentProperties) {\n    var reserved = ['deleted', 'synced'];\n    var ownProperties = Object.getOwnPropertyNames(pseudoRxDocument);\n    var prototypeProperties = Object.getOwnPropertyNames(basePrototype);\n    _rxDocumentProperties = [...ownProperties, ...prototypeProperties, ...reserved];\n  }\n  return _rxDocumentProperties;\n}\n//# sourceMappingURL=entity-properties.js.map","/**\n * this plugin adds the error-messages\n * without it, only error-codes will be shown\n * This is mainly because error-string are hard to compress and we need a smaller build\n */\n\nimport { NON_PREMIUM_COLLECTION_LIMIT } from \"../utils/utils-premium.js\";\nexport var ERROR_MESSAGES = {\n  // util.js / config\n  UT1: 'given name is no string or empty',\n  UT2: \"collection- and database-names must match the regex to be compatible with couchdb databases.\\n    See https://neighbourhood.ie/blog/2020/10/13/everything-you-need-to-know-about-couchdb-database-names/\\n    info: if your database-name specifies a folder, the name must contain the slash-char '/' or '\\\\'\",\n  UT3: 'replication-direction must either be push or pull or both. But not none',\n  UT4: 'given leveldown is no valid adapter',\n  UT5: 'keyCompression is set to true in the schema but no key-compression handler is used in the storage',\n  UT6: 'schema contains encrypted fields but no encryption handler is used in the storage',\n  UT7: 'attachments.compression is enabled but no attachment-compression plugin is used',\n  // plugins\n  PL1: 'Given plugin is not RxDB plugin.',\n  // removed in 14.0.0 - PouchDB RxStorage was removed - PL2: 'You tried importing a RxDB plugin to pouchdb. Use addRxPlugin() instead.',\n  PL3: 'A plugin with the same name was already added but it was not the exact same JavaScript object',\n  // pouch-db.js\n  // removed in 12.0.0 - P1: 'PouchDB.getBatch: limit must be > 2',\n  P2: 'bulkWrite() cannot be called with an empty array',\n  // removed in 12.0.0 - P3: 'bulkAddRevisions cannot be called with an empty array',\n\n  // rx-query\n  QU1: 'RxQuery._execOverDatabase(): op not known',\n  // removed in 9.0.0 - QU2: 'limit() must get a number',\n  // removed in 9.0.0 - QU3: 'skip() must get a number',\n  QU4: 'RxQuery.regex(): You cannot use .regex() on the primary field',\n  QU5: 'RxQuery.sort(): does not work because key is not defined in the schema',\n  QU6: 'RxQuery.limit(): cannot be called on .findOne()',\n  // removed in 12.0.0 (should by ensured by the typings) - QU7: 'query must be an object',\n  // removed in 12.0.0 (should by ensured by the typings) - QU8: 'query cannot be an array',\n  QU9: 'throwIfMissing can only be used in findOne queries',\n  QU10: 'result empty and throwIfMissing: true',\n  QU11: 'RxQuery: no valid query params given',\n  QU12: 'Given index is not in schema',\n  QU13: 'A top level field of the query is not included in the schema',\n  QU14: 'Running a count() query in slow mode is now allowed. Either run a count() query with a selector that fully matches an index ' + 'or set allowSlowCount=true when calling the createRxDatabase',\n  QU15: 'For count queries it is not allowed to use skip or limit',\n  QU16: '$regex queries must be defined by a string, not an RegExp instance. ' + 'This is because RegExp objects cannot be JSON stringified and also they are mutable which would be dangerous',\n  QU17: 'Chained queries cannot be used on findByIds() RxQuery instances',\n  QU18: 'Malformed query result data. This likely happens because you create a OPFS-storage RxDatabase inside of a worker but did not set the usesRxDatabaseInWorker setting. https://rxdb.info/rx-storage-opfs.html#setting-usesrxdatabaseinworker-when-a-rxdatabase-is-also-used-inside-of-the-worker ',\n  QU19: 'Queries must not contain fields or properties with the value `undefined`: https://github.com/pubkey/rxdb/issues/6792#issuecomment-2624555824 ',\n  // mquery.js\n  MQ1: 'path must be a string or object',\n  MQ2: 'Invalid argument',\n  MQ3: 'Invalid sort() argument. Must be a string, object, or array',\n  MQ4: 'Invalid argument. Expected instanceof mquery or plain object',\n  MQ5: 'method must be used after where() when called with these arguments',\n  MQ6: 'Can\\'t mix sort syntaxes. Use either array or object | .sort([[\\'field\\', 1], [\\'test\\', -1]]) | .sort({ field: 1, test: -1 })',\n  MQ7: 'Invalid sort value',\n  MQ8: 'Can\\'t mix sort syntaxes. Use either array or object',\n  // rx-database\n  DB1: 'RxDocument.prepare(): another instance on this adapter has a different password',\n  DB2: 'RxDatabase.addCollections(): collection-names cannot start with underscore _',\n  DB3: 'RxDatabase.addCollections(): collection already exists. use myDatabase[collectionName] to get it',\n  DB4: 'RxDatabase.addCollections(): schema is missing',\n  DB5: 'RxDatabase.addCollections(): collection-name not allowed',\n  DB6: 'RxDatabase.addCollections(): another instance created this collection with a different schema. Read this https://rxdb.info/questions-answers.html?console=qa#cant-change-the-schema ',\n  // removed in 13.0.0 (now part of the encryption plugin) DB7: 'RxDatabase.addCollections(): schema encrypted but no password given',\n  DB8: 'createRxDatabase(): A RxDatabase with the same name and adapter already exists.\\n' + 'Make sure to use this combination of storage+databaseName only once\\n' + 'If you have the duplicate database on purpose to simulate multi-tab behavior in unit tests, set \"ignoreDuplicate: true\".\\n' + 'As alternative you can set \"closeDuplicates: true\" like if this happens in your react projects with hot reload that reloads the code without reloading the process.',\n  DB9: 'ignoreDuplicate is only allowed in dev-mode and must never be used in production',\n  // removed in 14.0.0 - PouchDB RxStorage is removed - DB9: 'createRxDatabase(): Adapter not added. Use addPouchPlugin(require(\\'pouchdb-adapter-[adaptername]\\'));',\n  // removed in 14.0.0 - PouchDB RxStorage is removed DB10: 'createRxDatabase(): To use leveldown-adapters, you have to add the leveldb-plugin. Use addPouchPlugin(require(\\'pouchdb-adapter-leveldb\\'));',\n  DB11: 'createRxDatabase(): Invalid db-name, folder-paths must not have an ending slash',\n  DB12: 'RxDatabase.addCollections(): could not write to internal store',\n  DB13: 'createRxDatabase(): Invalid db-name or collection name, name contains the dollar sign',\n  DB14: 'no custom reactivity factory added on database creation',\n  // rx-collection\n  COL1: 'RxDocument.insert() You cannot insert an existing document',\n  COL2: 'RxCollection.insert() fieldName ._id can only be used as primaryKey',\n  COL3: 'RxCollection.upsert() does not work without primary',\n  COL4: 'RxCollection.incrementalUpsert() does not work without primary',\n  COL5: 'RxCollection.find() if you want to search by _id, use .findOne(_id)',\n  COL6: 'RxCollection.findOne() needs a queryObject or string. Notice that in RxDB, primary keys must be strings and cannot be numbers.',\n  COL7: 'hook must be a function',\n  COL8: 'hooks-when not known',\n  COL9: 'RxCollection.addHook() hook-name not known',\n  COL10: 'RxCollection .postCreate-hooks cannot be async',\n  COL11: 'migrationStrategies must be an object',\n  COL12: 'A migrationStrategy is missing or too much',\n  COL13: 'migrationStrategy must be a function',\n  COL14: 'given static method-name is not a string',\n  COL15: 'static method-names cannot start with underscore _',\n  COL16: 'given static method is not a function',\n  COL17: 'RxCollection.ORM: statics-name not allowed',\n  COL18: 'collection-method not allowed because fieldname is in the schema',\n  // removed in 14.0.0, use CONFLICT instead - COL19: 'Document update conflict. When changing a document you must work on the previous revision',\n  COL20: 'Storage write error',\n  COL21: 'The RxCollection is closed or removed already, either from this JavaScript realm or from another, like a browser tab',\n  CONFLICT: 'Document update conflict. When changing a document you must work on the previous revision',\n  COL22: '.bulkInsert() and .bulkUpsert() cannot be run with multiple documents that have the same primary key',\n  COL23: 'In the open-source version of RxDB, the amount of collections that can exist in parallel is limited to ' + NON_PREMIUM_COLLECTION_LIMIT + '. If you already purchased the premium access, you can remove this limit: https://rxdb.info/rx-collection.html#faq',\n  // rx-document.js\n  DOC1: 'RxDocument.get$ cannot get observable of in-array fields because order cannot be guessed',\n  DOC2: 'cannot observe primary path',\n  DOC3: 'final fields cannot be observed',\n  DOC4: 'RxDocument.get$ cannot observe a non-existed field',\n  DOC5: 'RxDocument.populate() cannot populate a non-existed field',\n  DOC6: 'RxDocument.populate() cannot populate because path has no ref',\n  DOC7: 'RxDocument.populate() ref-collection not in database',\n  DOC8: 'RxDocument.set(): primary-key cannot be modified',\n  DOC9: 'final fields cannot be modified',\n  DOC10: 'RxDocument.set(): cannot set childpath when rootPath not selected',\n  DOC11: 'RxDocument.save(): can\\'t save deleted document',\n  // removed in 10.0.0 DOC12: 'RxDocument.save(): error',\n  DOC13: 'RxDocument.remove(): Document is already deleted',\n  DOC14: 'RxDocument.close() does not exist',\n  DOC15: 'query cannot be an array',\n  DOC16: 'Since version 8.0.0 RxDocument.set() can only be called on temporary RxDocuments',\n  DOC17: 'Since version 8.0.0 RxDocument.save() can only be called on non-temporary documents',\n  DOC18: 'Document property for composed primary key is missing',\n  DOC19: 'Value of primary key(s) cannot be changed',\n  DOC20: 'PrimaryKey missing',\n  DOC21: 'PrimaryKey must be equal to PrimaryKey.trim(). It cannot start or end with a whitespace',\n  DOC22: 'PrimaryKey must not contain a linebreak',\n  DOC23: 'PrimaryKey must not contain a double-quote [\"]',\n  DOC24: 'Given document data could not be structured cloned. This happens if you pass non-plain-json data into it, like a Date() object or a Function. ' + 'In vue.js this happens if you use ref() on the document data which transforms it into a Proxy object.',\n  // data-migrator.js\n  DM1: 'migrate() Migration has already run',\n  DM2: 'migration of document failed final document does not match final schema',\n  DM3: 'migration already running',\n  DM4: 'Migration errored',\n  DM5: 'Cannot open database state with newer RxDB version. You have to migrate your database state first. See https://rxdb.info/migration-storage.html?console=storage ',\n  // plugins/attachments.js\n  AT1: 'to use attachments, please define this in your schema',\n  // plugins/encryption-crypto-js.js\n  EN1: 'password is not valid',\n  EN2: 'validatePassword: min-length of password not complied',\n  EN3: 'Schema contains encrypted properties but no password is given',\n  EN4: 'Password not valid',\n  // plugins/json-dump.js\n  JD1: 'You must create the collections before you can import their data',\n  JD2: 'RxCollection.importJSON(): the imported json relies on a different schema',\n  JD3: 'RxCollection.importJSON(): json.passwordHash does not match the own',\n  // plugins/leader-election.js\n\n  // plugins/local-documents.js\n  LD1: 'RxDocument.allAttachments$ can\\'t use attachments on local documents',\n  LD2: 'RxDocument.get(): objPath must be a string',\n  LD3: 'RxDocument.get$ cannot get observable of in-array fields because order cannot be guessed',\n  LD4: 'cannot observe primary path',\n  LD5: 'RxDocument.set() id cannot be modified',\n  LD6: 'LocalDocument: Function is not usable on local documents',\n  LD7: 'Local document already exists',\n  LD8: 'localDocuments not activated. Set localDocuments=true on creation, when you want to store local documents on the RxDatabase or RxCollection.',\n  // plugins/replication.js\n  RC1: 'Replication: already added',\n  RC2: 'replicateCouchDB() query must be from the same RxCollection',\n  // removed in 14.0.0 - PouchDB RxStorage is removed RC3: 'RxCollection.syncCouchDB() Do not use a collection\\'s pouchdb as remote, use the collection instead',\n  RC4: 'RxCouchDBReplicationState.awaitInitialReplication() cannot await initial replication when live: true',\n  RC5: 'RxCouchDBReplicationState.awaitInitialReplication() cannot await initial replication if multiInstance because the replication might run on another instance',\n  RC6: 'syncFirestore() serverTimestampField MUST NOT be part of the collections schema and MUST NOT be nested.',\n  RC7: 'SimplePeer requires to have process.nextTick() polyfilled, see https://rxdb.info/replication-webrtc.html?console=webrtc ',\n  RC_PULL: 'RxReplication pull handler threw an error - see .errors for more details',\n  RC_STREAM: 'RxReplication pull stream$ threw an error - see .errors for more details',\n  RC_PUSH: 'RxReplication push handler threw an error - see .errors for more details',\n  RC_PUSH_NO_AR: 'RxReplication push handler did not return an array with the conflicts',\n  RC_WEBRTC_PEER: 'RxReplication WebRTC Peer has error',\n  RC_COUCHDB_1: 'replicateCouchDB() url must end with a slash like \\'https://example.com/mydatabase/\\'',\n  RC_COUCHDB_2: 'replicateCouchDB() did not get valid result with rows.',\n  RC_OUTDATED: 'Outdated client, update required. Replication was canceled',\n  RC_UNAUTHORIZED: 'Unauthorized client, update the replicationState.headers to set correct auth data',\n  RC_FORBIDDEN: 'Client behaves wrong so the replication was canceled. Mostly happens if the client tries to write data that it is not allowed to',\n  // plugins/dev-mode/check-schema.js\n  SC1: 'fieldnames do not match the regex',\n  SC2: 'SchemaCheck: name \\'item\\' reserved for array-fields',\n  SC3: 'SchemaCheck: fieldname has a ref-array but items-type is not string',\n  SC4: 'SchemaCheck: fieldname has a ref but is not type string, [string,null] or array<string>',\n  SC6: 'SchemaCheck: primary can only be defined at top-level',\n  SC7: 'SchemaCheck: default-values can only be defined at top-level',\n  SC8: 'SchemaCheck: first level-fields cannot start with underscore _',\n  SC10: 'SchemaCheck: schema defines ._rev, this will be done automatically',\n  SC11: 'SchemaCheck: schema needs a number >=0 as version',\n  // removed in 10.0.0 - SC12: 'SchemaCheck: primary can only be defined once',\n  SC13: 'SchemaCheck: primary is always index, do not declare it as index',\n  SC14: 'SchemaCheck: primary is always unique, do not declare it as index',\n  SC15: 'SchemaCheck: primary cannot be encrypted',\n  SC16: 'SchemaCheck: primary must have type: string',\n  SC17: 'SchemaCheck: top-level fieldname is not allowed',\n  SC18: 'SchemaCheck: indexes must be an array',\n  SC19: 'SchemaCheck: indexes must contain strings or arrays of strings',\n  SC20: 'SchemaCheck: indexes.array must contain strings',\n  SC21: 'SchemaCheck: given index is not defined in schema',\n  SC22: 'SchemaCheck: given indexKey is not type:string',\n  SC23: 'SchemaCheck: fieldname is not allowed',\n  SC24: 'SchemaCheck: required fields must be set via array. See https://spacetelescope.github.io/understanding-json-schema/reference/object.html#required',\n  SC25: 'SchemaCheck: compoundIndexes needs to be specified in the indexes field',\n  SC26: 'SchemaCheck: indexes needs to be specified at collection schema level',\n  // removed in 16.0.0 - SC27: 'SchemaCheck: encrypted fields need to be specified at collection schema level',\n  SC28: 'SchemaCheck: encrypted fields is not defined in the schema',\n  SC29: 'SchemaCheck: missing object key \\'properties\\'',\n  SC30: 'SchemaCheck: primaryKey is required',\n  SC32: 'SchemaCheck: primary field must have the type string/number/integer',\n  SC33: 'SchemaCheck: used primary key is not a property in the schema',\n  SC34: 'Fields of type string that are used in an index, must have set the maxLength attribute in the schema',\n  SC35: 'Fields of type number/integer that are used in an index, must have set the multipleOf attribute in the schema',\n  SC36: 'A field of this type cannot be used as index',\n  SC37: 'Fields of type number that are used in an index, must have set the minimum and maximum attribute in the schema',\n  SC38: 'Fields of type boolean that are used in an index, must be required in the schema',\n  SC39: 'The primary key must have the maxLength attribute set. Ensure you use the dev-mode plugin when developing with RxDB.',\n  SC40: '$ref fields in the schema are not allowed. RxDB cannot resolve related schemas because it would have a negative performance impact.' + 'It would have to run http requests on runtime. $ref fields should be resolved during build time.',\n  SC41: 'minimum, maximum and maxLength values for indexes must be real numbers, not Infinity or -Infinity',\n  // plugins/dev-mode\n  // removed in 13.9.0, use PL3 instead - DEV1: 'dev-mode added multiple times',\n  DVM1: 'When dev-mode is enabled, your storage must use one of the schema validators at the top level. This is because most problems people have with RxDB is because they store data that is not valid to the schema which causes strange bugs and problems.',\n  // plugins/validate.js\n  VD1: 'Sub-schema not found, does the schemaPath exists in your schema?',\n  VD2: 'object does not match schema',\n  // plugins/in-memory.js\n  // removed in 14.0.0 - PouchDB RxStorage is removed IM1: 'InMemory: Memory-Adapter must be added. Use addPouchPlugin(require(\\'pouchdb-adapter-memory\\'));',\n  // removed in 14.0.0 - PouchDB RxStorage is removed IM2: 'inMemoryCollection.sync(): Do not replicate with the in-memory instance. Replicate with the parent instead',\n\n  // plugins/server.js\n  S1: 'You cannot create collections after calling RxDatabase.server()',\n  // plugins/replication-graphql.js\n  GQL1: 'GraphQL replication: cannot find sub schema by key',\n  // removed in 13.0.0, use RC_PULL instead - GQL2: 'GraphQL replication: unknown errors occurred in replication pull - see innerErrors for more details',\n  GQL3: 'GraphQL replication: pull returns more documents then batchSize',\n  // removed in 13.0.0, use RC_PUSH instead - GQL4: 'GraphQL replication: unknown errors occurred in replication push - see innerErrors for more details',\n\n  // plugins/crdt/\n  CRDT1: 'CRDT operations cannot be used because the crdt options are not set in the schema.',\n  CRDT2: 'RxDocument.incrementalModify() cannot be used when CRDTs are activated.',\n  CRDT3: 'To use CRDTs you MUST NOT set a conflictHandler because the default CRDT conflict handler must be used',\n  // plugins/storage-dexie/\n  DXE1: 'non-required index fields are not possible with the dexie.js RxStorage: https://github.com/pubkey/rxdb/pull/6643#issuecomment-2505310082',\n  // removed in 15.0.0, added boolean index support to dexie storage - DXE1: 'The dexie.js RxStorage does not support boolean indexes, see https://rxdb.info/rx-storage-dexie.html#boolean-index',\n\n  // plugins/storage-sqlite-trial/\n  SQL1: 'The trial version of the SQLite storage does not support attachments.',\n  SQL2: 'The trial version of the SQLite storage is limited to contain 300 documents',\n  SQL3: 'The trial version of the SQLite storage is limited to running 110 operations',\n  // plugins/storage-remote\n  RM1: 'Cannot communicate with a remote that was build on a different RxDB version. Did you forget to rebuild your workers when updating RxDB?',\n  /**\n   * Should never be thrown, use this for\n   * null checks etc. so you do not have to increase the\n   * build size with error message strings.\n   */\n  SNH: 'This should never happen'\n};\n//# sourceMappingURL=error-messages.js.map","import { ERROR_MESSAGES } from \"./error-messages.js\";\nimport { checkSchema } from \"./check-schema.js\";\nimport { checkOrmDocumentMethods, checkOrmMethods } from \"./check-orm.js\";\nimport { checkMigrationStrategies } from \"./check-migration-strategies.js\";\nimport { ensureCollectionNameValid, ensureDatabaseNameIsValid } from \"./unallowed-properties.js\";\nimport { checkMangoQuery, checkQuery, isQueryAllowed } from \"./check-query.js\";\nimport { newRxError } from \"../../rx-error.js\";\nimport { deepFreeze } from \"../../plugins/utils/index.js\";\nimport { checkWriteRows, ensurePrimaryKeyValid } from \"./check-document.js\";\nimport { addDevModeTrackingIframe } from \"./dev-mode-tracking.js\";\nexport * from \"./check-schema.js\";\nexport * from \"./unallowed-properties.js\";\nexport * from \"./check-query.js\";\nvar showDevModeWarning = true;\n\n/**\n * Suppresses the warning message shown in the console, typically invoked once the developer (hello!) \n * has acknowledged it.\n */\nexport function disableWarnings() {\n  showDevModeWarning = false;\n}\n\n/**\n * Deep freezes and object when in dev-mode.\n * Deep-Freezing has the same performance as deep-cloning, so we only do that in dev-mode.\n * Also we can ensure the readonly state via typescript\n * @link https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n */\nexport function deepFreezeWhenDevMode(obj) {\n  // direct return if not suitable for deepFreeze()\n  if (!obj || typeof obj === 'string' || typeof obj === 'number') {\n    return obj;\n  }\n  return deepFreeze(obj);\n}\nexport var DEV_MODE_PLUGIN_NAME = 'dev-mode';\nexport var RxDBDevModePlugin = {\n  name: DEV_MODE_PLUGIN_NAME,\n  rxdb: true,\n  init: () => {\n    addDevModeTrackingIframe();\n    if (showDevModeWarning) {\n      console.warn(['-------------- RxDB dev-mode warning -------------------------------', 'you are seeing this because you use the RxDB dev-mode plugin https://rxdb.info/dev-mode.html?console=dev-mode ', 'This is great in development mode, because it will run many checks to ensure', 'that you use RxDB correct. If you see this in production mode,', 'you did something wrong because the dev-mode plugin will decrease the performance.', '', '🤗 Hint: To get the most out of RxDB, check out the Premium Plugins', 'to get access to faster storages and more professional features: https://rxdb.info/premium/?console=dev-mode ', '', 'You can disable this warning by calling disableWarnings() from the dev-mode plugin.',\n      // '',\n      // 'Also take part in the RxDB User Survey: https://rxdb.info/survey.html',\n      '---------------------------------------------------------------------'].join('\\n'));\n    }\n  },\n  overwritable: {\n    isDevMode() {\n      return true;\n    },\n    deepFreezeWhenDevMode,\n    tunnelErrorMessage(code) {\n      if (!ERROR_MESSAGES[code]) {\n        console.error('RxDB: Error-Code not known: ' + code);\n        throw new Error('Error-Code ' + code + ' not known, contact the maintainer');\n      }\n      var errorMessage = ERROR_MESSAGES[code];\n      return \"\\nError message: \" + errorMessage + \"\\nError code: \" + code;\n    }\n  },\n  hooks: {\n    preCreateRxSchema: {\n      after: checkSchema\n    },\n    preCreateRxDatabase: {\n      before: function (args) {\n        if (!args.storage.name.startsWith('validate-')) {\n          throw newRxError('DVM1', {\n            database: args.name,\n            storage: args.storage.name\n          });\n        }\n      },\n      after: function (args) {\n        ensureDatabaseNameIsValid(args);\n      }\n    },\n    createRxDatabase: {\n      after: async function (args) {}\n    },\n    preCreateRxCollection: {\n      after: function (args) {\n        ensureCollectionNameValid(args);\n        checkOrmDocumentMethods(args.schema, args.methods);\n        if (args.name.charAt(0) === '_') {\n          throw newRxError('DB2', {\n            name: args.name\n          });\n        }\n        if (!args.schema) {\n          throw newRxError('DB4', {\n            name: args.name,\n            args\n          });\n        }\n      }\n    },\n    createRxDocument: {\n      before: function (doc) {\n        ensurePrimaryKeyValid(doc.primary, doc.toJSON(true));\n      }\n    },\n    prePrepareRxQuery: {\n      after: function (args) {\n        isQueryAllowed(args);\n      }\n    },\n    preCreateRxQuery: {\n      after: function (args) {\n        checkQuery(args);\n      }\n    },\n    prePrepareQuery: {\n      after: args => {\n        checkMangoQuery(args);\n      }\n    },\n    preStorageWrite: {\n      before: args => {\n        checkWriteRows(args.storageInstance, args.rows);\n      }\n    },\n    createRxCollection: {\n      after: args => {\n        // check ORM-methods\n        checkOrmMethods(args.creator.statics);\n        checkOrmMethods(args.creator.methods);\n        checkOrmMethods(args.creator.attachments);\n\n        // check migration strategies\n        if (args.creator.schema && args.creator.migrationStrategies) {\n          checkMigrationStrategies(args.creator.schema, args.creator.migrationStrategies);\n        }\n      }\n    }\n  }\n};\n//# sourceMappingURL=index.js.map","import { newRxError, newRxTypeError } from \"../../rx-error.js\";\nimport { rxDatabaseProperties } from \"./entity-properties.js\";\nimport { isFolderPath } from \"../../plugins/utils/index.js\";\n\n/**\n * if the name of a collection\n * clashes with a property of RxDatabase,\n * we get problems so this function prohibits this\n */\nexport function ensureCollectionNameValid(args) {\n  if (rxDatabaseProperties().includes(args.name)) {\n    throw newRxError('DB5', {\n      name: args.name\n    });\n  }\n  validateDatabaseName(args.name);\n}\nexport function ensureDatabaseNameIsValid(args) {\n  validateDatabaseName(args.name);\n  if (args.name.includes('$')) {\n    throw newRxError('DB13', {\n      name: args.name\n    });\n  }\n\n  /**\n   * The server-plugin has problems when a path with and ending slash is given\n   * So we do not allow this.\n   * @link https://github.com/pubkey/rxdb/issues/2251\n   */\n  if (isFolderPath(args.name)) {\n    if (args.name.endsWith('/') || args.name.endsWith('\\\\')) {\n      throw newRxError('DB11', {\n        name: args.name\n      });\n    }\n  }\n}\n\n/**\n * In contrast to CouchDB, we still allow inner uppercase letters\n * like the name fooBar. This makes it way less confusing when naming\n * collections with a JavaScript variable name convention.\n */\nvar validCouchDBStringRegexStr = '^[a-z][_$a-zA-Z0-9\\\\-]*$';\nvar validCouchDBStringRegex = new RegExp(validCouchDBStringRegexStr);\n\n/**\n * Validates that a given string is ok to be used with couchdb-collection-names.\n * We only allow these strings as database- or collection names because it ensures\n * that you later do not get in trouble when you want to use the database together witch couchdb.\n *\n * @link https://docs.couchdb.org/en/stable/api/database/common.html\n * @link https://neighbourhood.ie/blog/2020/10/13/everything-you-need-to-know-about-couchdb-database-names/\n * @throws  {RxError}\n */\nexport function validateDatabaseName(name) {\n  if (typeof name !== 'string' || name.length === 0) {\n    throw newRxTypeError('UT1', {\n      name\n    });\n  }\n\n  // do not check, if foldername is given\n  if (isFolderPath(name)) {\n    return true;\n  }\n  if (!name.match(validCouchDBStringRegex) &&\n  /**\n   * The string ':memory:' is used in the SQLite RxStorage\n   * to persist data into a memory state. Often used in tests.\n   */\n  name !== ':memory:') {\n    throw newRxError('UT2', {\n      regex: validCouchDBStringRegexStr,\n      givenName: name\n    });\n  }\n  return true;\n}\n//# sourceMappingURL=unallowed-properties.js.map","/**\n * this plugin adds the leader-election-capabilities to rxdb\n */\n\nimport { createLeaderElection } from 'broadcast-channel';\nimport { getBroadcastChannelReference, removeBroadcastChannelReference } from \"../../rx-storage-multiinstance.js\";\nimport { PROMISE_RESOLVE_TRUE, getFromMapOrCreate } from \"../utils/index.js\";\nvar LEADER_ELECTORS_OF_DB = new WeakMap();\nvar LEADER_ELECTOR_BY_BROADCAST_CHANNEL = new WeakMap();\n\n/**\n * Returns the leader elector of a broadcast channel.\n * Used to ensure we reuse the same elector for the channel each time.\n */\nexport function getLeaderElectorByBroadcastChannel(broadcastChannel) {\n  return getFromMapOrCreate(LEADER_ELECTOR_BY_BROADCAST_CHANNEL, broadcastChannel, () => createLeaderElection(broadcastChannel));\n}\n\n/**\n * @overwrites RxDatabase().leaderElector for caching\n */\nexport function getForDatabase() {\n  var broadcastChannel = getBroadcastChannelReference(this.storage.name, this.token, this.name, this);\n\n  /**\n   * Clean up the reference on RxDatabase.close()\n   */\n  var oldClose = this.close.bind(this);\n  this.close = function () {\n    removeBroadcastChannelReference(this.token, this);\n    return oldClose();\n  };\n  var elector = getLeaderElectorByBroadcastChannel(broadcastChannel);\n  if (!elector) {\n    elector = getLeaderElectorByBroadcastChannel(broadcastChannel);\n    LEADER_ELECTORS_OF_DB.set(this, elector);\n  }\n\n  /**\n   * Overwrite for caching\n   */\n  this.leaderElector = () => elector;\n  return elector;\n}\nexport function isLeader() {\n  if (!this.multiInstance) {\n    return true;\n  }\n  return this.leaderElector().isLeader;\n}\nexport function waitForLeadership() {\n  if (!this.multiInstance) {\n    return PROMISE_RESOLVE_TRUE;\n  } else {\n    return this.leaderElector().awaitLeadership().then(() => true);\n  }\n}\n\n/**\n * runs when the database gets closed\n */\nexport function onClose(db) {\n  var has = LEADER_ELECTORS_OF_DB.get(db);\n  if (has) {\n    has.die();\n  }\n}\nexport var rxdb = true;\nexport var prototypes = {\n  RxDatabase: proto => {\n    proto.leaderElector = getForDatabase;\n    proto.isLeader = isLeader;\n    proto.waitForLeadership = waitForLeadership;\n  }\n};\nexport var RxDBLeaderElectionPlugin = {\n  name: 'leader-election',\n  rxdb,\n  prototypes,\n  hooks: {\n    preCloseRxDatabase: {\n      after: onClose\n    }\n  }\n};\n//# sourceMappingURL=index.js.map","import { Subject } from 'rxjs';\nimport { ensureNotFalsy, getFromMapOrThrow, PROMISE_RESOLVE_VOID, promiseWait, randomToken } from \"../../plugins/utils/index.js\";\nimport { default as _Peer\n// @ts-ignore\n} from 'simple-peer/simplepeer.min.js';\nvar Peer = _Peer;\nimport { newRxError } from \"../../rx-error.js\";\nfunction sendMessage(ws, msg) {\n  ws.send(JSON.stringify(msg));\n}\nvar DEFAULT_SIGNALING_SERVER_HOSTNAME = 'signaling.rxdb.info';\nexport var DEFAULT_SIGNALING_SERVER = 'wss://' + DEFAULT_SIGNALING_SERVER_HOSTNAME + '/';\nvar defaultServerWarningShown = false;\nexport var SIMPLE_PEER_PING_INTERVAL = 1000 * 60 * 2;\n\n/**\n * Returns a connection handler that uses simple-peer and the signaling server.\n */\nexport function getConnectionHandlerSimplePeer({\n  signalingServerUrl,\n  wrtc,\n  config,\n  webSocketConstructor\n}) {\n  ensureProcessNextTickIsSet();\n  signalingServerUrl = signalingServerUrl ? signalingServerUrl : DEFAULT_SIGNALING_SERVER;\n  webSocketConstructor = webSocketConstructor ? webSocketConstructor : WebSocket;\n  if (signalingServerUrl.includes(DEFAULT_SIGNALING_SERVER_HOSTNAME) && !defaultServerWarningShown) {\n    defaultServerWarningShown = true;\n    console.warn(['RxDB Warning: You are using the RxDB WebRTC replication plugin', 'but you did not specify your own signaling server url.', 'By default it will use a signaling server provided by RxDB at ' + DEFAULT_SIGNALING_SERVER, 'This server is made for demonstration purposes and tryouts. It is not reliable and might be offline at any time.', 'In production you must always use your own signaling server instead.', 'Learn how to run your own server at https://rxdb.info/replication-webrtc.html', 'Also leave a ⭐ at the RxDB github repo 🙏 https://github.com/pubkey/rxdb 🙏'].join(' '));\n  }\n  var creator = async options => {\n    var connect$ = new Subject();\n    var disconnect$ = new Subject();\n    var message$ = new Subject();\n    var response$ = new Subject();\n    var error$ = new Subject();\n    var peers = new Map();\n    var closed = false;\n    var ownPeerId;\n    var socket = undefined;\n    createSocket();\n\n    /**\n     * Send ping signals to the server.\n     */\n    (async () => {\n      while (true) {\n        await promiseWait(SIMPLE_PEER_PING_INTERVAL / 2);\n        if (closed) {\n          break;\n        }\n        if (socket) {\n          sendMessage(socket, {\n            type: 'ping'\n          });\n        }\n      }\n    })();\n\n    /**\n     * @recursive calls it self on socket disconnects\n     * so that when the user goes offline and online\n     * again, it will recreate the WebSocket connection.\n     */\n    function createSocket() {\n      if (closed) {\n        return;\n      }\n      socket = new webSocketConstructor(signalingServerUrl);\n      socket.onclose = () => createSocket();\n      socket.onopen = () => {\n        ensureNotFalsy(socket).onmessage = msgEvent => {\n          var msg = JSON.parse(msgEvent.data);\n          switch (msg.type) {\n            case 'init':\n              ownPeerId = msg.yourPeerId;\n              sendMessage(ensureNotFalsy(socket), {\n                type: 'join',\n                room: options.topic\n              });\n              break;\n            case 'joined':\n              /**\n               * PeerId is created by the signaling server\n               * to prevent spoofing it.\n               */\n              var createPeerConnection = function (remotePeerId) {\n                var disconnected = false;\n                var newSimplePeer = new Peer({\n                  initiator: remotePeerId > ownPeerId,\n                  wrtc,\n                  config,\n                  trickle: true\n                });\n                newSimplePeer.id = randomToken(10);\n                peers.set(remotePeerId, newSimplePeer);\n                newSimplePeer.on('signal', signal => {\n                  sendMessage(ensureNotFalsy(socket), {\n                    type: 'signal',\n                    senderPeerId: ownPeerId,\n                    receiverPeerId: remotePeerId,\n                    room: options.topic,\n                    data: signal\n                  });\n                });\n                newSimplePeer.on('data', messageOrResponse => {\n                  messageOrResponse = JSON.parse(messageOrResponse.toString());\n                  if (messageOrResponse.result) {\n                    response$.next({\n                      peer: newSimplePeer,\n                      response: messageOrResponse\n                    });\n                  } else {\n                    message$.next({\n                      peer: newSimplePeer,\n                      message: messageOrResponse\n                    });\n                  }\n                });\n                newSimplePeer.on('error', error => {\n                  error$.next(newRxError('RC_WEBRTC_PEER', {\n                    error\n                  }));\n                  newSimplePeer.destroy();\n                  if (!disconnected) {\n                    disconnected = true;\n                    disconnect$.next(newSimplePeer);\n                  }\n                });\n                newSimplePeer.on('connect', () => {\n                  connect$.next(newSimplePeer);\n                });\n                newSimplePeer.on('close', () => {\n                  if (!disconnected) {\n                    disconnected = true;\n                    disconnect$.next(newSimplePeer);\n                  }\n                  createPeerConnection(remotePeerId);\n                });\n              };\n              msg.otherPeerIds.forEach(remotePeerId => {\n                if (remotePeerId === ownPeerId || peers.has(remotePeerId)) {\n                  return;\n                } else {\n                  createPeerConnection(remotePeerId);\n                }\n              });\n              break;\n            case 'signal':\n              var peer = getFromMapOrThrow(peers, msg.senderPeerId);\n              peer.signal(msg.data);\n              break;\n          }\n        };\n      };\n    }\n    ;\n    var handler = {\n      error$,\n      connect$,\n      disconnect$,\n      message$,\n      response$,\n      async send(peer, message) {\n        await peer.send(JSON.stringify(message));\n      },\n      close() {\n        closed = true;\n        ensureNotFalsy(socket).close();\n        error$.complete();\n        connect$.complete();\n        disconnect$.complete();\n        message$.complete();\n        response$.complete();\n        return PROMISE_RESOLVE_VOID;\n      }\n    };\n    return handler;\n  };\n  return creator;\n}\n\n/**\n * Multiple people had problems because it requires to have\n * the nextTick() method in the runtime. So we check here and\n * throw a helpful error.\n */\nexport function ensureProcessNextTickIsSet() {\n  if (typeof process === 'undefined' || typeof process.nextTick !== 'function') {\n    throw newRxError('RC7');\n  }\n}\n//# sourceMappingURL=connection-handler-simple-peer.js.map","import { BehaviorSubject, filter, firstValueFrom, map, Subject } from 'rxjs';\nimport { addRxPlugin } from \"../../plugin.js\";\nimport { rxStorageInstanceToReplicationHandler } from \"../../replication-protocol/index.js\";\nimport { ensureNotFalsy, getFromMapOrThrow, randomToken } from \"../../plugins/utils/index.js\";\nimport { RxDBLeaderElectionPlugin } from \"../leader-election/index.js\";\nimport { replicateRxCollection } from \"../replication/index.js\";\nimport { isMasterInWebRTCReplication, sendMessageAndAwaitAnswer } from \"./webrtc-helper.js\";\nimport { newRxError } from \"../../rx-error.js\";\nexport async function replicateWebRTC(options) {\n  var collection = options.collection;\n  addRxPlugin(RxDBLeaderElectionPlugin);\n\n  // fill defaults\n  if (options.pull) {\n    if (!options.pull.batchSize) {\n      options.pull.batchSize = 20;\n    }\n  }\n  if (options.push) {\n    if (!options.push.batchSize) {\n      options.push.batchSize = 20;\n    }\n  }\n  if (collection.database.multiInstance) {\n    await collection.database.waitForLeadership();\n  }\n\n  // used to easier debug stuff\n  var requestCounter = 0;\n  var requestFlag = randomToken(10);\n  function getRequestId() {\n    var count = requestCounter++;\n    return collection.database.token + '|' + requestFlag + '|' + count;\n  }\n  var storageToken = await collection.database.storageToken;\n  var pool = new RxWebRTCReplicationPool(collection, options, await options.connectionHandlerCreator(options));\n  pool.subs.push(pool.connectionHandler.error$.subscribe(err => pool.error$.next(err)), pool.connectionHandler.disconnect$.subscribe(peer => pool.removePeer(peer)));\n\n  /**\n   * Answer if someone requests our storage token\n   */\n  pool.subs.push(pool.connectionHandler.message$.pipe(filter(data => data.message.method === 'token')).subscribe(data => {\n    pool.connectionHandler.send(data.peer, {\n      id: data.message.id,\n      result: storageToken\n    });\n  }));\n  var connectSub = pool.connectionHandler.connect$.pipe(filter(() => !pool.canceled)).subscribe(async peer => {\n    if (options.isPeerValid) {\n      var isValid = await options.isPeerValid(peer);\n      if (!isValid) {\n        return;\n      }\n    }\n    var peerToken;\n    try {\n      var tokenResponse = await sendMessageAndAwaitAnswer(pool.connectionHandler, peer, {\n        id: getRequestId(),\n        method: 'token',\n        params: []\n      });\n      peerToken = tokenResponse.result;\n    } catch (error) {\n      /**\n       * If could not get the tokenResponse,\n       * just ignore that peer.\n       */\n      pool.error$.next(newRxError('RC_WEBRTC_PEER', {\n        error\n      }));\n      return;\n    }\n    var isMaster = await isMasterInWebRTCReplication(collection.database.hashFunction, storageToken, peerToken);\n    var replicationState;\n    if (isMaster) {\n      var masterHandler = pool.masterReplicationHandler;\n      var masterChangeStreamSub = masterHandler.masterChangeStream$.subscribe(ev => {\n        var streamResponse = {\n          id: 'masterChangeStream$',\n          result: ev\n        };\n        pool.connectionHandler.send(peer, streamResponse);\n      });\n\n      // clean up the subscription\n      pool.subs.push(masterChangeStreamSub, pool.connectionHandler.disconnect$.pipe(filter(p => p === peer)).subscribe(() => masterChangeStreamSub.unsubscribe()));\n      var messageSub = pool.connectionHandler.message$.pipe(filter(data => data.peer === peer), filter(data => data.message.method !== 'token')).subscribe(async data => {\n        var {\n          peer: msgPeer,\n          message\n        } = data;\n        /**\n         * If it is not a function,\n         * it means that the client requested the masterChangeStream$\n         */\n        var method = masterHandler[message.method].bind(masterHandler);\n        var result = await method(...message.params);\n        var response = {\n          id: message.id,\n          result\n        };\n        pool.connectionHandler.send(msgPeer, response);\n      });\n      pool.subs.push(messageSub);\n    } else {\n      replicationState = replicateRxCollection({\n        replicationIdentifier: [collection.name, options.topic, peerToken].join('||'),\n        collection: collection,\n        autoStart: true,\n        deletedField: '_deleted',\n        live: true,\n        retryTime: options.retryTime,\n        waitForLeadership: false,\n        pull: options.pull ? Object.assign({}, options.pull, {\n          async handler(lastPulledCheckpoint) {\n            var answer = await sendMessageAndAwaitAnswer(pool.connectionHandler, peer, {\n              method: 'masterChangesSince',\n              params: [lastPulledCheckpoint, ensureNotFalsy(options.pull).batchSize],\n              id: getRequestId()\n            });\n            return answer.result;\n          },\n          stream$: pool.connectionHandler.response$.pipe(filter(m => m.response.id === 'masterChangeStream$'), map(m => m.response.result))\n        }) : undefined,\n        push: options.push ? Object.assign({}, options.push, {\n          async handler(docs) {\n            var answer = await sendMessageAndAwaitAnswer(pool.connectionHandler, peer, {\n              method: 'masterWrite',\n              params: [docs],\n              id: getRequestId()\n            });\n            return answer.result;\n          }\n        }) : undefined\n      });\n    }\n    pool.addPeer(peer, replicationState);\n  });\n  pool.subs.push(connectSub);\n  return pool;\n}\n\n/**\n * Because the WebRTC replication runs between many instances,\n * we use a Pool instead of returning a single replication state.\n */\nexport var RxWebRTCReplicationPool = /*#__PURE__*/function () {\n  function RxWebRTCReplicationPool(collection, options, connectionHandler) {\n    this.peerStates$ = new BehaviorSubject(new Map());\n    this.canceled = false;\n    this.subs = [];\n    this.error$ = new Subject();\n    this.collection = collection;\n    this.options = options;\n    this.connectionHandler = connectionHandler;\n    this.collection.onClose.push(() => this.cancel());\n    this.masterReplicationHandler = rxStorageInstanceToReplicationHandler(collection.storageInstance, collection.conflictHandler, collection.database.token);\n  }\n  var _proto = RxWebRTCReplicationPool.prototype;\n  _proto.addPeer = function addPeer(peer,\n  // only if isMaster=false it has a replicationState\n  replicationState) {\n    var peerState = {\n      peer,\n      replicationState,\n      subs: []\n    };\n    this.peerStates$.next(this.peerStates$.getValue().set(peer, peerState));\n    if (replicationState) {\n      peerState.subs.push(replicationState.error$.subscribe(ev => this.error$.next(ev)));\n    }\n  };\n  _proto.removePeer = function removePeer(peer) {\n    var peerState = getFromMapOrThrow(this.peerStates$.getValue(), peer);\n    this.peerStates$.getValue().delete(peer);\n    this.peerStates$.next(this.peerStates$.getValue());\n    peerState.subs.forEach(sub => sub.unsubscribe());\n    if (peerState.replicationState) {\n      peerState.replicationState.cancel();\n    }\n  }\n\n  // often used in unit tests\n  ;\n  _proto.awaitFirstPeer = function awaitFirstPeer() {\n    return firstValueFrom(this.peerStates$.pipe(filter(peerStates => peerStates.size > 0)));\n  };\n  _proto.cancel = async function cancel() {\n    if (this.canceled) {\n      return;\n    }\n    this.canceled = true;\n    this.subs.forEach(sub => sub.unsubscribe());\n    Array.from(this.peerStates$.getValue().keys()).forEach(peer => {\n      this.removePeer(peer);\n    });\n    await this.connectionHandler.close();\n  };\n  return RxWebRTCReplicationPool;\n}();\nexport * from \"./webrtc-helper.js\";\nexport * from \"./signaling-server.js\";\nexport * from \"./webrtc-types.js\";\n// export * from './connection-handler-webtorrent';\n// export * from './connection-handler-p2pcf';\nexport * from \"./connection-handler-simple-peer.js\";\n//# sourceMappingURL=index.js.map","import { getFromMapOrCreate, promiseWait, randomToken } from \"../utils/index.js\";\nimport { SIMPLE_PEER_PING_INTERVAL } from \"./connection-handler-simple-peer.js\";\nexport var PEER_ID_LENGTH = 12;\n/**\n * Starts a WebRTC signaling server\n * that can be used in tests.\n*/\nexport async function startSignalingServerSimplePeer(serverOptions) {\n  var {\n    WebSocketServer\n  } = await import('ws');\n  var wss = new WebSocketServer(serverOptions);\n  var peerById = new Map();\n  var peersByRoom = new Map();\n  var serverClosed = false;\n  wss.on('close', () => {\n    serverClosed = true;\n    peerById.clear();\n    peersByRoom.clear();\n  });\n\n  /**\n   * Clients can disconnect without telling that to the\n   * server. Therefore we have to automatically disconnect clients that\n   * have not send a ping message in the last 2 minutes.\n   */\n  (async () => {\n    var _loop = async function () {\n      await promiseWait(1000 * 5);\n      var minTime = Date.now() - SIMPLE_PEER_PING_INTERVAL;\n      Array.from(peerById.values()).forEach(peer => {\n        if (peer.lastPing < minTime) {\n          disconnectSocket(peer.id, 'no ping for 2 minutes');\n        }\n      });\n    };\n    while (!serverClosed) {\n      await _loop();\n    }\n  })();\n  function disconnectSocket(peerId, reason) {\n    console.log('# disconnect peer ' + peerId + ' reason: ' + reason);\n    var peer = peerById.get(peerId);\n    if (peer) {\n      peer.socket.close && peer.socket.close(undefined, reason);\n      peer.rooms.forEach(roomId => {\n        var room = peersByRoom.get(roomId);\n        room?.delete(peerId);\n        if (room && room.size === 0) {\n          peersByRoom.delete(roomId);\n        }\n      });\n    }\n    peerById.delete(peerId);\n  }\n  wss.on('connection', function (ws) {\n    /**\n     * PeerID is created by the server to prevent malicious\n     * actors from falsy claiming other peoples ids.\n     */\n    var peerId = randomToken(PEER_ID_LENGTH);\n    var peer = {\n      id: peerId,\n      socket: ws,\n      rooms: new Set(),\n      lastPing: Date.now()\n    };\n    peerById.set(peerId, peer);\n    sendMessage(ws, {\n      type: 'init',\n      yourPeerId: peerId\n    });\n    ws.on('error', err => {\n      console.error('SERVER ERROR:');\n      console.dir(err);\n      disconnectSocket(peerId, 'socket errored');\n    });\n    ws.on('close', () => {\n      disconnectSocket(peerId, 'socket disconnected');\n    });\n    ws.on('message', msgEvent => {\n      peer.lastPing = Date.now();\n      var message = JSON.parse(msgEvent.toString());\n      var type = message.type;\n      switch (type) {\n        case 'join':\n          var roomId = message.room;\n          if (!validateIdString(roomId) || !validateIdString(peerId)) {\n            disconnectSocket(peerId, 'invalid ids');\n            return;\n          }\n          if (peer.rooms.has(peerId)) {\n            return;\n          }\n          peer.rooms.add(roomId);\n          var room = getFromMapOrCreate(peersByRoom, message.room, () => new Set());\n          room.add(peerId);\n\n          // tell everyone about new room state\n          room.forEach(otherPeerId => {\n            var otherPeer = peerById.get(otherPeerId);\n            if (otherPeer) {\n              sendMessage(otherPeer.socket, {\n                type: 'joined',\n                otherPeerIds: Array.from(room)\n              });\n            }\n          });\n          break;\n        case 'signal':\n          if (message.senderPeerId !== peerId) {\n            disconnectSocket(peerId, 'spoofed sender');\n            return;\n          }\n          var receiver = peerById.get(message.receiverPeerId);\n          if (receiver) {\n            sendMessage(receiver.socket, message);\n          }\n          break;\n        case 'ping':\n          break;\n        default:\n          disconnectSocket(peerId, 'unknown message type ' + type);\n      }\n    });\n  });\n  return {\n    port: serverOptions.port,\n    server: wss,\n    localUrl: 'ws://localhost:' + serverOptions.port\n  };\n}\nfunction sendMessage(ws, message) {\n  var msgString = JSON.stringify(message);\n  ws.send(msgString);\n}\nfunction validateIdString(roomId) {\n  if (typeof roomId === 'string' && roomId.length > 5 && roomId.length < 100) {\n    return true;\n  } else {\n    return false;\n  }\n}\n//# sourceMappingURL=signaling-server.js.map","import { filter, firstValueFrom, map } from 'rxjs';\n\n/**\n * To deterministically define which peer is master and\n * which peer is fork, we compare the storage tokens.\n * But we have to hash them before, to ensure that\n * a storageToken like 'aaaaaa' is not always the master\n * for all peers.\n */\nexport async function isMasterInWebRTCReplication(hashFunction, ownStorageToken, otherStorageToken) {\n  var isMaster = (await hashFunction([ownStorageToken, otherStorageToken].join('|'))) > (await hashFunction([otherStorageToken, ownStorageToken].join('|')));\n  return isMaster;\n}\n\n/**\n * Send a message to the peer and await the answer.\n * @throws with an EmptyErrorImpl if the peer connection\n * was closed before an answer was received.\n */\nexport function sendMessageAndAwaitAnswer(handler, peer, message) {\n  var requestId = message.id;\n  var answerPromise = firstValueFrom(handler.response$.pipe(filter(d => d.peer === peer), filter(d => d.response.id === requestId), map(d => d.response)));\n  handler.send(peer, message);\n  return answerPromise;\n}\n//# sourceMappingURL=webrtc-helper.js.map","/**\n * This plugin contains the primitives to create\n * a RxDB client-server replication.\n * It is used in the other replication plugins\n * but also can be used as standalone with a custom replication handler.\n */\n\nimport { BehaviorSubject, combineLatest, filter, mergeMap, Subject } from 'rxjs';\nimport { RxDBLeaderElectionPlugin } from \"../leader-election/index.js\";\nimport { arrayFilterNotEmpty, ensureNotFalsy, errorToPlainJson, flatClone, getFromMapOrCreate, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_TRUE, toArray, toPromise } from \"../../plugins/utils/index.js\";\nimport { awaitRxStorageReplicationFirstInSync, awaitRxStorageReplicationInSync, cancelRxStorageReplication, getRxReplicationMetaInstanceSchema, replicateRxStorageInstance } from \"../../replication-protocol/index.js\";\nimport { newRxError } from \"../../rx-error.js\";\nimport { awaitRetry, DEFAULT_MODIFIER, swapDefaultDeletedTodeletedField, handlePulledDocuments, preventHibernateBrowserTab } from \"./replication-helper.js\";\nimport { addConnectedStorageToCollection, removeConnectedStorageFromCollection } from \"../../rx-database-internal-store.js\";\nimport { addRxPlugin } from \"../../plugin.js\";\nimport { hasEncryption } from \"../../rx-storage-helper.js\";\nimport { overwritable } from \"../../overwritable.js\";\nimport { runAsyncPluginHooks } from \"../../hooks.js\";\nexport var REPLICATION_STATE_BY_COLLECTION = new WeakMap();\nexport var RxReplicationState = /*#__PURE__*/function () {\n  function RxReplicationState(\n  /**\n   * The identifier, used to flag revisions\n   * and to identify which documents state came from the remote.\n   */\n  replicationIdentifier, collection, deletedField, pull, push, live, retryTime, autoStart, toggleOnDocumentVisible) {\n    this.subs = [];\n    this.subjects = {\n      received: new Subject(),\n      // all documents that are received from the endpoint\n      sent: new Subject(),\n      // all documents that are send to the endpoint\n      error: new Subject(),\n      // all errors that are received from the endpoint, emits new Error() objects\n      canceled: new BehaviorSubject(false),\n      // true when the replication was canceled\n      active: new BehaviorSubject(false) // true when something is running, false when not\n    };\n    this.received$ = this.subjects.received.asObservable();\n    this.sent$ = this.subjects.sent.asObservable();\n    this.error$ = this.subjects.error.asObservable();\n    this.canceled$ = this.subjects.canceled.asObservable();\n    this.active$ = this.subjects.active.asObservable();\n    this.wasStarted = false;\n    this.onCancel = [];\n    this.callOnStart = undefined;\n    this.remoteEvents$ = new Subject();\n    this.replicationIdentifier = replicationIdentifier;\n    this.collection = collection;\n    this.deletedField = deletedField;\n    this.pull = pull;\n    this.push = push;\n    this.live = live;\n    this.retryTime = retryTime;\n    this.autoStart = autoStart;\n    this.toggleOnDocumentVisible = toggleOnDocumentVisible;\n    this.metaInfoPromise = (async () => {\n      var metaInstanceCollectionName = 'rx-replication-meta-' + (await collection.database.hashFunction([this.collection.name, this.replicationIdentifier].join('-')));\n      var metaInstanceSchema = getRxReplicationMetaInstanceSchema(this.collection.schema.jsonSchema, hasEncryption(this.collection.schema.jsonSchema));\n      return {\n        collectionName: metaInstanceCollectionName,\n        schema: metaInstanceSchema\n      };\n    })();\n    var replicationStates = getFromMapOrCreate(REPLICATION_STATE_BY_COLLECTION, collection, () => []);\n    replicationStates.push(this);\n\n    // stop the replication when the collection gets closed\n    this.collection.onClose.push(() => this.cancel());\n\n    // create getters for the observables\n    Object.keys(this.subjects).forEach(key => {\n      Object.defineProperty(this, key + '$', {\n        get: function () {\n          return this.subjects[key].asObservable();\n        }\n      });\n    });\n    var startPromise = new Promise(res => {\n      this.callOnStart = res;\n    });\n    this.startPromise = startPromise;\n  }\n  var _proto = RxReplicationState.prototype;\n  _proto.start = async function start() {\n    if (this.isStopped()) {\n      return;\n    }\n    if (this.internalReplicationState) {\n      this.internalReplicationState.events.paused.next(false);\n    }\n\n    /**\n     * If started after a pause,\n     * just re-sync once and continue.\n     */\n    if (this.wasStarted) {\n      this.reSync();\n      return;\n    }\n    this.wasStarted = true;\n    if (!this.toggleOnDocumentVisible) {\n      preventHibernateBrowserTab(this);\n    }\n\n    // fill in defaults for pull & push\n    var pullModifier = this.pull && this.pull.modifier ? this.pull.modifier : DEFAULT_MODIFIER;\n    var pushModifier = this.push && this.push.modifier ? this.push.modifier : DEFAULT_MODIFIER;\n    var database = this.collection.database;\n    var metaInfo = await this.metaInfoPromise;\n    var [metaInstance] = await Promise.all([this.collection.database.storage.createStorageInstance({\n      databaseName: database.name,\n      collectionName: metaInfo.collectionName,\n      databaseInstanceToken: database.token,\n      multiInstance: database.multiInstance,\n      options: {},\n      schema: metaInfo.schema,\n      password: database.password,\n      devMode: overwritable.isDevMode()\n    }), addConnectedStorageToCollection(this.collection, metaInfo.collectionName, metaInfo.schema)]);\n    this.metaInstance = metaInstance;\n    this.internalReplicationState = replicateRxStorageInstance({\n      pushBatchSize: this.push && this.push.batchSize ? this.push.batchSize : 100,\n      pullBatchSize: this.pull && this.pull.batchSize ? this.pull.batchSize : 100,\n      initialCheckpoint: {\n        upstream: this.push ? this.push.initialCheckpoint : undefined,\n        downstream: this.pull ? this.pull.initialCheckpoint : undefined\n      },\n      forkInstance: this.collection.storageInstance,\n      metaInstance: this.metaInstance,\n      hashFunction: database.hashFunction,\n      identifier: 'rxdbreplication' + this.replicationIdentifier,\n      conflictHandler: this.collection.conflictHandler,\n      replicationHandler: {\n        masterChangeStream$: this.remoteEvents$.asObservable().pipe(filter(_v => !!this.pull), mergeMap(async ev => {\n          if (ev === 'RESYNC') {\n            return ev;\n          }\n          var useEv = flatClone(ev);\n          useEv.documents = handlePulledDocuments(this.collection, this.deletedField, useEv.documents);\n          useEv.documents = await Promise.all(useEv.documents.map(d => pullModifier(d)));\n          return useEv;\n        })),\n        masterChangesSince: async (checkpoint, batchSize) => {\n          if (!this.pull) {\n            return {\n              checkpoint: null,\n              documents: []\n            };\n          }\n          /**\n           * Retries must be done here in the replication primitives plugin,\n           * because the replication protocol itself has no\n           * error handling.\n           */\n          var done = false;\n          var result = {};\n          while (!done && !this.isStoppedOrPaused()) {\n            try {\n              result = await this.pull.handler(checkpoint, batchSize);\n              done = true;\n            } catch (err) {\n              var emitError = newRxError('RC_PULL', {\n                checkpoint,\n                errors: toArray(err).map(er => errorToPlainJson(er)),\n                direction: 'pull'\n              });\n              this.subjects.error.next(emitError);\n              await awaitRetry(this.collection, ensureNotFalsy(this.retryTime));\n            }\n          }\n          if (this.isStoppedOrPaused()) {\n            return {\n              checkpoint: null,\n              documents: []\n            };\n          }\n          var useResult = flatClone(result);\n          useResult.documents = handlePulledDocuments(this.collection, this.deletedField, useResult.documents);\n          useResult.documents = await Promise.all(useResult.documents.map(d => pullModifier(d)));\n          return useResult;\n        },\n        masterWrite: async rows => {\n          if (!this.push) {\n            return [];\n          }\n          var done = false;\n          await runAsyncPluginHooks('preReplicationMasterWrite', {\n            rows,\n            collection: this.collection\n          });\n          var useRowsOrNull = await Promise.all(rows.map(async row => {\n            row.newDocumentState = await pushModifier(row.newDocumentState);\n            if (row.newDocumentState === null) {\n              return null;\n            }\n            if (row.assumedMasterState) {\n              row.assumedMasterState = await pushModifier(row.assumedMasterState);\n            }\n            if (this.deletedField !== '_deleted') {\n              row.newDocumentState = swapDefaultDeletedTodeletedField(this.deletedField, row.newDocumentState);\n              if (row.assumedMasterState) {\n                row.assumedMasterState = swapDefaultDeletedTodeletedField(this.deletedField, row.assumedMasterState);\n              }\n            }\n            return row;\n          }));\n          var useRows = useRowsOrNull.filter(arrayFilterNotEmpty);\n          var result = null;\n\n          // In case all the rows have been filtered and nothing has to be sent\n          if (useRows.length === 0) {\n            done = true;\n            result = [];\n          }\n          while (!done && !this.isStoppedOrPaused()) {\n            try {\n              result = await this.push.handler(useRows);\n              /**\n               * It is a common problem that people have wrongly behaving backend\n               * that do not return an array with the conflicts on push requests.\n               * So we run this check here to make it easier to debug.\n               * @link https://github.com/pubkey/rxdb/issues/4103\n               */\n              if (!Array.isArray(result)) {\n                throw newRxError('RC_PUSH_NO_AR', {\n                  pushRows: rows,\n                  direction: 'push',\n                  args: {\n                    result\n                  }\n                });\n              }\n              done = true;\n            } catch (err) {\n              var emitError = err.rxdb ? err : newRxError('RC_PUSH', {\n                pushRows: rows,\n                errors: toArray(err).map(er => errorToPlainJson(er)),\n                direction: 'push'\n              });\n              this.subjects.error.next(emitError);\n              await awaitRetry(this.collection, ensureNotFalsy(this.retryTime));\n            }\n          }\n          if (this.isStoppedOrPaused()) {\n            return [];\n          }\n          await runAsyncPluginHooks('preReplicationMasterWriteDocumentsHandle', {\n            result,\n            collection: this.collection\n          });\n          var conflicts = handlePulledDocuments(this.collection, this.deletedField, ensureNotFalsy(result));\n          return conflicts;\n        }\n      }\n    });\n    this.subs.push(this.internalReplicationState.events.error.subscribe(err => {\n      this.subjects.error.next(err);\n    }), this.internalReplicationState.events.processed.down.subscribe(row => this.subjects.received.next(row.document)), this.internalReplicationState.events.processed.up.subscribe(writeToMasterRow => {\n      this.subjects.sent.next(writeToMasterRow.newDocumentState);\n    }), combineLatest([this.internalReplicationState.events.active.down, this.internalReplicationState.events.active.up]).subscribe(([down, up]) => {\n      var isActive = down || up;\n      this.subjects.active.next(isActive);\n    }));\n    if (this.pull && this.pull.stream$ && this.live) {\n      this.subs.push(this.pull.stream$.subscribe({\n        next: ev => {\n          if (!this.isStoppedOrPaused()) {\n            this.remoteEvents$.next(ev);\n          }\n        },\n        error: err => {\n          this.subjects.error.next(err);\n        }\n      }));\n    }\n\n    /**\n     * Non-live replications run once\n     * and then automatically get canceled.\n     */\n    if (!this.live) {\n      await awaitRxStorageReplicationFirstInSync(this.internalReplicationState);\n      await awaitRxStorageReplicationInSync(this.internalReplicationState);\n      await this.cancel();\n    }\n    this.callOnStart();\n  };\n  _proto.pause = function pause() {\n    ensureNotFalsy(this.internalReplicationState).events.paused.next(true);\n  };\n  _proto.isPaused = function isPaused() {\n    return this.internalReplicationState ? this.internalReplicationState.events.paused.getValue() : false;\n  };\n  _proto.isStopped = function isStopped() {\n    if (this.subjects.canceled.getValue()) {\n      return true;\n    }\n    return false;\n  };\n  _proto.isStoppedOrPaused = function isStoppedOrPaused() {\n    return this.isPaused() || this.isStopped();\n  };\n  _proto.awaitInitialReplication = async function awaitInitialReplication() {\n    await this.startPromise;\n    return awaitRxStorageReplicationFirstInSync(ensureNotFalsy(this.internalReplicationState));\n  }\n\n  /**\n   * Returns a promise that resolves when:\n   * - All local data is replicated with the remote\n   * - No replication cycle is running or in retry-state\n   *\n   * WARNING: USing this function directly in a multi-tab browser application\n   * is dangerous because only the leading instance will ever be replicated,\n   * so this promise will not resolve in the other tabs.\n   * For multi-tab support you should set and observe a flag in a local document.\n   */;\n  _proto.awaitInSync = async function awaitInSync() {\n    await this.startPromise;\n    await awaitRxStorageReplicationFirstInSync(ensureNotFalsy(this.internalReplicationState));\n\n    /**\n     * To reduce the amount of re-renders and make testing\n     * and to make the whole behavior more predictable,\n     * we await these things multiple times.\n     * For example the state might be in sync already and at the\n     * exact same time a pull.stream$ event comes in and we want to catch\n     * that in the same call to awaitInSync() instead of resolving\n     * while actually the state is not in sync.\n     */\n    var t = 2;\n    while (t > 0) {\n      t--;\n\n      /**\n       * Often awaitInSync() is called directly after a document write,\n       * like in the unit tests.\n       * So we first have to await the idleness to ensure that all RxChangeEvents\n       * are processed already.\n       */\n      await this.collection.database.requestIdlePromise();\n      await awaitRxStorageReplicationInSync(ensureNotFalsy(this.internalReplicationState));\n    }\n    return true;\n  };\n  _proto.reSync = function reSync() {\n    this.remoteEvents$.next('RESYNC');\n  };\n  _proto.emitEvent = function emitEvent(ev) {\n    this.remoteEvents$.next(ev);\n  };\n  _proto.cancel = async function cancel() {\n    if (this.isStopped()) {\n      return PROMISE_RESOLVE_FALSE;\n    }\n    var promises = this.onCancel.map(fn => toPromise(fn()));\n    if (this.internalReplicationState) {\n      await cancelRxStorageReplication(this.internalReplicationState);\n    }\n    if (this.metaInstance) {\n      promises.push(ensureNotFalsy(this.internalReplicationState).checkpointQueue.then(() => ensureNotFalsy(this.metaInstance).close()));\n    }\n    this.subs.forEach(sub => sub.unsubscribe());\n    this.subjects.canceled.next(true);\n    this.subjects.active.complete();\n    this.subjects.canceled.complete();\n    this.subjects.error.complete();\n    this.subjects.received.complete();\n    this.subjects.sent.complete();\n    return Promise.all(promises);\n  };\n  _proto.remove = async function remove() {\n    await ensureNotFalsy(this.metaInstance).remove();\n    var metaInfo = await this.metaInfoPromise;\n    await this.cancel();\n    await removeConnectedStorageFromCollection(this.collection, metaInfo.collectionName, metaInfo.schema);\n  };\n  return RxReplicationState;\n}();\nexport function replicateRxCollection({\n  replicationIdentifier,\n  collection,\n  deletedField = '_deleted',\n  pull,\n  push,\n  live = true,\n  retryTime = 1000 * 5,\n  waitForLeadership = true,\n  autoStart = true,\n  toggleOnDocumentVisible = false\n}) {\n  addRxPlugin(RxDBLeaderElectionPlugin);\n\n  /**\n   * It is a common error to forget to add these config\n   * objects. So we check here because it makes no sense\n   * to start a replication with neither push nor pull.\n   */\n  if (!pull && !push) {\n    throw newRxError('UT3', {\n      collection: collection.name,\n      args: {\n        replicationIdentifier\n      }\n    });\n  }\n  var replicationState = new RxReplicationState(replicationIdentifier, collection, deletedField, pull, push, live, retryTime, autoStart, toggleOnDocumentVisible);\n  if (toggleOnDocumentVisible && typeof document !== 'undefined' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string') {\n    var handler = () => {\n      if (replicationState.isStopped()) {\n        return;\n      }\n      var isVisible = document.visibilityState;\n      if (isVisible) {\n        replicationState.start();\n      } else {\n        /**\n         * Only pause if not the current leader.\n         * If no tab is visible, the elected leader should still continue\n         * the replication.\n         */\n        if (!collection.database.isLeader()) {\n          replicationState.pause();\n        }\n      }\n    };\n    document.addEventListener('visibilitychange', handler);\n    replicationState.onCancel.push(() => document.removeEventListener('visibilitychange', handler));\n  }\n  startReplicationOnLeaderShip(waitForLeadership, replicationState);\n  return replicationState;\n}\nexport function startReplicationOnLeaderShip(waitForLeadership, replicationState) {\n  /**\n   * Always await this Promise to ensure that the current instance\n   * is leader when waitForLeadership=true\n   */\n  var mustWaitForLeadership = waitForLeadership && replicationState.collection.database.multiInstance;\n  var waitTillRun = mustWaitForLeadership ? replicationState.collection.database.waitForLeadership() : PROMISE_RESOLVE_TRUE;\n  return waitTillRun.then(() => {\n    if (replicationState.isStopped()) {\n      return;\n    }\n    if (replicationState.autoStart) {\n      replicationState.start();\n    }\n  });\n}\n//# sourceMappingURL=index.js.map","import { flatClone } from \"../../plugins/utils/index.js\";\nimport { getComposedPrimaryKeyOfDocumentData } from \"../../rx-schema-helper.js\";\n// does nothing\nexport var DEFAULT_MODIFIER = d => Promise.resolve(d);\nexport function swapDefaultDeletedTodeletedField(deletedField, doc) {\n  if (deletedField === '_deleted') {\n    return doc;\n  } else {\n    doc = flatClone(doc);\n    var isDeleted = !!doc._deleted;\n    doc[deletedField] = isDeleted;\n    delete doc._deleted;\n    return doc;\n  }\n}\n\n/**\n * Must be run over all plain document data\n * that was pulled from the remote.\n * Used to fill up fields or modify the deleted field etc.\n */\nexport function handlePulledDocuments(collection, deletedField, docs) {\n  return docs.map(doc => {\n    var useDoc = flatClone(doc);\n\n    /**\n     * Swap out the deleted field\n     */\n    if (deletedField !== '_deleted') {\n      var isDeleted = !!useDoc[deletedField];\n      useDoc._deleted = isDeleted;\n      delete useDoc[deletedField];\n    } else {\n      // ensure we have a boolean.\n      useDoc._deleted = !!useDoc._deleted;\n    }\n\n    /**\n     * Fill up composed primary\n     */\n    var primaryPath = collection.schema.primaryPath;\n    useDoc[primaryPath] = getComposedPrimaryKeyOfDocumentData(collection.schema.jsonSchema, useDoc);\n    return useDoc;\n  });\n}\n\n/**\n * Like normal promiseWait()\n * but will skip the wait time if the online-state changes.\n */\nexport function awaitRetry(collection, retryTime) {\n  if (typeof window === 'undefined' || typeof window !== 'object' || typeof window.addEventListener === 'undefined' || navigator.onLine) {\n    return collection.promiseWait(retryTime);\n  }\n  var listener;\n  var onlineAgain = new Promise(res => {\n    listener = () => {\n      window.removeEventListener('online', listener);\n      res();\n    };\n    window.addEventListener('online', listener);\n  });\n  return Promise.race([onlineAgain, collection.promiseWait(retryTime)]).then(() => {\n    window.removeEventListener('online', listener);\n  });\n}\n\n/**\n * When a replication is running and the leading tab get hibernated\n * by the browser, the replication will be stuck.\n * To prevent this, we fire a mouseeven each X seconds while the replication is not canceled.\n * \n * If you find a better way to prevent hibernation, please make a pull request.\n */\nexport function preventHibernateBrowserTab(replicationState) {\n  function simulateActivity() {\n    if (typeof document === 'undefined' || typeof document.dispatchEvent !== 'function') {\n      return;\n    }\n    var event = new Event('mousemove');\n    document.dispatchEvent(event);\n  }\n  var intervalId = setInterval(simulateActivity, 20 * 1000); // Simulate activity every 20 seconds\n  replicationState.onCancel.push(() => clearInterval(intervalId));\n}\n//# sourceMappingURL=replication-helper.js.map","import { Dexie } from 'dexie';\nimport { flatClone, getFromMapOrCreate, getProperty, setProperty, toArray, uniqueArray } from \"../utils/index.js\";\nimport { getPrimaryFieldOfPrimaryKey, getSchemaByObjectPath } from \"../../rx-schema-helper.js\";\nexport var DEXIE_DOCS_TABLE_NAME = 'docs';\nexport var DEXIE_CHANGES_TABLE_NAME = 'changes';\nexport var DEXIE_ATTACHMENTS_TABLE_NAME = 'attachments';\nexport var RX_STORAGE_NAME_DEXIE = 'dexie';\nvar DEXIE_STATE_DB_BY_NAME = new Map();\nvar REF_COUNT_PER_DEXIE_DB = new Map();\nexport function getDexieDbWithTables(databaseName, collectionName, settings, schema) {\n  var dexieDbName = 'rxdb-dexie-' + databaseName + '--' + schema.version + '--' + collectionName;\n  var state = getFromMapOrCreate(DEXIE_STATE_DB_BY_NAME, dexieDbName, () => {\n    var value = (async () => {\n      /**\n       * IndexedDB was not designed for dynamically adding tables on the fly,\n       * so we create one dexie database per RxDB storage instance.\n       * @link https://github.com/dexie/Dexie.js/issues/684#issuecomment-373224696\n       */\n      var useSettings = flatClone(settings);\n      useSettings.autoOpen = false;\n      var dexieDb = new Dexie(dexieDbName, useSettings);\n      if (settings.onCreate) {\n        await settings.onCreate(dexieDb, dexieDbName);\n      }\n      var dexieStoresSettings = {\n        [DEXIE_DOCS_TABLE_NAME]: getDexieStoreSchema(schema),\n        [DEXIE_CHANGES_TABLE_NAME]: '++sequence, id',\n        [DEXIE_ATTACHMENTS_TABLE_NAME]: 'id'\n      };\n      dexieDb.version(1).stores(dexieStoresSettings);\n      await dexieDb.open();\n      return {\n        dexieDb,\n        dexieTable: dexieDb[DEXIE_DOCS_TABLE_NAME],\n        dexieAttachmentsTable: dexieDb[DEXIE_ATTACHMENTS_TABLE_NAME],\n        booleanIndexes: getBooleanIndexes(schema)\n      };\n    })();\n    DEXIE_STATE_DB_BY_NAME.set(dexieDbName, state);\n    REF_COUNT_PER_DEXIE_DB.set(state, 0);\n    return value;\n  });\n  return state;\n}\nexport async function closeDexieDb(statePromise) {\n  var state = await statePromise;\n  var prevCount = REF_COUNT_PER_DEXIE_DB.get(statePromise);\n  var newCount = prevCount - 1;\n  if (newCount === 0) {\n    state.dexieDb.close();\n    REF_COUNT_PER_DEXIE_DB.delete(statePromise);\n  } else {\n    REF_COUNT_PER_DEXIE_DB.set(statePromise, newCount);\n  }\n}\n\n/**\n * It is not possible to set non-javascript-variable-syntax\n * keys as IndexedDB indexes. So we have to substitute the pipe-char\n * which comes from the key-compression plugin.\n */\nexport var DEXIE_PIPE_SUBSTITUTE = '__';\nexport function dexieReplaceIfStartsWithPipe(str) {\n  var split = str.split('.');\n  if (split.length > 1) {\n    return split.map(part => dexieReplaceIfStartsWithPipe(part)).join('.');\n  }\n  if (str.startsWith('|')) {\n    var withoutFirst = str.substring(1);\n    return DEXIE_PIPE_SUBSTITUTE + withoutFirst;\n  } else {\n    return str;\n  }\n}\nexport function dexieReplaceIfStartsWithPipeRevert(str) {\n  var split = str.split('.');\n  if (split.length > 1) {\n    return split.map(part => dexieReplaceIfStartsWithPipeRevert(part)).join('.');\n  }\n  if (str.startsWith(DEXIE_PIPE_SUBSTITUTE)) {\n    var withoutFirst = str.substring(DEXIE_PIPE_SUBSTITUTE.length);\n    return '|' + withoutFirst;\n  } else {\n    return str;\n  }\n}\n\n/**\n * IndexedDB does not support boolean indexing.\n * So we have to replace true/false with '1'/'0'\n * @param d \n */\nexport function fromStorageToDexie(booleanIndexes, inputDoc) {\n  if (!inputDoc) {\n    return inputDoc;\n  }\n  var d = flatClone(inputDoc);\n  d = fromStorageToDexieField(d);\n  booleanIndexes.forEach(idx => {\n    var val = getProperty(inputDoc, idx);\n    var newVal = val ? '1' : '0';\n    var useIndex = dexieReplaceIfStartsWithPipe(idx);\n    setProperty(d, useIndex, newVal);\n  });\n  return d;\n}\nexport function fromDexieToStorage(booleanIndexes, d) {\n  if (!d) {\n    return d;\n  }\n  d = flatClone(d);\n  d = fromDexieToStorageField(d);\n  booleanIndexes.forEach(idx => {\n    var val = getProperty(d, idx);\n    var newVal = val === '1' ? true : false;\n    setProperty(d, idx, newVal);\n  });\n  return d;\n}\n\n/**\n * @recursive\n */\nexport function fromStorageToDexieField(documentData) {\n  if (!documentData || typeof documentData === 'string' || typeof documentData === 'number' || typeof documentData === 'boolean') {\n    return documentData;\n  } else if (Array.isArray(documentData)) {\n    return documentData.map(row => fromStorageToDexieField(row));\n  } else if (typeof documentData === 'object') {\n    var ret = {};\n    Object.entries(documentData).forEach(([key, value]) => {\n      if (typeof value === 'object') {\n        value = fromStorageToDexieField(value);\n      }\n      ret[dexieReplaceIfStartsWithPipe(key)] = value;\n    });\n    return ret;\n  }\n}\nexport function fromDexieToStorageField(documentData) {\n  if (!documentData || typeof documentData === 'string' || typeof documentData === 'number' || typeof documentData === 'boolean') {\n    return documentData;\n  } else if (Array.isArray(documentData)) {\n    return documentData.map(row => fromDexieToStorageField(row));\n  } else if (typeof documentData === 'object') {\n    var ret = {};\n    Object.entries(documentData).forEach(([key, value]) => {\n      if (typeof value === 'object' || Array.isArray(documentData)) {\n        value = fromDexieToStorageField(value);\n      }\n      ret[dexieReplaceIfStartsWithPipeRevert(key)] = value;\n    });\n    return ret;\n  }\n}\n\n/**\n * Creates a string that can be used to create the dexie store.\n * @link https://dexie.org/docs/API-Reference#quick-reference\n */\nexport function getDexieStoreSchema(rxJsonSchema) {\n  var parts = [];\n\n  /**\n   * First part must be the primary key\n   * @link https://github.com/dexie/Dexie.js/issues/1307#issuecomment-846590912\n   */\n  var primaryKey = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);\n  parts.push([primaryKey]);\n  parts.push(['_deleted', primaryKey]);\n\n  // add other indexes\n  if (rxJsonSchema.indexes) {\n    rxJsonSchema.indexes.forEach(index => {\n      var arIndex = toArray(index);\n      parts.push(arIndex);\n    });\n  }\n\n  // we also need the _meta.lwt+primaryKey index for the getChangedDocumentsSince() method.\n  parts.push(['_meta.lwt', primaryKey]);\n\n  // and this one for the cleanup()\n  parts.push(['_meta.lwt']);\n\n  /**\n   * It is not possible to set non-javascript-variable-syntax\n   * keys as IndexedDB indexes. So we have to substitute the pipe-char\n   * which comes from the key-compression plugin.\n   */\n  parts = parts.map(part => {\n    return part.map(str => dexieReplaceIfStartsWithPipe(str));\n  });\n  var dexieSchemaRows = parts.map(part => {\n    if (part.length === 1) {\n      return part[0];\n    } else {\n      return '[' + part.join('+') + ']';\n    }\n  });\n  dexieSchemaRows = dexieSchemaRows.filter((elem, pos, arr) => arr.indexOf(elem) === pos); // unique;\n\n  var dexieSchema = dexieSchemaRows.join(', ');\n  return dexieSchema;\n}\n\n/**\n * Returns all documents in the database.\n * Non-deleted plus deleted ones.\n */\nexport async function getDocsInDb(internals, docIds) {\n  var state = await internals;\n  var docsInDb = await state.dexieTable.bulkGet(docIds);\n  return docsInDb.map(d => fromDexieToStorage(state.booleanIndexes, d));\n}\nexport function attachmentObjectId(documentId, attachmentId) {\n  return documentId + '||' + attachmentId;\n}\nexport function getBooleanIndexes(schema) {\n  var checkedFields = new Set();\n  var ret = [];\n  if (!schema.indexes) {\n    return ret;\n  }\n  schema.indexes.forEach(index => {\n    var fields = toArray(index);\n    fields.forEach(field => {\n      if (checkedFields.has(field)) {\n        return;\n      }\n      checkedFields.add(field);\n      var schemaObj = getSchemaByObjectPath(schema, field);\n      if (schemaObj.type === 'boolean') {\n        ret.push(field);\n      }\n    });\n  });\n  ret.push('_deleted');\n  return uniqueArray(ret);\n}\n//# sourceMappingURL=dexie-helper.js.map","import { INDEX_MAX, INDEX_MIN } from \"../../query-planner.js\";\nimport { getQueryMatcher, getSortComparator } from \"../../rx-query-helper.js\";\nimport { dexieReplaceIfStartsWithPipe, DEXIE_DOCS_TABLE_NAME, fromDexieToStorage } from \"./dexie-helper.js\";\nexport function mapKeyForKeyRange(k) {\n  if (k === INDEX_MIN) {\n    return -Infinity;\n  } else {\n    return k;\n  }\n}\nfunction rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, value) {\n  if (booleanIndexes.includes(fieldName)) {\n    var newValue = value === INDEX_MAX || value === true ? '1' : '0';\n    return newValue;\n  } else {\n    return value;\n  }\n}\nexport function getKeyRangeByQueryPlan(booleanIndexes, queryPlan, IDBKeyRange) {\n  if (!IDBKeyRange) {\n    if (typeof window === 'undefined') {\n      throw new Error('IDBKeyRange missing');\n    } else {\n      IDBKeyRange = window.IDBKeyRange;\n    }\n  }\n  var startKeys = queryPlan.startKeys.map((v, i) => {\n    var fieldName = queryPlan.index[i];\n    return rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, v);\n  }).map(mapKeyForKeyRange);\n  var endKeys = queryPlan.endKeys.map((v, i) => {\n    var fieldName = queryPlan.index[i];\n    return rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, v);\n  }).map(mapKeyForKeyRange);\n  var keyRange = IDBKeyRange.bound(startKeys, endKeys, !queryPlan.inclusiveStart, !queryPlan.inclusiveEnd);\n  return keyRange;\n}\n\n/**\n * Runs mango queries over the Dexie.js database.\n */\nexport async function dexieQuery(instance, preparedQuery) {\n  var state = await instance.internals;\n  var query = preparedQuery.query;\n  var skip = query.skip ? query.skip : 0;\n  var limit = query.limit ? query.limit : Infinity;\n  var skipPlusLimit = skip + limit;\n  var queryPlan = preparedQuery.queryPlan;\n  var queryMatcher = false;\n  if (!queryPlan.selectorSatisfiedByIndex) {\n    queryMatcher = getQueryMatcher(instance.schema, preparedQuery.query);\n  }\n  var keyRange = getKeyRangeByQueryPlan(state.booleanIndexes, queryPlan, state.dexieDb._options.IDBKeyRange);\n  var queryPlanFields = queryPlan.index;\n  var rows = [];\n  await state.dexieDb.transaction('r', state.dexieTable, async dexieTx => {\n    /**\n     * Here we use the native IndexedDB transaction\n     * to get the cursor.\n     * Maybe we should not leave Dexie.js API and find\n     * a way to create the cursor with Dexie.js.\n     */\n    var tx = dexieTx.idbtrans;\n\n    // const nativeIndexedDB = state.dexieDb.backendDB();\n    // const trans = nativeIndexedDB.transaction([DEXIE_DOCS_TABLE_NAME], 'readonly');\n\n    var store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);\n    var index;\n    var indexName;\n    indexName = '[' + queryPlanFields.map(field => dexieReplaceIfStartsWithPipe(field)).join('+') + ']';\n    index = store.index(indexName);\n    var cursorReq = index.openCursor(keyRange);\n    await new Promise(res => {\n      cursorReq.onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (cursor) {\n          // We have a record in cursor.value\n          var docData = fromDexieToStorage(state.booleanIndexes, cursor.value);\n          if (!queryMatcher || queryMatcher(docData)) {\n            rows.push(docData);\n          }\n\n          /**\n           * If we do not have to manually sort\n           * and have enough documents,\n           * we can abort iterating over the cursor\n           * because we already have every relevant document.\n           */\n          if (queryPlan.sortSatisfiedByIndex && rows.length === skipPlusLimit) {\n            res();\n          } else {\n            cursor.continue();\n          }\n        } else {\n          // Iteration complete\n          res();\n        }\n      };\n    });\n  });\n  if (!queryPlan.sortSatisfiedByIndex) {\n    var sortComparator = getSortComparator(instance.schema, preparedQuery.query);\n    rows = rows.sort(sortComparator);\n  }\n\n  // apply skip and limit boundaries.\n  rows = rows.slice(skip, skipPlusLimit);\n\n  /**\n   * Comment this in for debugging to check all fields in the database.\n   */\n  // const docsInDb = await state.dexieTable.filter(queryMatcher).toArray();\n  // let documents = docsInDb\n  //     .map(docData => stripDexieKey(docData))\n  //     .sort(sortComparator);\n  // if (preparedQuery.skip) {\n  //     documents = documents.slice(preparedQuery.skip);\n  // }\n  // if (preparedQuery.limit && documents.length > preparedQuery.limit) {\n  //     documents = documents.slice(0, preparedQuery.limit);\n  // }\n\n  return {\n    documents: rows\n  };\n}\nexport async function dexieCount(instance, preparedQuery) {\n  var state = await instance.internals;\n  var queryPlan = preparedQuery.queryPlan;\n  var queryPlanFields = queryPlan.index;\n  var keyRange = getKeyRangeByQueryPlan(state.booleanIndexes, queryPlan, state.dexieDb._options.IDBKeyRange);\n  var count = -1;\n  await state.dexieDb.transaction('r', state.dexieTable, async dexieTx => {\n    var tx = dexieTx.idbtrans;\n    var store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);\n    var index;\n    var indexName;\n    indexName = '[' + queryPlanFields.map(field => dexieReplaceIfStartsWithPipe(field)).join('+') + ']';\n    index = store.index(indexName);\n    var request = index.count(keyRange);\n    count = await new Promise((res, rej) => {\n      request.onsuccess = function () {\n        res(request.result);\n      };\n      request.onerror = err => rej(err);\n    });\n  });\n  return count;\n}\n//# sourceMappingURL=dexie-query.js.map","import { RX_STORAGE_NAME_DEXIE } from \"./dexie-helper.js\";\nimport { createDexieStorageInstance } from \"./rx-storage-instance-dexie.js\";\nimport { ensureRxStorageInstanceParamsAreCorrect } from \"../../rx-storage-helper.js\";\nimport { RXDB_VERSION } from \"../utils/utils-rxdb-version.js\";\nimport { newRxError } from \"../../rx-error.js\";\nexport var RxStorageDexie = /*#__PURE__*/function () {\n  function RxStorageDexie(settings) {\n    this.name = RX_STORAGE_NAME_DEXIE;\n    this.rxdbVersion = RXDB_VERSION;\n    this.settings = settings;\n  }\n  var _proto = RxStorageDexie.prototype;\n  _proto.createStorageInstance = function createStorageInstance(params) {\n    ensureRxStorageInstanceParamsAreCorrect(params);\n\n    /**\n     * Dexie does not support non-required indexes and must throw if that is used.\n     * @link https://github.com/pubkey/rxdb/pull/6643#issuecomment-2505310082\n     */\n    if (params.schema.indexes) {\n      var indexFields = params.schema.indexes.flat();\n      indexFields.filter(indexField => !indexField.includes('.')).forEach(indexField => {\n        if (!params.schema.required || !params.schema.required.includes(indexField)) {\n          throw newRxError('DXE1', {\n            field: indexField,\n            schema: params.schema\n          });\n        }\n      });\n    }\n    return createDexieStorageInstance(this, params, this.settings);\n  };\n  return RxStorageDexie;\n}();\nexport function getRxStorageDexie(settings = {}) {\n  var storage = new RxStorageDexie(settings);\n  return storage;\n}\n//# sourceMappingURL=rx-storage-dexie.js.map","import { Subject } from 'rxjs';\nimport { now, ensureNotFalsy, hasPremiumFlag } from \"../utils/index.js\";\nimport { attachmentObjectId, closeDexieDb, fromStorageToDexie, getDexieDbWithTables, getDocsInDb, RX_STORAGE_NAME_DEXIE } from \"./dexie-helper.js\";\nimport { dexieCount, dexieQuery } from \"./dexie-query.js\";\nimport { getPrimaryFieldOfPrimaryKey } from \"../../rx-schema-helper.js\";\nimport { categorizeBulkWriteRows, flatCloneDocWithMeta } from \"../../rx-storage-helper.js\";\nimport { addRxStorageMultiInstanceSupport } from \"../../rx-storage-multiinstance.js\";\nimport { newRxError } from \"../../rx-error.js\";\nvar instanceId = now();\nvar shownNonPremiumLog = false;\nexport var RxStorageInstanceDexie = /*#__PURE__*/function () {\n  function RxStorageInstanceDexie(storage, databaseName, collectionName, schema, internals, options, settings, devMode) {\n    this.changes$ = new Subject();\n    this.instanceId = instanceId++;\n    this.storage = storage;\n    this.databaseName = databaseName;\n    this.collectionName = collectionName;\n    this.schema = schema;\n    this.internals = internals;\n    this.options = options;\n    this.settings = settings;\n    this.devMode = devMode;\n    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n  }\n  var _proto = RxStorageInstanceDexie.prototype;\n  _proto.bulkWrite = async function bulkWrite(documentWrites, context) {\n    ensureNotClosed(this);\n    if (!shownNonPremiumLog && !(await hasPremiumFlag())) {\n      console.warn(['-------------- RxDB Open Core RxStorage -------------------------------', 'You are using the free Dexie.js based RxStorage implementation from RxDB https://rxdb.info/rx-storage-dexie.html?console=dexie ', 'While this is a great option, we want to let you know that there are faster storage solutions available in our premium plugins.', 'For professional users and production environments, we highly recommend considering these premium options to enhance performance and reliability.', ' https://rxdb.info/premium/?console=dexie ', 'If you already purchased premium access you can disable this log by calling the setPremiumFlag() function from rxdb-premium/plugins/shared.', '---------------------------------------------------------------------'].join('\\n'));\n      shownNonPremiumLog = true;\n    } else {\n      shownNonPremiumLog = true;\n    }\n\n    /**\n     * Check some assumptions to ensure RxDB\n     * does not call the storage with an invalid write.\n     */\n    documentWrites.forEach(row => {\n      // ensure revision is set\n      if (!row.document._rev || row.previous && !row.previous._rev) {\n        throw newRxError('SNH', {\n          args: {\n            row\n          }\n        });\n      }\n    });\n    var state = await this.internals;\n    var ret = {\n      error: []\n    };\n\n    /**\n     * Some storages might add any _meta fields\n     * internally. To ensure RxDB can work with that in the\n     * test suite, we add a random field here.\n     * To ensure \n     */\n    if (this.devMode) {\n      documentWrites = documentWrites.map(row => {\n        var doc = flatCloneDocWithMeta(row.document);\n        return {\n          previous: row.previous,\n          document: doc\n        };\n      });\n    }\n    var documentKeys = documentWrites.map(writeRow => writeRow.document[this.primaryPath]);\n    var categorized;\n    await state.dexieDb.transaction('rw', state.dexieTable, state.dexieAttachmentsTable, async () => {\n      var docsInDbMap = new Map();\n      var docsInDbWithInternals = await getDocsInDb(this.internals, documentKeys);\n      docsInDbWithInternals.forEach(docWithDexieInternals => {\n        var doc = docWithDexieInternals;\n        if (doc) {\n          docsInDbMap.set(doc[this.primaryPath], doc);\n        }\n        return doc;\n      });\n      categorized = categorizeBulkWriteRows(this, this.primaryPath, docsInDbMap, documentWrites, context);\n      ret.error = categorized.errors;\n\n      /**\n       * Batch up the database operations\n       * so we can later run them in bulk.\n       */\n      var bulkPutDocs = [];\n      categorized.bulkInsertDocs.forEach(row => {\n        bulkPutDocs.push(row.document);\n      });\n      categorized.bulkUpdateDocs.forEach(row => {\n        bulkPutDocs.push(row.document);\n      });\n      bulkPutDocs = bulkPutDocs.map(d => fromStorageToDexie(state.booleanIndexes, d));\n      if (bulkPutDocs.length > 0) {\n        await state.dexieTable.bulkPut(bulkPutDocs);\n      }\n\n      // handle attachments\n      var putAttachments = [];\n      categorized.attachmentsAdd.forEach(attachment => {\n        putAttachments.push({\n          id: attachmentObjectId(attachment.documentId, attachment.attachmentId),\n          data: attachment.attachmentData.data\n        });\n      });\n      categorized.attachmentsUpdate.forEach(attachment => {\n        putAttachments.push({\n          id: attachmentObjectId(attachment.documentId, attachment.attachmentId),\n          data: attachment.attachmentData.data\n        });\n      });\n      await state.dexieAttachmentsTable.bulkPut(putAttachments);\n      await state.dexieAttachmentsTable.bulkDelete(categorized.attachmentsRemove.map(attachment => attachmentObjectId(attachment.documentId, attachment.attachmentId)));\n    });\n    categorized = ensureNotFalsy(categorized);\n    if (categorized.eventBulk.events.length > 0) {\n      var lastState = ensureNotFalsy(categorized.newestRow).document;\n      categorized.eventBulk.checkpoint = {\n        id: lastState[this.primaryPath],\n        lwt: lastState._meta.lwt\n      };\n      this.changes$.next(categorized.eventBulk);\n    }\n    return ret;\n  };\n  _proto.findDocumentsById = async function findDocumentsById(ids, deleted) {\n    ensureNotClosed(this);\n    var state = await this.internals;\n    var ret = [];\n    await state.dexieDb.transaction('r', state.dexieTable, async () => {\n      var docsInDb = await getDocsInDb(this.internals, ids);\n      docsInDb.forEach(documentInDb => {\n        if (documentInDb && (!documentInDb._deleted || deleted)) {\n          ret.push(documentInDb);\n        }\n      });\n    });\n    return ret;\n  };\n  _proto.query = function query(preparedQuery) {\n    ensureNotClosed(this);\n    return dexieQuery(this, preparedQuery);\n  };\n  _proto.count = async function count(preparedQuery) {\n    if (preparedQuery.queryPlan.selectorSatisfiedByIndex) {\n      var result = await dexieCount(this, preparedQuery);\n      return {\n        count: result,\n        mode: 'fast'\n      };\n    } else {\n      var _result = await dexieQuery(this, preparedQuery);\n      return {\n        count: _result.documents.length,\n        mode: 'slow'\n      };\n    }\n  };\n  _proto.changeStream = function changeStream() {\n    ensureNotClosed(this);\n    return this.changes$.asObservable();\n  };\n  _proto.cleanup = async function cleanup(minimumDeletedTime) {\n    ensureNotClosed(this);\n    var state = await this.internals;\n    await state.dexieDb.transaction('rw', state.dexieTable, async () => {\n      var maxDeletionTime = now() - minimumDeletedTime;\n      var toRemove = await state.dexieTable.where('_meta.lwt').below(maxDeletionTime).toArray();\n      var removeIds = [];\n      toRemove.forEach(doc => {\n        if (doc._deleted === '1') {\n          removeIds.push(doc[this.primaryPath]);\n        }\n      });\n      await state.dexieTable.bulkDelete(removeIds);\n    });\n    return true;\n  };\n  _proto.getAttachmentData = async function getAttachmentData(documentId, attachmentId, _digest) {\n    ensureNotClosed(this);\n    var state = await this.internals;\n    var id = attachmentObjectId(documentId, attachmentId);\n    return await state.dexieDb.transaction('r', state.dexieAttachmentsTable, async () => {\n      var attachment = await state.dexieAttachmentsTable.get(id);\n      if (attachment) {\n        return attachment.data;\n      } else {\n        throw new Error('attachment missing documentId: ' + documentId + ' attachmentId: ' + attachmentId);\n      }\n    });\n  };\n  _proto.remove = async function remove() {\n    ensureNotClosed(this);\n    var state = await this.internals;\n    await state.dexieTable.clear();\n    return this.close();\n  };\n  _proto.close = function close() {\n    if (this.closed) {\n      return this.closed;\n    }\n    this.closed = (async () => {\n      this.changes$.complete();\n      await closeDexieDb(this.internals);\n    })();\n    return this.closed;\n  };\n  return RxStorageInstanceDexie;\n}();\nexport async function createDexieStorageInstance(storage, params, settings) {\n  var internals = getDexieDbWithTables(params.databaseName, params.collectionName, settings, params.schema);\n  var instance = new RxStorageInstanceDexie(storage, params.databaseName, params.collectionName, params.schema, internals, params.options, settings, params.devMode);\n  await addRxStorageMultiInstanceSupport(RX_STORAGE_NAME_DEXIE, params, instance);\n  return Promise.resolve(instance);\n}\nfunction ensureNotClosed(instance) {\n  if (instance.closed) {\n    throw new Error('RxStorageInstanceDexie is closed ' + instance.databaseName + '-' + instance.collectionName);\n  }\n}\n//# sourceMappingURL=rx-storage-instance-dexie.js.map","export function lastOfArray(ar) {\n  return ar[ar.length - 1];\n}\n\n/**\n * shuffle the given array\n */\nexport function shuffleArray(arr) {\n  return arr.slice(0).sort(() => Math.random() - 0.5);\n}\nexport function randomOfArray(arr) {\n  var randomElement = arr[Math.floor(Math.random() * arr.length)];\n  return randomElement;\n}\nexport function toArray(input) {\n  return Array.isArray(input) ? input.slice(0) : [input];\n}\n\n/**\n * Split array with items into smaller arrays with items\n * @link https://stackoverflow.com/a/7273794/3443137\n */\nexport function batchArray(array, batchSize) {\n  array = array.slice(0);\n  var ret = [];\n  while (array.length) {\n    var batch = array.splice(0, batchSize);\n    ret.push(batch);\n  }\n  return ret;\n}\n\n/**\n * @link https://stackoverflow.com/a/15996017\n */\nexport function removeOneFromArrayIfMatches(ar, condition) {\n  ar = ar.slice();\n  var i = ar.length;\n  var done = false;\n  while (i-- && !done) {\n    if (condition(ar[i])) {\n      done = true;\n      ar.splice(i, 1);\n    }\n  }\n  return ar;\n}\n\n/**\n * returns true if the supplied argument is either an Array<T> or a Readonly<Array<T>>\n */\nexport function isMaybeReadonlyArray(x) {\n  // While this looks strange, it's a workaround for an issue in TypeScript:\n  // https://github.com/microsoft/TypeScript/issues/17002\n  //\n  // The problem is that `Array.isArray` as a type guard returns `false` for a readonly array,\n  // but at runtime the object is an array and the runtime call to `Array.isArray` would return `true`.\n  // The type predicate here allows for both `Array<T>` and `Readonly<Array<T>>` to pass a type check while\n  // still performing runtime type inspection.\n  return Array.isArray(x);\n}\nexport function isOneItemOfArrayInOtherArray(ar1, ar2) {\n  for (var i = 0; i < ar1.length; i++) {\n    var el = ar1[i];\n    var has = ar2.includes(el);\n    if (has) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Use this in array.filter() to remove all empty slots\n * and have the correct typings afterwards.\n * @link https://stackoverflow.com/a/46700791/3443137\n */\nexport function arrayFilterNotEmpty(value) {\n  if (value === null || value === undefined) {\n    return false;\n  }\n  return true;\n}\nexport function countUntilNotMatching(ar, matchingFn) {\n  var count = 0;\n  var idx = -1;\n  for (var item of ar) {\n    idx = idx + 1;\n    var matching = matchingFn(item, idx);\n    if (matching) {\n      count = count + 1;\n    } else {\n      break;\n    }\n  }\n  return count;\n}\nexport async function asyncFilter(array, predicate) {\n  var filters = await Promise.all(array.map(predicate));\n  return array.filter((...[, index]) => filters[index]);\n}\n\n/**\n * @link https://stackoverflow.com/a/3762735\n */\nexport function sumNumberArray(array) {\n  var count = 0;\n  for (var i = array.length; i--;) {\n    count += array[i];\n  }\n  return count;\n}\nexport function maxOfNumbers(arr) {\n  return Math.max(...arr);\n}\n\n/**\n * Appends the given documents to the given array.\n * This will mutate the first given array.\n * Mostly used as faster alternative to Array.concat()\n * because .concat() is so slow.\n * @link https://www.measurethat.net/Benchmarks/Show/4223/0/array-concat-vs-spread-operator-vs-push#latest_results_block\n * \n * TODO it turns out that in mid 2024 v8 has optimized Array.concat()\n * so it might be faster to just use concat() again:\n * @link https://jsperf.app/qiqawa/10\n */\nexport function appendToArray(ar, add) {\n  /**\n   * Pre-increasing the array size has turned out\n   * to be way faster when big arrays must be handled.\n   * @link https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki\n   */\n  var addSize = add.length;\n  if (addSize === 0) {\n    return;\n  }\n  var baseSize = ar.length;\n  ar.length = baseSize + add.length;\n  for (var i = 0; i < addSize; ++i) {\n    ar[baseSize + i] = add[i];\n  }\n}\n\n/**\n * @link https://gist.github.com/telekosmos/3b62a31a5c43f40849bb\n */\nexport function uniqueArray(arrArg) {\n  return arrArg.filter(function (elem, pos, arr) {\n    return arr.indexOf(elem) === pos;\n  });\n}\nexport function sortByObjectNumberProperty(property) {\n  return (a, b) => {\n    return b[property] - a[property];\n  };\n}\n//# sourceMappingURL=utils-array.js.map","import { flatClone } from \"./utils-object.js\";\n/**\n * We use 1 as minimum so that the value is never falsy.\n * This const is used in several places because querying\n * with a value lower then the minimum could give false results.\n */\nexport var RX_META_LWT_MINIMUM = 1;\nexport function getDefaultRxDocumentMeta() {\n  return {\n    /**\n     * Set this to 1 to not waste performance\n     * while calling new Date()..\n     * The storage wrappers will anyway update\n     * the lastWrite time while calling transformDocumentDataFromRxDBToRxStorage()\n     */\n    lwt: RX_META_LWT_MINIMUM\n  };\n}\n\n/**\n * Returns a revision that is not valid.\n * Use this to have correct typings\n * while the storage wrapper anyway will overwrite the revision.\n */\nexport function getDefaultRevision() {\n  /**\n   * Use a non-valid revision format,\n   * to ensure that the RxStorage will throw\n   * when the revision is not replaced downstream.\n   */\n  return '';\n}\nexport function stripMetaDataFromDocument(docData) {\n  return Object.assign({}, docData, {\n    _meta: undefined,\n    _deleted: undefined,\n    _rev: undefined\n  });\n}\n\n/**\n * Faster way to check the equality of document lists\n * compared to doing a deep-equal.\n * Here we only check the ids and revisions.\n */\nexport function areRxDocumentArraysEqual(primaryPath, ar1, ar2) {\n  if (ar1.length !== ar2.length) {\n    return false;\n  }\n  var i = 0;\n  var len = ar1.length;\n  while (i < len) {\n    var row1 = ar1[i];\n    var row2 = ar2[i];\n    i++;\n    if (row1._rev !== row2._rev || row1[primaryPath] !== row2[primaryPath]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function getSortDocumentsByLastWriteTimeComparator(primaryPath) {\n  return (a, b) => {\n    if (a._meta.lwt === b._meta.lwt) {\n      if (b[primaryPath] < a[primaryPath]) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else {\n      return a._meta.lwt - b._meta.lwt;\n    }\n  };\n}\nexport function sortDocumentsByLastWriteTime(primaryPath, docs) {\n  return docs.sort(getSortDocumentsByLastWriteTimeComparator(primaryPath));\n}\nexport function toWithDeleted(docData) {\n  docData = flatClone(docData);\n  docData._deleted = !!docData._deleted;\n  return Object.assign(docData, {\n    _attachments: undefined,\n    _meta: undefined,\n    _rev: undefined\n  });\n}\n//# sourceMappingURL=utils-document.js.map","import { ucfirst } from \"./utils-string.js\";\n\n/**\n * Returns an error that indicates that a plugin is missing\n * We do not throw a RxError because this should not be handled\n * programmatically but by using the correct import\n */\nexport function pluginMissing(pluginKey) {\n  var keyParts = pluginKey.split('-');\n  var pluginName = 'RxDB';\n  keyParts.forEach(part => {\n    pluginName += ucfirst(part);\n  });\n  pluginName += 'Plugin';\n  return new Error(\"You are using a function which must be overwritten by a plugin.\\n        You should either prevent the usage of this function or add the plugin via:\\n            import { \" + pluginName + \" } from 'rxdb/plugins/\" + pluginKey + \"';\\n            addRxPlugin(\" + pluginName + \");\\n        \");\n}\nexport function errorToPlainJson(err) {\n  var ret = {\n    name: err.name,\n    message: err.message,\n    rxdb: err.rxdb,\n    parameters: err.parameters,\n    extensions: err.extensions,\n    code: err.code,\n    url: err.url,\n    /**\n     * stack must be last to make it easier to read the json in a console.\n     * Also we ensure that each linebreak is spaced so that the chrome devtools\n     * shows urls to the source code that can be clicked to inspect\n     * the correct place in the code.\n     */\n    stack: !err.stack ? undefined : err.stack.replace(/\\n/g, ' \\n ')\n  };\n  return ret;\n}\n//# sourceMappingURL=utils-error.js.map","/**\n * Can be used by some plugins to have a \"global\" object that\n * can be imported and mutated at will.\n */\nexport var RXDB_UTILS_GLOBAL = {};\n//# sourceMappingURL=utils-global.js.map","export async function nativeSha256(input) {\n  var data = new TextEncoder().encode(input);\n  /**\n   * If your JavaScript runtime does not support crypto.subtle.digest,\n   * provide your own hash function when calling createRxDatabase().\n   */\n\n  var hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  /**\n   * @link https://jameshfisher.com/2017/10/30/web-cryptography-api-hello-world/\n   */\n  var hash = Array.prototype.map.call(new Uint8Array(hashBuffer), x => ('00' + x.toString(16)).slice(-2)).join('');\n  return hash;\n}\nexport var defaultHashSha256 = nativeSha256;\nexport function hashStringToNumber(str) {\n  var nr = 0;\n  var len = str.length;\n  for (var i = 0; i < len; i++) {\n    nr = nr + str.charCodeAt(i);\n    nr |= 0; // Convert to 32bit integer, improves performance\n  }\n  return nr;\n}\n//# sourceMappingURL=utils-hash.js.map","export function getFromMapOrThrow(map, key) {\n  var val = map.get(key);\n  if (typeof val === 'undefined') {\n    throw new Error('missing value from map ' + key);\n  }\n  return val;\n}\nexport function getFromMapOrCreate(map, index, creator, ifWasThere) {\n  var value = map.get(index);\n  if (typeof value === 'undefined') {\n    value = creator();\n    map.set(index, value);\n  } else if (ifWasThere) {\n    ifWasThere(value);\n  }\n  return value;\n}\n//# sourceMappingURL=utils-map.js.map","/**\n * Copied from the fast-deep-equal package\n * because it does not support es modules and causes optimization bailouts.\n * TODO use the npm package again when this is merged:\n * @link https://github.com/epoberezkin/fast-deep-equal/pull/105\n */\nexport function deepEqual(a, b) {\n  if (a === b) return true;\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length;\n    var i;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) if (!deepEqual(a[i], b[i])) return false;\n      return true;\n    }\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    var keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n    for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n      if (!deepEqual(a[key], b[key])) return false;\n    }\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a !== a && b !== b;\n}\n//# sourceMappingURL=utils-object-deep-equal.js.map","/**\n * Copied from\n * @link https://github.com/sindresorhus/dot-prop/blob/main/index.js\n * because it is currently an esm only module.\n * TODO use the npm package again when RxDB is also fully esm.\n */\n\nvar isObject = value => {\n  var type = typeof value;\n  return value !== null && (type === 'object' || type === 'function');\n};\nvar disallowedKeys = new Set(['__proto__', 'prototype', 'constructor']);\nvar digits = new Set('0123456789');\nfunction getPathSegments(path) {\n  var parts = [];\n  var currentSegment = '';\n  var currentPart = 'start';\n  var isIgnoring = false;\n  for (var character of path) {\n    switch (character) {\n      case '\\\\':\n        {\n          if (currentPart === 'index') {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            throw new Error('Invalid character after an index');\n          }\n          if (isIgnoring) {\n            currentSegment += character;\n          }\n          currentPart = 'property';\n          isIgnoring = !isIgnoring;\n          break;\n        }\n      case '.':\n        {\n          if (currentPart === 'index') {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            currentPart = 'property';\n            break;\n          }\n          if (isIgnoring) {\n            isIgnoring = false;\n            currentSegment += character;\n            break;\n          }\n          if (disallowedKeys.has(currentSegment)) {\n            return [];\n          }\n          parts.push(currentSegment);\n          currentSegment = '';\n          currentPart = 'property';\n          break;\n        }\n      case '[':\n        {\n          if (currentPart === 'index') {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            currentPart = 'index';\n            break;\n          }\n          if (isIgnoring) {\n            isIgnoring = false;\n            currentSegment += character;\n            break;\n          }\n          if (currentPart === 'property') {\n            if (disallowedKeys.has(currentSegment)) {\n              return [];\n            }\n            parts.push(currentSegment);\n            currentSegment = '';\n          }\n          currentPart = 'index';\n          break;\n        }\n      case ']':\n        {\n          if (currentPart === 'index') {\n            parts.push(Number.parseInt(currentSegment, 10));\n            currentSegment = '';\n            currentPart = 'indexEnd';\n            break;\n          }\n          if (currentPart === 'indexEnd') {\n            throw new Error('Invalid character after an index');\n          }\n\n          // Falls through\n        }\n      default:\n        {\n          if (currentPart === 'index' && !digits.has(character)) {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            throw new Error('Invalid character after an index');\n          }\n          if (currentPart === 'start') {\n            currentPart = 'property';\n          }\n          if (isIgnoring) {\n            isIgnoring = false;\n            currentSegment += '\\\\';\n          }\n          currentSegment += character;\n        }\n    }\n  }\n  if (isIgnoring) {\n    currentSegment += '\\\\';\n  }\n  switch (currentPart) {\n    case 'property':\n      {\n        if (disallowedKeys.has(currentSegment)) {\n          return [];\n        }\n        parts.push(currentSegment);\n        break;\n      }\n    case 'index':\n      {\n        throw new Error('Index was not closed');\n      }\n    case 'start':\n      {\n        parts.push('');\n        break;\n      }\n    // No default\n  }\n  return parts;\n}\nfunction isStringIndex(object, key) {\n  if (typeof key !== 'number' && Array.isArray(object)) {\n    var index = Number.parseInt(key, 10);\n    return Number.isInteger(index) && object[index] === object[key];\n  }\n  return false;\n}\nfunction assertNotStringIndex(object, key) {\n  if (isStringIndex(object, key)) {\n    throw new Error('Cannot use string index');\n  }\n}\n\n/**\n * TODO we need some performance tests and improvements here.\n */\nexport function getProperty(object, path, value) {\n  if (Array.isArray(path)) {\n    path = path.join('.');\n  }\n\n  /**\n   * Performance shortcut.\n   * In most cases we just have a simple property name\n   * so we can directly return it.\n   */\n  if (!path.includes('.') && !path.includes('[')) {\n    return object[path];\n  }\n  if (!isObject(object) || typeof path !== 'string') {\n    return value === undefined ? object : value;\n  }\n  var pathArray = getPathSegments(path);\n  if (pathArray.length === 0) {\n    return value;\n  }\n  for (var index = 0; index < pathArray.length; index++) {\n    var key = pathArray[index];\n    if (isStringIndex(object, key)) {\n      object = index === pathArray.length - 1 ? undefined : null;\n    } else {\n      object = object[key];\n    }\n    if (object === undefined || object === null) {\n      // `object` is either `undefined` or `null` so we want to stop the loop, and\n      // if this is not the last bit of the path, and\n      // if it didn't return `undefined`\n      // it would return `null` if `object` is `null`\n      // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n      if (index !== pathArray.length - 1) {\n        return value;\n      }\n      break;\n    }\n  }\n  return object === undefined ? value : object;\n}\nexport function setProperty(object, path, value) {\n  if (Array.isArray(path)) {\n    path = path.join('.');\n  }\n  if (!isObject(object) || typeof path !== 'string') {\n    return object;\n  }\n  var root = object;\n  var pathArray = getPathSegments(path);\n  for (var index = 0; index < pathArray.length; index++) {\n    var key = pathArray[index];\n    assertNotStringIndex(object, key);\n    if (index === pathArray.length - 1) {\n      object[key] = value;\n    } else if (!isObject(object[key])) {\n      object[key] = typeof pathArray[index + 1] === 'number' ? [] : {};\n    }\n    object = object[key];\n  }\n  return root;\n}\nexport function deleteProperty(object, path) {\n  if (!isObject(object) || typeof path !== 'string') {\n    return false;\n  }\n  var pathArray = getPathSegments(path);\n  for (var index = 0; index < pathArray.length; index++) {\n    var key = pathArray[index];\n    assertNotStringIndex(object, key);\n    if (index === pathArray.length - 1) {\n      delete object[key];\n      return true;\n    }\n    object = object[key];\n    if (!isObject(object)) {\n      return false;\n    }\n  }\n}\nexport function hasProperty(object, path) {\n  if (!isObject(object) || typeof path !== 'string') {\n    return false;\n  }\n  var pathArray = getPathSegments(path);\n  if (pathArray.length === 0) {\n    return false;\n  }\n  for (var key of pathArray) {\n    if (!isObject(object) || !(key in object) || isStringIndex(object, key)) {\n      return false;\n    }\n    object = object[key];\n  }\n  return true;\n}\n\n// TODO: Backslashes with no effect should not be escaped\nfunction escapePath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return path.replace(/[\\\\.[]/g, '\\\\$&');\n}\n\n// The keys returned by Object.entries() for arrays are strings\nfunction entries(value) {\n  if (Array.isArray(value)) {\n    return value.map((v, index) => [index, v]);\n  }\n  return Object.entries(value);\n}\nfunction stringifyPath(pathSegments) {\n  var result = '';\n\n  // eslint-disable-next-line prefer-const\n  for (var [index, segment] of entries(pathSegments)) {\n    if (typeof segment === 'number') {\n      result += \"[\" + segment + \"]\";\n    } else {\n      segment = escapePath(segment);\n      result += index === 0 ? segment : \".\" + segment;\n    }\n  }\n  return result;\n}\nfunction* deepKeysIterator(object, currentPath = []) {\n  if (!isObject(object)) {\n    if (currentPath.length > 0) {\n      yield stringifyPath(currentPath);\n    }\n    return;\n  }\n  for (var [key, value] of entries(object)) {\n    yield* deepKeysIterator(value, [...currentPath, key]);\n  }\n}\nexport function deepKeys(object) {\n  return [...deepKeysIterator(object)];\n}\n//# sourceMappingURL=utils-object-dot-prop.js.map","export function deepFreeze(o) {\n  Object.freeze(o);\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (Object.prototype.hasOwnProperty.call(o, prop) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n}\n\n/**\n * To get specific nested path values from objects,\n * RxDB normally uses the 'dot-prop' npm module.\n * But when performance is really relevant, this is not fast enough.\n * Instead we use a monad that can prepare some stuff up front\n * and we can reuse the generated function.\n */\n\nexport function objectPathMonad(objectPath) {\n  var split = objectPath.split('.');\n\n  // reuse this variable for better performance.\n  var splitLength = split.length;\n\n  /**\n   * Performance shortcut,\n   * if no nested path is used,\n   * directly return the field of the object.\n   */\n  if (splitLength === 1) {\n    return obj => obj[objectPath];\n  }\n  return obj => {\n    var currentVal = obj;\n    for (var i = 0; i < splitLength; ++i) {\n      var subPath = split[i];\n      currentVal = currentVal[subPath];\n      if (typeof currentVal === 'undefined') {\n        return currentVal;\n      }\n    }\n    return currentVal;\n  };\n}\nexport function getFromObjectOrThrow(obj, key) {\n  var val = obj[key];\n  if (!val) {\n    throw new Error('missing value from object ' + key);\n  }\n  return val;\n}\n\n/**\n * returns a flattened object\n * @link https://gist.github.com/penguinboy/762197\n */\nexport function flattenObject(ob) {\n  var toReturn = {};\n  for (var i in ob) {\n    if (!Object.prototype.hasOwnProperty.call(ob, i)) continue;\n    if (typeof ob[i] === 'object') {\n      var flatObject = flattenObject(ob[i]);\n      for (var x in flatObject) {\n        if (!Object.prototype.hasOwnProperty.call(flatObject, x)) continue;\n        toReturn[i + '.' + x] = flatObject[x];\n      }\n    } else {\n      toReturn[i] = ob[i];\n    }\n  }\n  return toReturn;\n}\n\n/**\n * does a flat copy on the objects,\n * is about 3 times faster then using deepClone\n * @link https://jsperf.com/object-rest-spread-vs-clone/2\n */\nexport function flatClone(obj) {\n  return Object.assign({}, obj);\n}\n\n/**\n * @link https://stackoverflow.com/a/11509718/3443137\n */\nexport function firstPropertyNameOfObject(obj) {\n  return Object.keys(obj)[0];\n}\nexport function firstPropertyValueOfObject(obj) {\n  var key = Object.keys(obj)[0];\n  return obj[key];\n}\n\n/**\n * deep-sort an object so its attributes are in lexical order.\n * Also sorts the arrays inside of the object if no-array-sort not set\n */\nexport function sortObject(obj, noArraySort = false) {\n  if (!obj) return obj; // do not sort null, false or undefined\n\n  // array\n  if (!noArraySort && Array.isArray(obj)) {\n    return obj.sort((a, b) => {\n      if (typeof a === 'string' && typeof b === 'string') return a.localeCompare(b);\n      if (typeof a === 'object') return 1;else return -1;\n    }).map(i => sortObject(i, noArraySort));\n  }\n\n  // object\n  // array is also of type object\n  if (typeof obj === 'object' && !Array.isArray(obj)) {\n    var out = {};\n    Object.keys(obj).sort((a, b) => a.localeCompare(b)).forEach(key => {\n      out[key] = sortObject(obj[key], noArraySort);\n    });\n    return out;\n  }\n\n  // everything else\n  return obj;\n}\n\n/**\n * Deep clone a plain json object.\n * Does not work with recursive stuff\n * or non-plain-json.\n * IMPORTANT: Performance of this is very important,\n * do not change it without running performance tests!\n *\n * @link https://github.com/zxdong262/deep-copy/blob/master/src/index.ts\n */\nfunction deepClone(src) {\n  if (!src) {\n    return src;\n  }\n  if (src === null || typeof src !== 'object') {\n    return src;\n  }\n  if (Array.isArray(src)) {\n    var ret = new Array(src.length);\n    var i = ret.length;\n    while (i--) {\n      ret[i] = deepClone(src[i]);\n    }\n    return ret;\n  }\n  var dest = {};\n  // eslint-disable-next-line guard-for-in\n  for (var key in src) {\n    dest[key] = deepClone(src[key]);\n  }\n  return dest;\n}\nexport var clone = deepClone;\n\n/**\n * overwrites the getter with the actual value\n * Mostly used for caching stuff on the first run\n */\nexport function overwriteGetterForCaching(obj, getterName, value) {\n  Object.defineProperty(obj, getterName, {\n    get: function () {\n      return value;\n    }\n  });\n  return value;\n}\nexport function hasDeepProperty(obj, property) {\n  if (obj.hasOwnProperty(property)) {\n    return true;\n  }\n  if (Array.isArray(obj)) {\n    var has = !!obj.find(item => hasDeepProperty(item, property));\n    return has;\n  }\n\n  // Recursively check for property in nested objects\n  for (var key in obj) {\n    if (typeof obj[key] === 'object' && obj[key] !== null) {\n      if (hasDeepProperty(obj[key], property)) {\n        return true;\n      }\n    }\n  }\n\n  // Return false if 'foobar' is not found at any level\n  return false;\n}\n\n/**\n * Deeply checks if an object contains any property\n * with the value of undefined\n * If yes, returns the path to it.\n */\nexport function findUndefinedPath(obj, parentPath = '') {\n  // If `obj` is not an object or is null, we can't go deeper, so return false\n  if (typeof obj !== \"object\" || obj === null) {\n    return false;\n  }\n  for (var key of Object.keys(obj)) {\n    var value = obj[key];\n    // Build the full path. For the root level, it's just the key;\n    // for nested levels, prepend the parent path followed by a dot.\n    var currentPath = parentPath ? parentPath + \".\" + key : key;\n\n    // If the value is undefined, return the path\n    if (typeof value === 'undefined') {\n      return currentPath;\n    }\n\n    // If the value is an object, recurse to check deeper\n    if (typeof value === \"object\" && value !== null) {\n      var result = findUndefinedPath(value, currentPath);\n      // If a path was found in the nested object, return it\n      if (result) {\n        return result;\n      }\n    }\n  }\n\n  // If no property with undefined was found\n  return false;\n}\n//# sourceMappingURL=utils-object.js.map","export function runXTimes(xTimes, fn) {\n  new Array(xTimes).fill(0).forEach((_v, idx) => fn(idx));\n}\nexport function ensureNotFalsy(obj, message) {\n  if (!obj) {\n    if (!message) {\n      message = '';\n    }\n    throw new Error('ensureNotFalsy() is falsy: ' + message);\n  }\n  return obj;\n}\nexport function ensureInteger(obj) {\n  if (!Number.isInteger(obj)) {\n    throw new Error('ensureInteger() is falsy');\n  }\n  return obj;\n}\n\n/**\n * Using shareReplay() without settings will not unsubscribe\n * if there are no more subscribers.\n * So we use these defaults.\n * @link https://cartant.medium.com/rxjs-whats-changed-with-sharereplay-65c098843e95\n */\nexport var RXJS_SHARE_REPLAY_DEFAULTS = {\n  bufferSize: 1,\n  refCount: true\n};\n\n/**\n * Dynamically add a name to a function\n * so that it can later be found in the stack.\n * @link https://stackoverflow.com/a/41854075/3443137\n */\nexport function nameFunction(name, body) {\n  // @ts-ignore\n  return {\n    [name](...args) {\n      return body.apply(this, args);\n    }\n  }[name];\n}\nexport function customFetchWithFixedHeaders(headers) {\n  function customFetch(url, options = {}) {\n    // Ensure options object exists and headers property is initialized\n    options.headers = {\n      ...headers,\n      // include default custom headers\n      ...(options.headers || {}) // merge any headers passed in the function call\n    };\n\n    // Call the original fetch with the modified options\n    return fetch(url, options);\n  }\n  return customFetch;\n}\n//# sourceMappingURL=utils-other.js.map","import { RXDB_UTILS_GLOBAL } from \"./utils-global.js\";\nimport { defaultHashSha256 } from \"./utils-hash.js\";\nimport { PROMISE_RESOLVE_FALSE } from \"./utils-promise.js\";\nexport var PREMIUM_FLAG_HASH = '6da4936d1425ff3a5c44c02342c6daf791d266be3ae8479b8ec59e261df41b93';\nexport var NON_PREMIUM_COLLECTION_LIMIT = 16;\nvar hasPremiumPromise = PROMISE_RESOLVE_FALSE;\nvar premiumChecked = false;\n\n/**\n * Here we check if the premium flag has been set.\n * This code exists in the open source version of RxDB.\n * Yes you are allowed to fork the repo and just overwrite this function.\n * However you might better spend this time developing your real project\n * and supporting the RxDB efforts by buying premium.\n */\nexport async function hasPremiumFlag() {\n  if (premiumChecked) {\n    return hasPremiumPromise;\n  }\n  premiumChecked = true;\n  hasPremiumPromise = (async () => {\n    if (RXDB_UTILS_GLOBAL.premium && typeof RXDB_UTILS_GLOBAL.premium === 'string' && (await defaultHashSha256(RXDB_UTILS_GLOBAL.premium)) === PREMIUM_FLAG_HASH) {\n      return true;\n    } else {\n      return false;\n    }\n  })();\n  return hasPremiumPromise;\n}\n//# sourceMappingURL=utils-premium.js.map","/**\n * returns a promise that resolves on the next tick\n */\nexport function nextTick() {\n  return new Promise(res => setTimeout(res, 0));\n}\nexport function promiseWait(ms = 0) {\n  return new Promise(res => setTimeout(res, ms));\n}\nexport function toPromise(maybePromise) {\n  if (maybePromise && typeof maybePromise.then === 'function') {\n    // is promise\n    return maybePromise;\n  } else {\n    return Promise.resolve(maybePromise);\n  }\n}\n\n/**\n * returns true if promise is given\n */\nexport function isPromise(value) {\n  if (typeof value !== 'undefined' && typeof value.then === 'function') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Reusing resolved promises has a better\n * performance than creating new ones each time.\n */\nexport var PROMISE_RESOLVE_TRUE = Promise.resolve(true);\nexport var PROMISE_RESOLVE_FALSE = Promise.resolve(false);\nexport var PROMISE_RESOLVE_NULL = Promise.resolve(null);\nexport var PROMISE_RESOLVE_VOID = Promise.resolve();\nexport function requestIdlePromiseNoQueue(\n/**\n * We always set a timeout!\n * RxDB might be used on the server side where the\n * server runs 24/4 on 99% CPU. So without a timeout\n * this would never resolve which could cause a memory leak.\n */\ntimeout = 10000) {\n  /**\n   * Do not use window.requestIdleCallback\n   * because some javascript runtimes like react-native,\n   * do not have a window object, but still have a global\n   * requestIdleCallback function.\n   * @link https://github.com/pubkey/rxdb/issues/4804\n  */\n  if (typeof requestIdleCallback === 'function') {\n    return new Promise(res => {\n      requestIdleCallback(() => res(), {\n        timeout\n      });\n    });\n  } else {\n    return promiseWait(0);\n  }\n}\n\n/**\n * If multiple operations wait for an requestIdlePromise\n * we do not want them to resolve all at the same time.\n * So we have to queue the calls.\n */\nvar idlePromiseQueue = PROMISE_RESOLVE_VOID;\nexport function requestIdlePromise(timeout = undefined) {\n  idlePromiseQueue = idlePromiseQueue.then(() => {\n    return requestIdlePromiseNoQueue(timeout);\n  });\n  return idlePromiseQueue;\n}\n\n/**\n * run the callback if requestIdleCallback available\n * do nothing if not\n * @link https://developer.mozilla.org/de/docs/Web/API/Window/requestIdleCallback\n */\nexport function requestIdleCallbackIfAvailable(fun) {\n  /**\n   * Do not use window.requestIdleCallback\n   * because some javascript runtimes like react-native,\n   * do not have a window object, but still have a global\n   * requestIdleCallback function.\n   * @link https://github.com/pubkey/rxdb/issues/4804\n  */\n  if (typeof requestIdleCallback === 'function') {\n    requestIdleCallback(() => {\n      fun();\n    });\n  }\n}\n\n/**\n * like Promise.all() but runs in series instead of parallel\n * @link https://github.com/egoist/promise.series/blob/master/index.js\n * @param tasks array with functions that return a promise\n */\nexport function promiseSeries(tasks, initial) {\n  return tasks.reduce((current, next) => current.then(next), Promise.resolve(initial));\n}\n//# sourceMappingURL=utils-promise.js.map","export var REGEX_ALL_DOTS = /\\./g;\nexport var REGEX_ALL_PIPES = /\\|/g;\n//# sourceMappingURL=utils-regex.js.map","/**\n * Parses the full revision.\n * Do NOT use this if you only need the revision height,\n * then use getHeightOfRevision() instead which is faster.\n */\nexport function parseRevision(revision) {\n  var split = revision.split('-');\n  if (split.length !== 2) {\n    throw new Error('malformatted revision: ' + revision);\n  }\n  return {\n    height: parseInt(split[0], 10),\n    hash: split[1]\n  };\n}\n\n/**\n * @hotPath Performance is very important here\n * because we need to parse the revision height very often.\n * Do not use `parseInt(revision.split('-')[0], 10)` because\n * only fetching the start-number chars is faster.\n */\nexport function getHeightOfRevision(revision) {\n  var useChars = '';\n  for (var index = 0; index < revision.length; index++) {\n    var char = revision[index];\n    if (char === '-') {\n      return parseInt(useChars, 10);\n    }\n    useChars += char;\n  }\n  throw new Error('malformatted revision: ' + revision);\n}\n\n/**\n * Creates the next write revision for a given document.\n */\nexport function createRevision(databaseInstanceToken, previousDocData) {\n  var newRevisionHeight = !previousDocData ? 1 : getHeightOfRevision(previousDocData._rev) + 1;\n  return newRevisionHeight + '-' + databaseInstanceToken;\n}\n//# sourceMappingURL=utils-revision.js.map","/**\n * This file is replaced in the 'npm run build:version' script.\n */\nexport var RXDB_VERSION = '16.9.0';\n//# sourceMappingURL=utils-rxdb-version.js.map","var COUCH_NAME_CHARS = 'abcdefghijklmnopqrstuvwxyz';\n\n/**\n * Get a random string which can be used for many things in RxDB.\n * The returned string is guaranteed to be a valid database name or collection name\n * and also to be a valid JavaScript variable name.\n * \n * @link http://stackoverflow.com/a/1349426/3443137\n */\nexport function randomToken(length = 10) {\n  var text = '';\n  for (var i = 0; i < length; i++) {\n    text += COUCH_NAME_CHARS.charAt(Math.floor(Math.random() * COUCH_NAME_CHARS.length));\n  }\n  return text;\n}\n\n/**\n * A random string that is never inside of any storage\n */\nexport var RANDOM_STRING = 'Fz7SZXPmYJujkzjY1rpXWvlWBqoGAfAX';\n\n/**\n * uppercase first char\n */\nexport function ucfirst(str) {\n  str += '';\n  var f = str.charAt(0).toUpperCase();\n  return f + str.substr(1);\n}\n\n/**\n * removes trailing and ending dots from the string\n */\nexport function trimDots(str) {\n  // start\n  while (str.charAt(0) === '.') {\n    str = str.substr(1);\n  }\n\n  // end\n  while (str.slice(-1) === '.') {\n    str = str.slice(0, -1);\n  }\n  return str;\n}\n\n/**\n * @link https://stackoverflow.com/a/44950500/3443137\n */\nexport function lastCharOfString(str) {\n  return str.charAt(str.length - 1);\n}\n\n/**\n * returns true if the given name is likely a folder path\n */\nexport function isFolderPath(name) {\n  // do not check, if foldername is given\n  if (name.includes('/') ||\n  // unix\n  name.includes('\\\\') // windows\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * @link https://gist.github.com/andreburgaud/6f73fd2d690b629346b8\n * @link https://stackoverflow.com/a/76240378/3443137\n */\nexport function arrayBufferToString(arrayBuffer) {\n  return new TextDecoder().decode(arrayBuffer);\n}\nexport function stringToArrayBuffer(str) {\n  return new TextEncoder().encode(str);\n}\nexport function normalizeString(str) {\n  return str.trim().replace(/[\\n\\s]+/g, '');\n}\n//# sourceMappingURL=utils-string.js.map","/**\n * Returns the current unix time in milliseconds (with two decimals!)\n * Because the accuracy of getTime() in javascript is bad,\n * and we cannot rely on performance.now() on all platforms,\n * this method implements a way to never return the same value twice.\n * This ensures that when now() is called often, we do not loose the information\n * about which call came first and which came after.\n *\n * We had to move from having no decimals, to having two decimal\n * because it turned out that some storages are such fast that\n * calling this method too often would return 'the future'.\n */\nvar _lastNow = 0;\n/**\n * Returns the current time in milliseconds,\n * also ensures to not return the same value twice.\n */\nexport function now() {\n  var ret = Date.now();\n  ret = ret + 0.01;\n  if (ret <= _lastNow) {\n    ret = _lastNow + 0.01;\n  }\n\n  /**\n   * Strip the returned number to max two decimals.\n   * In theory we would not need this but\n   * in practice JavaScript has no such good number precision\n   * so rounding errors could add another decimal place.\n   */\n  var twoDecimals = parseFloat(ret.toFixed(2));\n  _lastNow = twoDecimals;\n  return twoDecimals;\n}\n//# sourceMappingURL=utils-time.js.map","/**\n * this plugin validates documents before they can be inserted into the RxCollection.\n * It's using ajv as jsonschema-validator\n * @link https://github.com/epoberezkin/ajv\n * @link https://github.com/ajv-validator/ajv/issues/2132#issuecomment-1537224620\n */\nimport Ajv from 'ajv';\nimport { wrappedValidateStorageFactory } from \"../../plugin-helpers.js\";\nvar ajv;\nexport function getAjv() {\n  if (!ajv) {\n    ajv = new Ajv({\n      strict: true\n    });\n    ajv.addKeyword('version');\n    ajv.addKeyword('keyCompression');\n    ajv.addKeyword('primaryKey');\n    ajv.addKeyword('indexes');\n    ajv.addKeyword('encrypted');\n    ajv.addKeyword('final');\n    ajv.addKeyword('sharding');\n    ajv.addKeyword('internalIndexes');\n    ajv.addKeyword('attachments');\n    ajv.addKeyword('ref');\n    ajv.addKeyword('crdt');\n  }\n  return ajv;\n}\nexport function getValidator(schema) {\n  var validator = getAjv().compile(schema);\n  return docData => {\n    var isValid = validator(docData);\n    if (isValid) {\n      return [];\n    } else {\n      return validator.errors;\n    }\n  };\n}\nexport var wrappedValidateAjvStorage = wrappedValidateStorageFactory(getValidator, 'ajv');\n//# sourceMappingURL=index.js.map","/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\n\nimport { getFromMapOrCreate, nextTick, now, requestIdlePromise } from \"./plugins/utils/index.js\";\nexport var QueryCache = /*#__PURE__*/function () {\n  function QueryCache() {\n    this._map = new Map();\n  }\n  var _proto = QueryCache.prototype;\n  /**\n   * check if an equal query is in the cache,\n   * if true, return the cached one,\n   * if false, save the given one and return it\n   */\n  _proto.getByQuery = function getByQuery(rxQuery) {\n    var stringRep = rxQuery.toString();\n    var ret = getFromMapOrCreate(this._map, stringRep, () => rxQuery);\n    return ret;\n  };\n  return QueryCache;\n}();\nexport function createQueryCache() {\n  return new QueryCache();\n}\nexport function uncacheRxQuery(queryCache, rxQuery) {\n  rxQuery.uncached = true;\n  var stringRep = rxQuery.toString();\n  queryCache._map.delete(stringRep);\n}\nexport function countRxQuerySubscribers(rxQuery) {\n  return rxQuery.refCount$.observers.length;\n}\nexport var DEFAULT_TRY_TO_KEEP_MAX = 100;\nexport var DEFAULT_UNEXECUTED_LIFETIME = 30 * 1000;\n\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\nexport var defaultCacheReplacementPolicyMonad = (tryToKeepMax, unExecutedLifetime) => (_collection, queryCache) => {\n  if (queryCache._map.size < tryToKeepMax) {\n    return;\n  }\n  var minUnExecutedLifetime = now() - unExecutedLifetime;\n  var maybeUncache = [];\n  var queriesInCache = Array.from(queryCache._map.values());\n  for (var rxQuery of queriesInCache) {\n    // filter out queries with subscribers\n    if (countRxQuerySubscribers(rxQuery) > 0) {\n      continue;\n    }\n    // directly uncache queries that never executed and are older than unExecutedLifetime\n    if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n      uncacheRxQuery(queryCache, rxQuery);\n      continue;\n    }\n    maybeUncache.push(rxQuery);\n  }\n  var mustUncache = maybeUncache.length - tryToKeepMax;\n  if (mustUncache <= 0) {\n    return;\n  }\n  var sortedByLastUsage = maybeUncache.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);\n  var toRemove = sortedByLastUsage.slice(0, mustUncache);\n  toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));\n};\nexport var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETIME);\nexport var COLLECTIONS_WITH_RUNNING_CLEANUP = new WeakSet();\n\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\nexport function triggerCacheReplacement(rxCollection) {\n  if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {\n    // already started\n    return;\n  }\n  COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);\n\n  /**\n   * Do not run directly to not reduce result latency of a new query\n   */\n  nextTick() // wait at least one tick\n  .then(() => requestIdlePromise(200)) // and then wait for the CPU to be idle\n  .then(() => {\n    if (!rxCollection.closed) {\n      rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n    }\n    COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);\n  });\n}\n//# sourceMappingURL=query-cache.js.map","import { countUntilNotMatching } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { getSchemaByObjectPath } from \"./rx-schema-helper.js\";\nexport var INDEX_MAX = String.fromCharCode(65535);\n\n/**\n * Do not use -Infinity here because it would be\n * transformed to null on JSON.stringify() which can break things\n * when the query plan is send to the storage as json.\n * @link https://stackoverflow.com/a/16644751\n * Notice that for IndexedDB IDBKeyRange we have\n * to transform the value back to -Infinity\n * before we can use it in IDBKeyRange.bound.\n */\nexport var INDEX_MIN = Number.MIN_SAFE_INTEGER;\n\n/**\n * Returns the query plan which contains\n * information about how to run the query\n * and which indexes to use.\n *\n * This is used in some storage like Memory, dexie.js and IndexedDB.\n */\nexport function getQueryPlan(schema, query) {\n  var selector = query.selector;\n  var indexes = schema.indexes ? schema.indexes.slice(0) : [];\n  if (query.index) {\n    indexes = [query.index];\n  }\n\n  /**\n   * Most storages do not support descending indexes\n   * so having a 'desc' in the sorting, means we always have to re-sort the results.\n   */\n  var hasDescSorting = !!query.sort.find(sortField => Object.values(sortField)[0] === 'desc');\n\n  /**\n   * Some fields can be part of the selector while not being relevant for sorting\n   * because their selector operators specify that in all cases all matching docs\n   * would have the same value.\n   * For example the boolean field _deleted.\n   * TODO similar thing could be done for enums.\n   */\n  var sortIrrelevevantFields = new Set();\n  Object.keys(selector).forEach(fieldName => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    if (schemaPart && schemaPart.type === 'boolean' && Object.prototype.hasOwnProperty.call(selector[fieldName], '$eq')) {\n      sortIrrelevevantFields.add(fieldName);\n    }\n  });\n  var optimalSortIndex = query.sort.map(sortField => Object.keys(sortField)[0]);\n  var optimalSortIndexCompareString = optimalSortIndex.filter(f => !sortIrrelevevantFields.has(f)).join(',');\n  var currentBestQuality = -1;\n  var currentBestQueryPlan;\n\n  /**\n   * Calculate one query plan for each index\n   * and then test which of the plans is best.\n   */\n  indexes.forEach(index => {\n    var inclusiveEnd = true;\n    var inclusiveStart = true;\n    var opts = index.map(indexField => {\n      var matcher = selector[indexField];\n      var operators = matcher ? Object.keys(matcher) : [];\n      var matcherOpts = {};\n      if (!matcher || !operators.length) {\n        var startKey = inclusiveStart ? INDEX_MIN : INDEX_MAX;\n        matcherOpts = {\n          startKey,\n          endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,\n          inclusiveStart: true,\n          inclusiveEnd: true\n        };\n      } else {\n        operators.forEach(operator => {\n          if (LOGICAL_OPERATORS.has(operator)) {\n            var operatorValue = matcher[operator];\n            var partialOpts = getMatcherQueryOpts(operator, operatorValue);\n            matcherOpts = Object.assign(matcherOpts, partialOpts);\n          }\n        });\n      }\n\n      // fill missing attributes\n      if (typeof matcherOpts.startKey === 'undefined') {\n        matcherOpts.startKey = INDEX_MIN;\n      }\n      if (typeof matcherOpts.endKey === 'undefined') {\n        matcherOpts.endKey = INDEX_MAX;\n      }\n      if (typeof matcherOpts.inclusiveStart === 'undefined') {\n        matcherOpts.inclusiveStart = true;\n      }\n      if (typeof matcherOpts.inclusiveEnd === 'undefined') {\n        matcherOpts.inclusiveEnd = true;\n      }\n      if (inclusiveStart && !matcherOpts.inclusiveStart) {\n        inclusiveStart = false;\n      }\n      if (inclusiveEnd && !matcherOpts.inclusiveEnd) {\n        inclusiveEnd = false;\n      }\n      return matcherOpts;\n    });\n    var startKeys = opts.map(opt => opt.startKey);\n    var endKeys = opts.map(opt => opt.endKey);\n    var queryPlan = {\n      index,\n      startKeys,\n      endKeys,\n      inclusiveEnd,\n      inclusiveStart,\n      sortSatisfiedByIndex: !hasDescSorting && optimalSortIndexCompareString === index.filter(f => !sortIrrelevevantFields.has(f)).join(','),\n      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query.selector, startKeys, endKeys)\n    };\n    var quality = rateQueryPlan(schema, query, queryPlan);\n    if (quality >= currentBestQuality || query.index) {\n      currentBestQuality = quality;\n      currentBestQueryPlan = queryPlan;\n    }\n  });\n\n  /**\n   * In all cases and index must be found\n   */\n  if (!currentBestQueryPlan) {\n    throw newRxError('SNH', {\n      query\n    });\n  }\n  return currentBestQueryPlan;\n}\nexport var LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte', '$lt', '$lte']);\nexport var LOWER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte']);\nexport var UPPER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$lt', '$lte']);\nexport function isSelectorSatisfiedByIndex(index, selector, startKeys, endKeys) {\n  /**\n   * Not satisfied if one or more operators are non-logical\n   * operators that can never be satisfied by an index.\n   */\n  var selectorEntries = Object.entries(selector);\n  var hasNonMatchingOperator = selectorEntries.find(([fieldName, operation]) => {\n    if (!index.includes(fieldName)) {\n      return true;\n    }\n    var hasNonLogicOperator = Object.entries(operation).find(([op, _value]) => !LOGICAL_OPERATORS.has(op));\n    return hasNonLogicOperator;\n  });\n  if (hasNonMatchingOperator) {\n    return false;\n  }\n\n  /**\n   * Not satisfied if contains $and or $or operations.\n   */\n  if (selector.$and || selector.$or) {\n    return false;\n  }\n\n  // ensure all lower bound in index\n  var satisfieldLowerBound = [];\n  var lowerOperatorFieldNames = new Set();\n  for (var [fieldName, operation] of Object.entries(selector)) {\n    if (!index.includes(fieldName)) {\n      return false;\n    }\n\n    // If more then one logic op on the same field, we have to selector-match.\n    var lowerLogicOps = Object.keys(operation).filter(key => LOWER_BOUND_LOGICAL_OPERATORS.has(key));\n    if (lowerLogicOps.length > 1) {\n      return false;\n    }\n    var hasLowerLogicOp = lowerLogicOps[0];\n    if (hasLowerLogicOp) {\n      lowerOperatorFieldNames.add(fieldName);\n    }\n    if (hasLowerLogicOp !== '$eq') {\n      if (satisfieldLowerBound.length > 0) {\n        return false;\n      } else {\n        satisfieldLowerBound.push(hasLowerLogicOp);\n      }\n    }\n  }\n\n  // ensure all upper bound in index\n  var satisfieldUpperBound = [];\n  var upperOperatorFieldNames = new Set();\n  for (var [_fieldName, _operation] of Object.entries(selector)) {\n    if (!index.includes(_fieldName)) {\n      return false;\n    }\n\n    // If more then one logic op on the same field, we have to selector-match.\n    var upperLogicOps = Object.keys(_operation).filter(key => UPPER_BOUND_LOGICAL_OPERATORS.has(key));\n    if (upperLogicOps.length > 1) {\n      return false;\n    }\n    var hasUperLogicOp = upperLogicOps[0];\n    if (hasUperLogicOp) {\n      upperOperatorFieldNames.add(_fieldName);\n    }\n    if (hasUperLogicOp !== '$eq') {\n      if (satisfieldUpperBound.length > 0) {\n        return false;\n      } else {\n        satisfieldUpperBound.push(hasUperLogicOp);\n      }\n    }\n  }\n\n  /**\n   * If the index contains a non-relevant field between\n   * the relevant fields, then the index is not satisfying.\n   */\n  var i = 0;\n  for (var _fieldName2 of index) {\n    for (var set of [lowerOperatorFieldNames, upperOperatorFieldNames]) {\n      if (!set.has(_fieldName2) && set.size > 0) {\n        return false;\n      }\n      set.delete(_fieldName2);\n    }\n    var startKey = startKeys[i];\n    var endKey = endKeys[i];\n    if (startKey !== endKey && lowerOperatorFieldNames.size > 0 && upperOperatorFieldNames.size > 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\nexport function getMatcherQueryOpts(operator, operatorValue) {\n  switch (operator) {\n    case '$eq':\n      return {\n        startKey: operatorValue,\n        endKey: operatorValue,\n        inclusiveEnd: true,\n        inclusiveStart: true\n      };\n    case '$lte':\n      return {\n        endKey: operatorValue,\n        inclusiveEnd: true\n      };\n    case '$gte':\n      return {\n        startKey: operatorValue,\n        inclusiveStart: true\n      };\n    case '$lt':\n      return {\n        endKey: operatorValue,\n        inclusiveEnd: false\n      };\n    case '$gt':\n      return {\n        startKey: operatorValue,\n        inclusiveStart: false\n      };\n    default:\n      throw new Error('SNH');\n  }\n}\n\n/**\n * Returns a number that determines the quality of the query plan.\n * Higher number means better query plan.\n */\nexport function rateQueryPlan(schema, query, queryPlan) {\n  var quality = 0;\n  var addQuality = value => {\n    if (value > 0) {\n      quality = quality + value;\n    }\n  };\n  var pointsPerMatchingKey = 10;\n  var nonMinKeyCount = countUntilNotMatching(queryPlan.startKeys, keyValue => keyValue !== INDEX_MIN && keyValue !== INDEX_MAX);\n  addQuality(nonMinKeyCount * pointsPerMatchingKey);\n  var nonMaxKeyCount = countUntilNotMatching(queryPlan.startKeys, keyValue => keyValue !== INDEX_MAX && keyValue !== INDEX_MIN);\n  addQuality(nonMaxKeyCount * pointsPerMatchingKey);\n  var equalKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue, idx) => {\n    if (keyValue === queryPlan.endKeys[idx]) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n  addQuality(equalKeyCount * pointsPerMatchingKey * 1.5);\n  var pointsIfNoReSortMustBeDone = queryPlan.sortSatisfiedByIndex ? 5 : 0;\n  addQuality(pointsIfNoReSortMustBeDone);\n  return quality;\n}\n//# sourceMappingURL=query-planner.js.map","import { getComposedPrimaryKeyOfDocumentData } from \"../rx-schema-helper.js\";\nimport { getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from \"../rx-storage-helper.js\";\nimport { createRevision, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, now } from \"../plugins/utils/index.js\";\nexport async function getLastCheckpointDoc(state, direction) {\n  var checkpointDocId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {\n    isCheckpoint: '1',\n    itemId: direction\n  });\n  var checkpointResult = await state.input.metaInstance.findDocumentsById([checkpointDocId], false);\n  var checkpointDoc = checkpointResult[0];\n  state.lastCheckpointDoc[direction] = checkpointDoc;\n  if (checkpointDoc) {\n    return checkpointDoc.checkpointData;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Sets the checkpoint,\n * automatically resolves conflicts that appear.\n */\nexport async function setCheckpoint(state, direction, checkpoint) {\n  state.checkpointQueue = state.checkpointQueue.then(async () => {\n    var previousCheckpointDoc = state.lastCheckpointDoc[direction];\n    if (checkpoint &&\n    /**\n     * If the replication is already canceled,\n     * we do not write a checkpoint\n     * because that could mean we write a checkpoint\n     * for data that has been fetched from the master\n     * but not been written to the child.\n     */\n    !state.events.canceled.getValue() && (\n    /**\n     * Only write checkpoint if it is different from before\n     * to have less writes to the storage.\n     */\n\n    !previousCheckpointDoc || JSON.stringify(previousCheckpointDoc.checkpointData) !== JSON.stringify(checkpoint))) {\n      var newDoc = {\n        id: '',\n        isCheckpoint: '1',\n        itemId: direction,\n        _deleted: false,\n        _attachments: {},\n        checkpointData: checkpoint,\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision()\n      };\n      newDoc.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newDoc);\n      while (!state.events.canceled.getValue()) {\n        /**\n         * Instead of just storing the new checkpoint,\n         * we have to stack up the checkpoint with the previous one.\n         * This is required for plugins like the sharding RxStorage\n         * where the changeStream events only contain a Partial of the\n         * checkpoint.\n         */\n        if (previousCheckpointDoc) {\n          newDoc.checkpointData = stackCheckpoints([previousCheckpointDoc.checkpointData, newDoc.checkpointData]);\n        }\n        newDoc._meta.lwt = now();\n        newDoc._rev = createRevision(await state.checkpointKey, previousCheckpointDoc);\n        if (state.events.canceled.getValue()) {\n          return;\n        }\n        var writeRows = [{\n          previous: previousCheckpointDoc,\n          document: newDoc\n        }];\n        var result = await state.input.metaInstance.bulkWrite(writeRows, 'replication-set-checkpoint');\n        var successDoc = getWrittenDocumentsFromBulkWriteResponse(state.primaryPath, writeRows, result)[0];\n        if (successDoc) {\n          state.lastCheckpointDoc[direction] = successDoc;\n          return;\n        } else {\n          var error = result.error[0];\n          if (error.status !== 409) {\n            throw error;\n          } else {\n            previousCheckpointDoc = ensureNotFalsy(error.documentInDb);\n            newDoc._rev = createRevision(await state.checkpointKey, previousCheckpointDoc);\n          }\n        }\n      }\n    }\n  });\n  await state.checkpointQueue;\n}\nexport async function getCheckpointKey(input) {\n  var hash = await input.hashFunction([input.identifier, input.forkInstance.databaseName, input.forkInstance.collectionName].join('||'));\n  return 'rx_storage_replication_' + hash;\n}\n//# sourceMappingURL=checkpoint.js.map","import { getDefaultRevision, createRevision, now, flatClone } from \"../plugins/utils/index.js\";\n\n/**\n * Resolves a conflict error or determines that the given document states are equal.\n * Returns the resolved document that must be written to the fork.\n * Then the new document state can be pushed upstream.\n * If document is not in conflict, returns undefined.\n * If error is non-409, it throws an error.\n * Conflicts are only solved in the upstream, never in the downstream.\n */\nexport async function resolveConflictError(state, input, forkState) {\n  var conflictHandler = state.input.conflictHandler;\n  var isEqual = conflictHandler.isEqual(input.realMasterState, input.newDocumentState, 'replication-resolve-conflict');\n  if (isEqual) {\n    /**\n     * Documents are equal,\n     * so this is not a conflict -> do nothing.\n     */\n    return undefined;\n  } else {\n    var resolved = await conflictHandler.resolve(input, 'replication-resolve-conflict');\n    /**\n     * We have a resolved conflict,\n     * use the resolved document data.\n     */\n    var resolvedDoc = Object.assign({}, resolved, {\n      /**\n       * Because the resolved conflict is written to the fork,\n       * we have to keep/update the forks _meta data, not the masters.\n       */\n      _meta: flatClone(forkState._meta),\n      _rev: getDefaultRevision(),\n      _attachments: flatClone(forkState._attachments)\n    });\n    resolvedDoc._meta.lwt = now();\n    resolvedDoc._rev = createRevision(await state.checkpointKey, forkState);\n    return resolvedDoc;\n  }\n}\n//# sourceMappingURL=conflicts.js.map","import { deepEqual } from \"../plugins/utils/index.js\";\nimport { stripAttachmentsDataFromDocument } from \"../rx-storage-helper.js\";\nexport var defaultConflictHandler = {\n  isEqual(a, b) {\n    /**\n     * If the documents are deep equal,\n     * we have no conflict.\n     * On your custom conflict handler you might only\n     * check some properties, like the updatedAt time,\n     * for better performance, because deepEqual is expensive.\n     */\n    return deepEqual(stripAttachmentsDataFromDocument(a), stripAttachmentsDataFromDocument(b));\n  },\n  resolve(i) {\n    /**\n     * The default conflict handler will always\n     * drop the fork state and use the master state instead.\n     */\n    return i.realMasterState;\n  }\n};\n//# sourceMappingURL=default-conflict-handler.js.map","import { firstValueFrom, filter, mergeMap } from 'rxjs';\nimport { newRxError } from \"../rx-error.js\";\nimport { getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from \"../rx-storage-helper.js\";\nimport { appendToArray, createRevision, ensureNotFalsy, flatClone, getDefaultRevision, getHeightOfRevision, now, PROMISE_RESOLVE_VOID } from \"../plugins/utils/index.js\";\nimport { getLastCheckpointDoc, setCheckpoint } from \"./checkpoint.js\";\nimport { stripAttachmentsDataFromMetaWriteRows, writeDocToDocState } from \"./helper.js\";\nimport { getAssumedMasterState, getMetaWriteRow } from \"./meta-instance.js\";\n\n/**\n * Writes all documents from the master to the fork.\n * The downstream has two operation modes\n * - Sync by iterating over the checkpoints via downstreamResyncOnce()\n * - Sync by listening to the changestream via downstreamProcessChanges()\n * We need this to be able to do initial syncs\n * and still can have fast event based sync when the client is not offline.\n */\nexport async function startReplicationDownstream(state) {\n  if (state.input.initialCheckpoint && state.input.initialCheckpoint.downstream) {\n    var checkpointDoc = await getLastCheckpointDoc(state, 'down');\n    if (!checkpointDoc) {\n      await setCheckpoint(state, 'down', state.input.initialCheckpoint.downstream);\n    }\n  }\n  var identifierHash = await state.input.hashFunction(state.input.identifier);\n  var replicationHandler = state.input.replicationHandler;\n\n  // used to detect which tasks etc can in it at which order.\n  var timer = 0;\n  var openTasks = [];\n  function addNewTask(task) {\n    state.stats.down.addNewTask = state.stats.down.addNewTask + 1;\n    var taskWithTime = {\n      time: timer++,\n      task\n    };\n    openTasks.push(taskWithTime);\n    state.streamQueue.down = state.streamQueue.down.then(() => {\n      var useTasks = [];\n      while (openTasks.length > 0) {\n        state.events.active.down.next(true);\n        var innerTaskWithTime = ensureNotFalsy(openTasks.shift());\n\n        /**\n         * If the task came in before the last time we started the pull\n         * from the master, then we can drop the task.\n         */\n        if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {\n          continue;\n        }\n        if (innerTaskWithTime.task === 'RESYNC') {\n          if (useTasks.length === 0) {\n            useTasks.push(innerTaskWithTime.task);\n            break;\n          } else {\n            break;\n          }\n        }\n        useTasks.push(innerTaskWithTime.task);\n      }\n      if (useTasks.length === 0) {\n        return;\n      }\n      if (useTasks[0] === 'RESYNC') {\n        return downstreamResyncOnce();\n      } else {\n        return downstreamProcessChanges(useTasks);\n      }\n    }).then(() => {\n      state.events.active.down.next(false);\n      if (!state.firstSyncDone.down.getValue() && !state.events.canceled.getValue()) {\n        state.firstSyncDone.down.next(true);\n      }\n    });\n  }\n  addNewTask('RESYNC');\n\n  /**\n   * If a write on the master happens, we have to trigger the downstream.\n   * Only do this if not canceled yet, otherwise firstValueFrom errors\n   * when running on a completed observable.\n   */\n  if (!state.events.canceled.getValue()) {\n    var sub = replicationHandler.masterChangeStream$.pipe(mergeMap(async ev => {\n      /**\n       * While a push is running, we have to delay all incoming\n       * events from the server to not mix up the replication state.\n       */\n      await firstValueFrom(state.events.active.up.pipe(filter(s => !s)));\n      return ev;\n    })).subscribe(task => {\n      state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;\n      addNewTask(task);\n    });\n    // unsubscribe when replication is canceled\n    firstValueFrom(state.events.canceled.pipe(filter(canceled => !!canceled))).then(() => sub.unsubscribe());\n  }\n\n  /**\n   * For faster performance, we directly start each write\n   * and then await all writes at the end.\n   */\n  var lastTimeMasterChangesRequested = -1;\n  async function downstreamResyncOnce() {\n    state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;\n    if (state.events.canceled.getValue()) {\n      return;\n    }\n    state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'down'));\n    var lastCheckpoint = await state.checkpointQueue;\n    var promises = [];\n    while (!state.events.canceled.getValue()) {\n      lastTimeMasterChangesRequested = timer++;\n      var downResult = await replicationHandler.masterChangesSince(lastCheckpoint, state.input.pullBatchSize);\n      if (downResult.documents.length === 0) {\n        break;\n      }\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, downResult.checkpoint]);\n      promises.push(persistFromMaster(downResult.documents, lastCheckpoint));\n\n      /**\n       * By definition we stop pull when the pulled documents\n       * do not fill up the pullBatchSize because we\n       * can assume that the remote has no more documents.\n       */\n      if (downResult.documents.length < state.input.pullBatchSize) {\n        break;\n      }\n    }\n    await Promise.all(promises);\n  }\n  function downstreamProcessChanges(tasks) {\n    state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;\n    var docsOfAllTasks = [];\n    var lastCheckpoint = null;\n    tasks.forEach(task => {\n      if (task === 'RESYNC') {\n        throw new Error('SNH');\n      }\n      appendToArray(docsOfAllTasks, task.documents);\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, task.checkpoint]);\n    });\n    return persistFromMaster(docsOfAllTasks, ensureNotFalsy(lastCheckpoint));\n  }\n\n  /**\n   * It can happen that the calls to masterChangesSince() or the changeStream()\n   * are way faster then how fast the documents can be persisted.\n   * Therefore we merge all incoming downResults into the nonPersistedFromMaster object\n   * and process them together if possible.\n   * This often bundles up single writes and improves performance\n   * by processing the documents in bulks.\n   */\n  var persistenceQueue = PROMISE_RESOLVE_VOID;\n  var nonPersistedFromMaster = {\n    docs: {}\n  };\n  function persistFromMaster(docs, checkpoint) {\n    var primaryPath = state.primaryPath;\n    state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;\n\n    /**\n     * Add the new docs to the non-persistent list\n     */\n    docs.forEach(docData => {\n      var docId = docData[primaryPath];\n      nonPersistedFromMaster.docs[docId] = docData;\n    });\n    nonPersistedFromMaster.checkpoint = checkpoint;\n\n    /**\n     * Run in the queue\n     * with all open documents from nonPersistedFromMaster.\n     */\n    persistenceQueue = persistenceQueue.then(() => {\n      var downDocsById = nonPersistedFromMaster.docs;\n      nonPersistedFromMaster.docs = {};\n      var useCheckpoint = nonPersistedFromMaster.checkpoint;\n      var docIds = Object.keys(downDocsById);\n      if (state.events.canceled.getValue() || docIds.length === 0) {\n        return PROMISE_RESOLVE_VOID;\n      }\n      var writeRowsToFork = [];\n      var writeRowsToForkById = {};\n      var writeRowsToMeta = {};\n      var useMetaWriteRows = [];\n      return Promise.all([state.input.forkInstance.findDocumentsById(docIds, true), getAssumedMasterState(state, docIds)]).then(([currentForkStateList, assumedMasterState]) => {\n        var currentForkState = new Map();\n        currentForkStateList.forEach(doc => currentForkState.set(doc[primaryPath], doc));\n        return Promise.all(docIds.map(async docId => {\n          var forkStateFullDoc = currentForkState.get(docId);\n          var forkStateDocData = forkStateFullDoc ? writeDocToDocState(forkStateFullDoc, state.hasAttachments, false) : undefined;\n          var masterState = downDocsById[docId];\n          var assumedMaster = assumedMasterState[docId];\n          if (assumedMaster && forkStateFullDoc && assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev) {\n            /**\n             * The current fork state represents a resolved conflict\n             * that first must be send to the master in the upstream.\n             * All conflicts are resolved by the upstream.\n             */\n            // return PROMISE_RESOLVE_VOID;\n            await state.streamQueue.up;\n          }\n          var isAssumedMasterEqualToForkState = !assumedMaster || !forkStateDocData ? false : state.input.conflictHandler.isEqual(assumedMaster.docData, forkStateDocData, 'downstream-check-if-equal-0');\n          if (!isAssumedMasterEqualToForkState && assumedMaster && assumedMaster.docData._rev && forkStateFullDoc && forkStateFullDoc._meta[state.input.identifier] && getHeightOfRevision(forkStateFullDoc._rev) === forkStateFullDoc._meta[state.input.identifier]) {\n            isAssumedMasterEqualToForkState = true;\n          }\n          if (forkStateFullDoc && assumedMaster && isAssumedMasterEqualToForkState === false || forkStateFullDoc && !assumedMaster) {\n            /**\n             * We have a non-upstream-replicated\n             * local write to the fork.\n             * This means we ignore the downstream of this document\n             * because anyway the upstream will first resolve the conflict.\n             */\n            return PROMISE_RESOLVE_VOID;\n          }\n          var areStatesExactlyEqual = !forkStateDocData ? false : state.input.conflictHandler.isEqual(masterState, forkStateDocData, 'downstream-check-if-equal-1');\n          if (forkStateDocData && areStatesExactlyEqual) {\n            /**\n             * Document states are exactly equal.\n             * This can happen when the replication is shut down\n             * unexpected like when the user goes offline.\n             *\n             * Only when the assumedMaster is different from the forkState,\n             * we have to patch the document in the meta instance.\n             */\n            if (!assumedMaster || isAssumedMasterEqualToForkState === false) {\n              useMetaWriteRows.push(await getMetaWriteRow(state, forkStateDocData, assumedMaster ? assumedMaster.metaDocument : undefined));\n            }\n            return PROMISE_RESOLVE_VOID;\n          }\n\n          /**\n           * All other master states need to be written to the forkInstance\n           * and metaInstance.\n           */\n          var newForkState = Object.assign({}, masterState, forkStateFullDoc ? {\n            _meta: flatClone(forkStateFullDoc._meta),\n            _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {},\n            _rev: getDefaultRevision()\n          } : {\n            _meta: {\n              lwt: now()\n            },\n            _rev: getDefaultRevision(),\n            _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {}\n          });\n          /**\n           * If the remote works with revisions,\n           * we store the height of the next fork-state revision\n           * inside of the documents meta data.\n           * By doing so we can filter it out in the upstream\n           * and detect the document as being equal to master or not.\n           * This is used for example in the CouchDB replication plugin.\n           */\n          if (masterState._rev) {\n            var nextRevisionHeight = !forkStateFullDoc ? 1 : getHeightOfRevision(forkStateFullDoc._rev) + 1;\n            newForkState._meta[state.input.identifier] = nextRevisionHeight;\n            if (state.input.keepMeta) {\n              newForkState._rev = masterState._rev;\n            }\n          }\n          if (state.input.keepMeta && masterState._meta) {\n            newForkState._meta = masterState._meta;\n          }\n          var forkWriteRow = {\n            previous: forkStateFullDoc,\n            document: newForkState\n          };\n          forkWriteRow.document._rev = forkWriteRow.document._rev ? forkWriteRow.document._rev : createRevision(identifierHash, forkWriteRow.previous);\n          writeRowsToFork.push(forkWriteRow);\n          writeRowsToForkById[docId] = forkWriteRow;\n          writeRowsToMeta[docId] = await getMetaWriteRow(state, masterState, assumedMaster ? assumedMaster.metaDocument : undefined);\n        }));\n      }).then(async () => {\n        if (writeRowsToFork.length > 0) {\n          return state.input.forkInstance.bulkWrite(writeRowsToFork, await state.downstreamBulkWriteFlag).then(forkWriteResult => {\n            var success = getWrittenDocumentsFromBulkWriteResponse(state.primaryPath, writeRowsToFork, forkWriteResult);\n            success.forEach(doc => {\n              var docId = doc[primaryPath];\n              state.events.processed.down.next(writeRowsToForkById[docId]);\n              useMetaWriteRows.push(writeRowsToMeta[docId]);\n            });\n            var mustThrow;\n            forkWriteResult.error.forEach(error => {\n              /**\n               * We do not have to care about downstream conflict errors here\n               * because on conflict, it will be solved locally and result in another write.\n               */\n              if (error.status === 409) {\n                return;\n              }\n              // other non-conflict errors must be handled\n              var throwMe = newRxError('RC_PULL', {\n                writeError: error\n              });\n              state.events.error.next(throwMe);\n              mustThrow = throwMe;\n            });\n            if (mustThrow) {\n              throw mustThrow;\n            }\n          });\n        }\n      }).then(() => {\n        if (useMetaWriteRows.length > 0) {\n          return state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useMetaWriteRows), 'replication-down-write-meta').then(metaWriteResult => {\n            metaWriteResult.error.forEach(writeError => {\n              state.events.error.next(newRxError('RC_PULL', {\n                id: writeError.documentId,\n                writeError\n              }));\n            });\n          });\n        }\n      }).then(() => {\n        /**\n         * For better performance we do not await checkpoint writes,\n         * but to ensure order on parallel checkpoint writes,\n         * we have to use a queue.\n         */\n        setCheckpoint(state, 'down', useCheckpoint);\n      });\n    }).catch(unhandledError => state.events.error.next(unhandledError));\n    return persistenceQueue;\n  }\n}\n//# sourceMappingURL=downstream.js.map","import { clone, createRevision, flatClone, getDefaultRevision, now } from \"../plugins/utils/index.js\";\nimport { stripAttachmentsDataFromDocument } from \"../rx-storage-helper.js\";\nexport function docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, docState, previous) {\n  var docData = Object.assign({}, docState, {\n    _attachments: hasAttachments && docState._attachments ? docState._attachments : {},\n    _meta: keepMeta ? docState._meta : Object.assign({}, previous ? previous._meta : {}, {\n      lwt: now()\n    }),\n    _rev: keepMeta ? docState._rev : getDefaultRevision()\n  });\n  if (!docData._rev) {\n    docData._rev = createRevision(databaseInstanceToken, previous);\n  }\n  return docData;\n}\nexport function writeDocToDocState(writeDoc, keepAttachments, keepMeta) {\n  var ret = flatClone(writeDoc);\n  if (!keepAttachments) {\n    delete ret._attachments;\n  }\n  if (!keepMeta) {\n    delete ret._meta;\n    delete ret._rev;\n  }\n  return ret;\n}\nexport function stripAttachmentsDataFromMetaWriteRows(state, rows) {\n  if (!state.hasAttachments) {\n    return rows;\n  }\n  return rows.map(row => {\n    var document = clone(row.document);\n    document.docData = stripAttachmentsDataFromDocument(document.docData);\n    return {\n      document,\n      previous: row.previous\n    };\n  });\n}\nexport function getUnderlyingPersistentStorage(instance) {\n  while (true) {\n    if (instance.underlyingPersistentStorage) {\n      instance = instance.underlyingPersistentStorage;\n    } else {\n      return instance;\n    }\n  }\n}\n//# sourceMappingURL=helper.js.map","/**\n * These files contain the replication protocol.\n * It can be used to replicated RxStorageInstances or RxCollections\n * or even to do a client(s)-server replication.\n */\n\nimport { BehaviorSubject, combineLatest, filter, firstValueFrom, mergeMap, Subject } from 'rxjs';\nimport { getPrimaryFieldOfPrimaryKey } from \"../rx-schema-helper.js\";\nimport { clone, ensureNotFalsy, flatClone, PROMISE_RESOLVE_VOID } from \"../plugins/utils/index.js\";\nimport { getCheckpointKey } from \"./checkpoint.js\";\nimport { startReplicationDownstream } from \"./downstream.js\";\nimport { docStateToWriteDoc, getUnderlyingPersistentStorage, writeDocToDocState } from \"./helper.js\";\nimport { startReplicationUpstream } from \"./upstream.js\";\nimport { fillWriteDataForAttachmentsChange } from \"../plugins/attachments/index.js\";\nimport { getChangedDocumentsSince } from \"../rx-storage-helper.js\";\nimport { newRxError } from \"../rx-error.js\";\nexport * from \"./checkpoint.js\";\nexport * from \"./downstream.js\";\nexport * from \"./upstream.js\";\nexport * from \"./meta-instance.js\";\nexport * from \"./conflicts.js\";\nexport * from \"./helper.js\";\nexport * from \"./default-conflict-handler.js\";\nexport function replicateRxStorageInstance(input) {\n  input = flatClone(input);\n  input.forkInstance = getUnderlyingPersistentStorage(input.forkInstance);\n  input.metaInstance = getUnderlyingPersistentStorage(input.metaInstance);\n  var checkpointKeyPromise = getCheckpointKey(input);\n  var state = {\n    primaryPath: getPrimaryFieldOfPrimaryKey(input.forkInstance.schema.primaryKey),\n    hasAttachments: !!input.forkInstance.schema.attachments,\n    input,\n    checkpointKey: checkpointKeyPromise,\n    downstreamBulkWriteFlag: checkpointKeyPromise.then(checkpointKey => 'replication-downstream-' + checkpointKey),\n    events: {\n      canceled: new BehaviorSubject(false),\n      paused: new BehaviorSubject(false),\n      active: {\n        down: new BehaviorSubject(true),\n        up: new BehaviorSubject(true)\n      },\n      processed: {\n        down: new Subject(),\n        up: new Subject()\n      },\n      resolvedConflicts: new Subject(),\n      error: new Subject()\n    },\n    stats: {\n      down: {\n        addNewTask: 0,\n        downstreamProcessChanges: 0,\n        downstreamResyncOnce: 0,\n        masterChangeStreamEmit: 0,\n        persistFromMaster: 0\n      },\n      up: {\n        forkChangeStreamEmit: 0,\n        persistToMaster: 0,\n        persistToMasterConflictWrites: 0,\n        persistToMasterHadConflicts: 0,\n        processTasks: 0,\n        upstreamInitialSync: 0\n      }\n    },\n    firstSyncDone: {\n      down: new BehaviorSubject(false),\n      up: new BehaviorSubject(false)\n    },\n    streamQueue: {\n      down: PROMISE_RESOLVE_VOID,\n      up: PROMISE_RESOLVE_VOID\n    },\n    checkpointQueue: PROMISE_RESOLVE_VOID,\n    lastCheckpointDoc: {}\n  };\n  startReplicationDownstream(state);\n  startReplicationUpstream(state);\n  return state;\n}\nexport function awaitRxStorageReplicationFirstInSync(state) {\n  return firstValueFrom(combineLatest([state.firstSyncDone.down.pipe(filter(v => !!v)), state.firstSyncDone.up.pipe(filter(v => !!v))])).then(() => {});\n}\nexport function awaitRxStorageReplicationInSync(replicationState) {\n  return Promise.all([replicationState.streamQueue.up, replicationState.streamQueue.down, replicationState.checkpointQueue]);\n}\nexport async function awaitRxStorageReplicationIdle(state) {\n  await awaitRxStorageReplicationFirstInSync(state);\n  while (true) {\n    var {\n      down,\n      up\n    } = state.streamQueue;\n    await Promise.all([up, down]);\n    /**\n     * If the Promises have not been reassigned\n     * after awaiting them, we know that the replication\n     * is in idle state at this point in time.\n     */\n    if (down === state.streamQueue.down && up === state.streamQueue.up) {\n      return;\n    }\n  }\n}\nexport function rxStorageInstanceToReplicationHandler(instance, conflictHandler, databaseInstanceToken,\n/**\n * If set to true,\n * the _meta.lwt from the pushed documents is kept.\n * (Used in the migration to ensure checkpoints are still valid)\n */\nkeepMeta = false) {\n  instance = getUnderlyingPersistentStorage(instance);\n  var hasAttachments = !!instance.schema.attachments;\n  var primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n  var replicationHandler = {\n    masterChangeStream$: instance.changeStream().pipe(mergeMap(async eventBulk => {\n      var ret = {\n        checkpoint: eventBulk.checkpoint,\n        documents: await Promise.all(eventBulk.events.map(async event => {\n          var docData = writeDocToDocState(event.documentData, hasAttachments, keepMeta);\n          if (hasAttachments) {\n            docData = await fillWriteDataForAttachmentsChange(primaryPath, instance, clone(docData),\n            /**\n             * Notice that the master never knows\n             * the client state of the document.\n             * Therefore we always send all attachments data.\n             */\n            undefined);\n          }\n          return docData;\n        }))\n      };\n      return ret;\n    })),\n    masterChangesSince(checkpoint, batchSize) {\n      return getChangedDocumentsSince(instance, batchSize, checkpoint).then(async result => {\n        return {\n          checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,\n          documents: await Promise.all(result.documents.map(async plainDocumentData => {\n            var docData = writeDocToDocState(plainDocumentData, hasAttachments, keepMeta);\n            if (hasAttachments) {\n              docData = await fillWriteDataForAttachmentsChange(primaryPath, instance, clone(docData),\n              /**\n               * Notice the the master never knows\n               * the client state of the document.\n               * Therefore we always send all attachments data.\n               */\n              undefined);\n            }\n            return docData;\n          }))\n        };\n      });\n    },\n    async masterWrite(rows) {\n      var rowById = {};\n      rows.forEach(row => {\n        var docId = row.newDocumentState[primaryPath];\n        rowById[docId] = row;\n      });\n      var ids = Object.keys(rowById);\n      var masterDocsStateList = await instance.findDocumentsById(ids, true);\n      var masterDocsState = new Map();\n      masterDocsStateList.forEach(doc => masterDocsState.set(doc[primaryPath], doc));\n      var conflicts = [];\n      var writeRows = [];\n      await Promise.all(Object.entries(rowById).map(([id, row]) => {\n        var masterState = masterDocsState.get(id);\n        if (!masterState) {\n          writeRows.push({\n            document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState)\n          });\n        } else if (masterState && !row.assumedMasterState) {\n          conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n        } else if (conflictHandler.isEqual(writeDocToDocState(masterState, hasAttachments, keepMeta), ensureNotFalsy(row.assumedMasterState), 'rxStorageInstanceToReplicationHandler-masterWrite') === true) {\n          writeRows.push({\n            previous: masterState,\n            document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState, masterState)\n          });\n        } else {\n          conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n        }\n      }));\n      if (writeRows.length > 0) {\n        var result = await instance.bulkWrite(writeRows, 'replication-master-write');\n        result.error.forEach(err => {\n          if (err.status !== 409) {\n            throw newRxError('SNH', {\n              name: 'non conflict error',\n              error: err\n            });\n          } else {\n            conflicts.push(writeDocToDocState(ensureNotFalsy(err.documentInDb), hasAttachments, keepMeta));\n          }\n        });\n      }\n      return conflicts;\n    }\n  };\n  return replicationHandler;\n}\nexport async function cancelRxStorageReplication(replicationState) {\n  replicationState.events.canceled.next(true);\n  replicationState.events.active.up.complete();\n  replicationState.events.active.down.complete();\n  replicationState.events.processed.up.complete();\n  replicationState.events.processed.down.complete();\n  replicationState.events.resolvedConflicts.complete();\n  replicationState.events.canceled.complete();\n  await replicationState.checkpointQueue;\n}\n//# sourceMappingURL=index.js.map","import { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData, getLengthOfPrimaryKey } from \"../rx-schema-helper.js\";\nimport { flatCloneDocWithMeta } from \"../rx-storage-helper.js\";\nimport { getDefaultRevision, createRevision, now } from \"../plugins/utils/index.js\";\nexport var META_INSTANCE_SCHEMA_TITLE = 'RxReplicationProtocolMetaData';\nexport function getRxReplicationMetaInstanceSchema(replicatedDocumentsSchema, encrypted) {\n  var parentPrimaryKeyLength = getLengthOfPrimaryKey(replicatedDocumentsSchema);\n  var baseSchema = {\n    title: META_INSTANCE_SCHEMA_TITLE,\n    primaryKey: {\n      key: 'id',\n      fields: ['itemId', 'isCheckpoint'],\n      separator: '|'\n    },\n    type: 'object',\n    version: replicatedDocumentsSchema.version,\n    additionalProperties: false,\n    properties: {\n      id: {\n        type: 'string',\n        minLength: 1,\n        // add +1 for the '|' and +1 for the 'isCheckpoint' flag\n        maxLength: parentPrimaryKeyLength + 2\n      },\n      isCheckpoint: {\n        type: 'string',\n        enum: ['0', '1'],\n        minLength: 1,\n        maxLength: 1\n      },\n      itemId: {\n        type: 'string',\n        /**\n         * ensure that all values of RxStorageReplicationDirection ('DOWN' has 4 chars) fit into it\n         * because checkpoints use the itemId field for that.\n         */\n        maxLength: parentPrimaryKeyLength > 4 ? parentPrimaryKeyLength : 4\n      },\n      checkpointData: {\n        type: 'object',\n        additionalProperties: true\n      },\n      docData: {\n        type: 'object',\n        properties: replicatedDocumentsSchema.properties\n      },\n      isResolvedConflict: {\n        type: 'string'\n      }\n    },\n    keyCompression: replicatedDocumentsSchema.keyCompression,\n    required: ['id', 'isCheckpoint', 'itemId']\n  };\n  if (encrypted) {\n    baseSchema.encrypted = ['docData'];\n  }\n  var metaInstanceSchema = fillWithDefaultSettings(baseSchema);\n  return metaInstanceSchema;\n}\n\n/**\n * Returns the document states of what the fork instance\n * assumes to be the latest state on the master instance.\n */\nexport function getAssumedMasterState(state, docIds) {\n  return state.input.metaInstance.findDocumentsById(docIds.map(docId => {\n    var useId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {\n      itemId: docId,\n      isCheckpoint: '0'\n    });\n    return useId;\n  }), true).then(metaDocs => {\n    var ret = {};\n    Object.values(metaDocs).forEach(metaDoc => {\n      ret[metaDoc.itemId] = {\n        docData: metaDoc.docData,\n        metaDocument: metaDoc\n      };\n    });\n    return ret;\n  });\n}\nexport async function getMetaWriteRow(state, newMasterDocState, previous, isResolvedConflict) {\n  var docId = newMasterDocState[state.primaryPath];\n  var newMeta = previous ? flatCloneDocWithMeta(previous) : {\n    id: '',\n    isCheckpoint: '0',\n    itemId: docId,\n    docData: newMasterDocState,\n    _attachments: {},\n    _deleted: false,\n    _rev: getDefaultRevision(),\n    _meta: {\n      lwt: 0\n    }\n  };\n  newMeta.docData = newMasterDocState;\n\n  /**\n   * Sending isResolvedConflict with the value undefined\n   * will throw a schema validation error because it must be either\n   * not set or have a string.\n   */\n  if (isResolvedConflict) {\n    newMeta.isResolvedConflict = isResolvedConflict;\n  }\n  newMeta._meta.lwt = now();\n  newMeta.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newMeta);\n  newMeta._rev = createRevision(await state.checkpointKey, previous);\n  var ret = {\n    previous,\n    document: newMeta\n  };\n  return ret;\n}\n//# sourceMappingURL=meta-instance.js.map","import { firstValueFrom, filter } from 'rxjs';\nimport { getChangedDocumentsSince, getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from \"../rx-storage-helper.js\";\nimport { appendToArray, batchArray, clone, ensureNotFalsy, getHeightOfRevision, PROMISE_RESOLVE_FALSE } from \"../plugins/utils/index.js\";\nimport { getLastCheckpointDoc, setCheckpoint } from \"./checkpoint.js\";\nimport { resolveConflictError } from \"./conflicts.js\";\nimport { stripAttachmentsDataFromMetaWriteRows, writeDocToDocState } from \"./helper.js\";\nimport { getAssumedMasterState, getMetaWriteRow } from \"./meta-instance.js\";\nimport { fillWriteDataForAttachmentsChange } from \"../plugins/attachments/index.js\";\nimport { newRxError } from \"../rx-error.js\";\n\n/**\n * Writes all document changes from the fork to the master.\n * The upstream runs on two modes:\n * - For initial replication, a checkpoint-iteration is used\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\n *   In contrast to the master, the fork can be assumed to never loose connection,\n *   so we do not have to prepare for missed out events.\n */\nexport async function startReplicationUpstream(state) {\n  if (state.input.initialCheckpoint && state.input.initialCheckpoint.upstream) {\n    var checkpointDoc = await getLastCheckpointDoc(state, 'up');\n    if (!checkpointDoc) {\n      await setCheckpoint(state, 'up', state.input.initialCheckpoint.upstream);\n    }\n  }\n  var replicationHandler = state.input.replicationHandler;\n  state.streamQueue.up = state.streamQueue.up.then(() => {\n    return upstreamInitialSync().then(() => {\n      return processTasks();\n    });\n  });\n\n  // used to detect which tasks etc can in it at which order.\n  var timer = 0;\n  var initialSyncStartTime = -1;\n  var openTasks = [];\n  var persistenceQueue = PROMISE_RESOLVE_FALSE;\n  var nonPersistedFromMaster = {\n    docs: {}\n  };\n  var sub = state.input.forkInstance.changeStream().subscribe(eventBulk => {\n    if (state.events.paused.getValue()) {\n      return;\n    }\n    state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\n    openTasks.push({\n      task: eventBulk,\n      time: timer++\n    });\n    if (!state.events.active.up.getValue()) {\n      state.events.active.up.next(true);\n    }\n    if (state.input.waitBeforePersist) {\n      return state.input.waitBeforePersist().then(() => processTasks());\n    } else {\n      return processTasks();\n    }\n  });\n  var subResync = replicationHandler.masterChangeStream$.pipe(filter(ev => ev === 'RESYNC')).subscribe(() => {\n    openTasks.push({\n      task: 'RESYNC',\n      time: timer++\n    });\n    processTasks();\n  });\n\n  // unsubscribe when replication is canceled\n  firstValueFrom(state.events.canceled.pipe(filter(canceled => !!canceled))).then(() => {\n    sub.unsubscribe();\n    subResync.unsubscribe();\n  });\n  async function upstreamInitialSync() {\n    state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\n    if (state.events.canceled.getValue()) {\n      return;\n    }\n    state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\n    var lastCheckpoint = await state.checkpointQueue;\n    var promises = new Set();\n    var _loop = async function () {\n      initialSyncStartTime = timer++;\n\n      /**\n       * Throttle the calls to\n       * forkInstance.getChangedDocumentsSince() so that\n       * if the pushing to the remote is slower compared to the\n       * pulling out of forkInstance, we do not block the UI too much\n       * and have a big memory spike with all forkInstance documents.\n       */\n      if (promises.size > 3) {\n        await Promise.race(Array.from(promises));\n      }\n      var upResult = await getChangedDocumentsSince(state.input.forkInstance, state.input.pushBatchSize, lastCheckpoint);\n      if (upResult.documents.length === 0) {\n        return 1; // break\n      }\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\n      var promise = persistToMaster(upResult.documents, ensureNotFalsy(lastCheckpoint));\n      promises.add(promise);\n      promise.catch().then(() => promises.delete(promise));\n    };\n    while (!state.events.canceled.getValue()) {\n      if (await _loop()) break;\n    }\n\n    /**\n     * If we had conflicts during the initial sync,\n     * it means that we likely have new writes to the fork\n     * and so we have to run the initial sync again to upstream these new writes.\n     */\n    var resolvedPromises = await Promise.all(promises);\n    var hadConflicts = resolvedPromises.find(r => !!r);\n    if (hadConflicts) {\n      await upstreamInitialSync();\n    } else if (!state.firstSyncDone.up.getValue() && !state.events.canceled.getValue()) {\n      state.firstSyncDone.up.next(true);\n    }\n  }\n\n  /**\n   * Takes all open tasks an processes them at once.\n   */\n  function processTasks() {\n    if (state.events.canceled.getValue() || openTasks.length === 0) {\n      state.events.active.up.next(false);\n      return;\n    }\n    state.stats.up.processTasks = state.stats.up.processTasks + 1;\n    state.events.active.up.next(true);\n    state.streamQueue.up = state.streamQueue.up.then(async () => {\n      /**\n       * Merge/filter all open tasks\n       */\n      var docs = [];\n      var checkpoint = {};\n      while (openTasks.length > 0) {\n        var taskWithTime = ensureNotFalsy(openTasks.shift());\n        /**\n         * If the task came in before the last time the initial sync fetching\n         * has run, we can ignore the task because the initial sync already processed\n         * these documents.\n         */\n        if (taskWithTime.time < initialSyncStartTime) {\n          continue;\n        }\n        if (taskWithTime.task === 'RESYNC') {\n          state.events.active.up.next(false);\n          await upstreamInitialSync();\n          return;\n        }\n\n        /**\n         * If the task came from the downstream, we can ignore these documents\n         * because we know they are replicated already.\n         * But even if they can be ignored, we later have to call persistToMaster()\n         * to have the correct checkpoint set.\n         */\n        if (taskWithTime.task.context !== (await state.downstreamBulkWriteFlag)) {\n          appendToArray(docs, taskWithTime.task.events.map(r => {\n            return r.documentData;\n          }));\n        }\n        checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\n      }\n      await persistToMaster(docs, checkpoint);\n\n      // might have got more tasks while running persistToMaster()\n      if (openTasks.length === 0) {\n        state.events.active.up.next(false);\n      } else {\n        return processTasks();\n      }\n    });\n  }\n\n  /**\n   * Returns true if had conflicts,\n   * false if not.\n   */\n  function persistToMaster(docs, checkpoint) {\n    state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\n\n    /**\n     * Add the new docs to the non-persistent list\n     */\n    docs.forEach(docData => {\n      var docId = docData[state.primaryPath];\n      nonPersistedFromMaster.docs[docId] = docData;\n    });\n    nonPersistedFromMaster.checkpoint = checkpoint;\n    persistenceQueue = persistenceQueue.then(async () => {\n      if (state.events.canceled.getValue()) {\n        return false;\n      }\n      var upDocsById = nonPersistedFromMaster.docs;\n      nonPersistedFromMaster.docs = {};\n      var useCheckpoint = nonPersistedFromMaster.checkpoint;\n      var docIds = Object.keys(upDocsById);\n      /**\n       * Even if we do not have anything to push,\n       * we still have to store the up-checkpoint.\n       * This ensures that when many documents have been pulled\n       * from the remote (that do not have to be pushed again),\n       * we continue at the correct position and do not have to load\n       * these documents from the storage again when the replication is restarted.\n       */\n      function rememberCheckpointBeforeReturn() {\n        return setCheckpoint(state, 'up', useCheckpoint);\n      }\n      ;\n      if (docIds.length === 0) {\n        rememberCheckpointBeforeReturn();\n        return false;\n      }\n      var assumedMasterState = await getAssumedMasterState(state, docIds);\n      var writeRowsToMaster = {};\n      var writeRowsToMasterIds = [];\n      var writeRowsToMeta = {};\n      var forkStateById = {};\n      await Promise.all(docIds.map(async docId => {\n        var fullDocData = upDocsById[docId];\n        forkStateById[docId] = fullDocData;\n        var docData = writeDocToDocState(fullDocData, state.hasAttachments, !!state.input.keepMeta);\n        var assumedMasterDoc = assumedMasterState[docId];\n\n        /**\n         * If the master state is equal to the\n         * fork state, we can assume that the document state is already\n         * replicated.\n         */\n        if (assumedMasterDoc &&\n        // if the isResolvedConflict is correct, we do not have to compare the documents.\n        assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev && state.input.conflictHandler.isEqual(assumedMasterDoc.docData, docData, 'upstream-check-if-equal') || (\n        /**\n         * If the master works with _rev fields,\n         * we use that to check if our current doc state\n         * is different from the assumedMasterDoc.\n         */\n\n        assumedMasterDoc && assumedMasterDoc.docData._rev && getHeightOfRevision(fullDocData._rev) === fullDocData._meta[state.input.identifier])) {\n          return;\n        }\n        writeRowsToMasterIds.push(docId);\n        writeRowsToMaster[docId] = {\n          assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n          newDocumentState: docData\n        };\n        writeRowsToMeta[docId] = await getMetaWriteRow(state, docData, assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined);\n      }));\n      if (writeRowsToMasterIds.length === 0) {\n        rememberCheckpointBeforeReturn();\n        return false;\n      }\n      var writeRowsArray = Object.values(writeRowsToMaster);\n      var conflictIds = new Set();\n      var conflictsById = {};\n\n      /**\n       * To always respect the push.batchSize,\n       * we have to split the write rows into batches\n       * to ensure that replicationHandler.masterWrite() is never\n       * called with more documents than what the batchSize limits.\n       */\n      var writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);\n      await Promise.all(writeBatches.map(async writeBatch => {\n        // enhance docs with attachments\n        if (state.hasAttachments) {\n          await Promise.all(writeBatch.map(async row => {\n            row.newDocumentState = await fillWriteDataForAttachmentsChange(state.primaryPath, state.input.forkInstance, clone(row.newDocumentState), row.assumedMasterState);\n          }));\n        }\n        var masterWriteResult = await replicationHandler.masterWrite(writeBatch);\n        masterWriteResult.forEach(conflictDoc => {\n          var id = conflictDoc[state.primaryPath];\n          conflictIds.add(id);\n          conflictsById[id] = conflictDoc;\n        });\n      }));\n      var useWriteRowsToMeta = [];\n      writeRowsToMasterIds.forEach(docId => {\n        if (!conflictIds.has(docId)) {\n          state.events.processed.up.next(writeRowsToMaster[docId]);\n          useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n        }\n      });\n      if (state.events.canceled.getValue()) {\n        return false;\n      }\n      if (useWriteRowsToMeta.length > 0) {\n        await state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useWriteRowsToMeta), 'replication-up-write-meta');\n        // TODO what happens when we have conflicts here?\n      }\n\n      /**\n       * Resolve conflicts by writing a new document\n       * state to the fork instance and the 'real' master state\n       * to the meta instance.\n       * Non-409 errors will be detected by resolveConflictError()\n       */\n      var hadConflictWrites = false;\n      if (conflictIds.size > 0) {\n        state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\n        var conflictWriteFork = [];\n        var conflictWriteMeta = {};\n        await Promise.all(Object.entries(conflictsById).map(([docId, realMasterState]) => {\n          var writeToMasterRow = writeRowsToMaster[docId];\n          var input = {\n            newDocumentState: writeToMasterRow.newDocumentState,\n            assumedMasterState: writeToMasterRow.assumedMasterState,\n            realMasterState\n          };\n          return resolveConflictError(state, input, forkStateById[docId]).then(async resolved => {\n            if (resolved) {\n              state.events.resolvedConflicts.next({\n                input,\n                output: resolved\n              });\n              conflictWriteFork.push({\n                previous: forkStateById[docId],\n                document: resolved\n              });\n              var assumedMasterDoc = assumedMasterState[docId];\n              conflictWriteMeta[docId] = await getMetaWriteRow(state, ensureNotFalsy(realMasterState), assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined, resolved._rev);\n            }\n          });\n        }));\n        if (conflictWriteFork.length > 0) {\n          hadConflictWrites = true;\n          state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\n          var forkWriteResult = await state.input.forkInstance.bulkWrite(conflictWriteFork, 'replication-up-write-conflict');\n          var mustThrow;\n          forkWriteResult.error.forEach(error => {\n            /**\n             * Conflict-Errors in the forkWriteResult must not be handled\n             * because they have been caused by a write to the forkInstance\n             * in between which will anyway trigger a new upstream cycle\n             * that will then resolved the conflict again.\n             */\n            if (error.status === 409) {\n              return;\n            }\n            // other non-conflict errors must be handled\n            var throwMe = newRxError('RC_PUSH', {\n              writeError: error\n            });\n            state.events.error.next(throwMe);\n            mustThrow = throwMe;\n          });\n          if (mustThrow) {\n            throw mustThrow;\n          }\n          var useMetaWrites = [];\n          var success = getWrittenDocumentsFromBulkWriteResponse(state.primaryPath, conflictWriteFork, forkWriteResult);\n          success.forEach(docData => {\n            var docId = docData[state.primaryPath];\n            useMetaWrites.push(conflictWriteMeta[docId]);\n          });\n          if (useMetaWrites.length > 0) {\n            await state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useMetaWrites), 'replication-up-write-conflict-meta');\n          }\n          // TODO what to do with conflicts while writing to the metaInstance?\n        }\n      }\n\n      /**\n       * For better performance we do not await checkpoint writes,\n       * but to ensure order on parallel checkpoint writes,\n       * we have to use a queue.\n       */\n      rememberCheckpointBeforeReturn();\n      return hadConflictWrites;\n    }).catch(unhandledError => {\n      state.events.error.next(unhandledError);\n      return false;\n    });\n    return persistenceQueue;\n  }\n}\n//# sourceMappingURL=upstream.js.map","/**\n * RxChangeEvents a emitted when something in the database changes\n * they can be grabbed by the observables of database, collection and document\n */\n\nimport { overwritable } from \"./overwritable.js\";\nimport { appendToArray, getFromMapOrCreate } from \"./plugins/utils/index.js\";\nexport function getDocumentDataOfRxChangeEvent(rxChangeEvent) {\n  if (rxChangeEvent.documentData) {\n    return rxChangeEvent.documentData;\n  } else {\n    return rxChangeEvent.previousDocumentData;\n  }\n}\n\n/**\n * Might return null which means an\n * already deleted document got modified but still is deleted.\n * These kind of events are not relevant for the event-reduce algorithm\n * and must be filtered out.\n */\nexport function rxChangeEventToEventReduceChangeEvent(rxChangeEvent) {\n  switch (rxChangeEvent.operation) {\n    case 'INSERT':\n      return {\n        operation: rxChangeEvent.operation,\n        id: rxChangeEvent.documentId,\n        doc: rxChangeEvent.documentData,\n        previous: null\n      };\n    case 'UPDATE':\n      return {\n        operation: rxChangeEvent.operation,\n        id: rxChangeEvent.documentId,\n        doc: overwritable.deepFreezeWhenDevMode(rxChangeEvent.documentData),\n        previous: rxChangeEvent.previousDocumentData ? rxChangeEvent.previousDocumentData : 'UNKNOWN'\n      };\n    case 'DELETE':\n      return {\n        operation: rxChangeEvent.operation,\n        id: rxChangeEvent.documentId,\n        doc: null,\n        previous: rxChangeEvent.previousDocumentData\n      };\n  }\n}\n\n/**\n * Flattens the given events into a single array of events.\n * Used mostly in tests.\n */\nexport function flattenEvents(input) {\n  var output = [];\n  if (Array.isArray(input)) {\n    input.forEach(inputItem => {\n      var add = flattenEvents(inputItem);\n      appendToArray(output, add);\n    });\n  } else {\n    if (input.id && input.events) {\n      // is bulk\n      input.events.forEach(ev => output.push(ev));\n    } else {\n      output.push(input);\n    }\n  }\n  var usedIds = new Set();\n  var nonDuplicate = [];\n  function getEventId(ev) {\n    return [ev.documentId, ev.documentData ? ev.documentData._rev : '', ev.previousDocumentData ? ev.previousDocumentData._rev : ''].join('|');\n  }\n  output.forEach(ev => {\n    var eventId = getEventId(ev);\n    if (!usedIds.has(eventId)) {\n      usedIds.add(eventId);\n      nonDuplicate.push(ev);\n    }\n  });\n  return nonDuplicate;\n}\nvar EVENT_BULK_CACHE = new Map();\nexport function rxChangeEventBulkToRxChangeEvents(eventBulk) {\n  return getFromMapOrCreate(EVENT_BULK_CACHE, eventBulk, () => {\n    var events = new Array(eventBulk.events.length);\n    var rawEvents = eventBulk.events;\n    var collectionName = eventBulk.collectionName;\n    var isLocal = eventBulk.isLocal;\n    var deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\n    for (var index = 0; index < rawEvents.length; index++) {\n      var event = rawEvents[index];\n      events[index] = {\n        documentId: event.documentId,\n        collectionName,\n        isLocal,\n        operation: event.operation,\n        documentData: deepFreezeWhenDevMode(event.documentData),\n        previousDocumentData: deepFreezeWhenDevMode(event.previousDocumentData)\n      };\n    }\n    return events;\n  });\n}\n//# sourceMappingURL=rx-change-event.js.map","import { createRevision, flatClone, getDefaultRevision, getDefaultRxDocumentMeta, now } from \"./plugins/utils/index.js\";\nimport { fillObjectWithDefaults, fillPrimaryKey } from \"./rx-schema-helper.js\";\nimport { runAsyncPluginHooks } from \"./hooks.js\";\nimport { getAllCollectionDocuments } from \"./rx-database-internal-store.js\";\nimport { flatCloneDocWithMeta } from \"./rx-storage-helper.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { newRxError } from \"./rx-error.js\";\n\n/**\n * fills in the default data.\n * This also clones the data.\n */\nexport function fillObjectDataBeforeInsert(schema, data) {\n  data = flatClone(data);\n  data = fillObjectWithDefaults(schema, data);\n  if (typeof schema.jsonSchema.primaryKey !== 'string') {\n    data = fillPrimaryKey(schema.primaryPath, schema.jsonSchema, data);\n  }\n  data._meta = getDefaultRxDocumentMeta();\n  if (!Object.prototype.hasOwnProperty.call(data, '_deleted')) {\n    data._deleted = false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(data, '_attachments')) {\n    data._attachments = {};\n  }\n  if (!Object.prototype.hasOwnProperty.call(data, '_rev')) {\n    data._rev = getDefaultRevision();\n  }\n  return data;\n}\n\n/**\n * Creates the storage instances that are used internally in the collection\n */\nexport async function createRxCollectionStorageInstance(rxDatabase, storageInstanceCreationParams) {\n  storageInstanceCreationParams.multiInstance = rxDatabase.multiInstance;\n  var storageInstance = await rxDatabase.storage.createStorageInstance(storageInstanceCreationParams);\n  return storageInstance;\n}\n\n/**\n * Removes the main storage of the collection\n * and all connected storages like the ones from the replication meta etc.\n */\nexport async function removeCollectionStorages(storage, databaseInternalStorage, databaseInstanceToken, databaseName, collectionName, multiInstance, password,\n/**\n * If no hash function is provided,\n * we assume that the whole internal store is removed anyway\n * so we do not have to delete the meta documents.\n */\nhashFunction) {\n  var allCollectionMetaDocs = await getAllCollectionDocuments(databaseInternalStorage);\n  var relevantCollectionMetaDocs = allCollectionMetaDocs.filter(metaDoc => metaDoc.data.name === collectionName);\n  var removeStorages = [];\n  relevantCollectionMetaDocs.forEach(metaDoc => {\n    removeStorages.push({\n      collectionName: metaDoc.data.name,\n      schema: metaDoc.data.schema,\n      isCollection: true\n    });\n    metaDoc.data.connectedStorages.forEach(row => removeStorages.push({\n      collectionName: row.collectionName,\n      isCollection: false,\n      schema: row.schema\n    }));\n  });\n\n  // ensure uniqueness\n  var alreadyAdded = new Set();\n  removeStorages = removeStorages.filter(row => {\n    var key = row.collectionName + '||' + row.schema.version;\n    if (alreadyAdded.has(key)) {\n      return false;\n    } else {\n      alreadyAdded.add(key);\n      return true;\n    }\n  });\n\n  // remove all the storages\n  await Promise.all(removeStorages.map(async row => {\n    var storageInstance = await storage.createStorageInstance({\n      collectionName: row.collectionName,\n      databaseInstanceToken,\n      databaseName,\n      /**\n       * multiInstance must be set to true if multiInstance\n       * was true on the database\n       * so that the storageInstance can inform other\n       * instances about being removed.\n       */\n      multiInstance,\n      options: {},\n      schema: row.schema,\n      password,\n      devMode: overwritable.isDevMode()\n    });\n    await storageInstance.remove();\n    if (row.isCollection) {\n      await runAsyncPluginHooks('postRemoveRxCollection', {\n        storage,\n        databaseName: databaseName,\n        collectionName\n      });\n    }\n  }));\n\n  // remove the meta documents\n  if (hashFunction) {\n    var writeRows = relevantCollectionMetaDocs.map(doc => {\n      var writeDoc = flatCloneDocWithMeta(doc);\n      writeDoc._deleted = true;\n      writeDoc._meta.lwt = now();\n      writeDoc._rev = createRevision(databaseInstanceToken, doc);\n      return {\n        previous: doc,\n        document: writeDoc\n      };\n    });\n    await databaseInternalStorage.bulkWrite(writeRows, 'rx-database-remove-collection-all');\n  }\n}\nexport function ensureRxCollectionIsNotClosed(collection) {\n  if (collection.closed) {\n    throw newRxError('COL21', {\n      collection: collection.name,\n      version: collection.schema.version\n    });\n  }\n}\n//# sourceMappingURL=rx-collection-helper.js.map","import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { filter, map, mergeMap } from 'rxjs';\nimport { ucfirst, flatClone, promiseSeries, pluginMissing, ensureNotFalsy, getFromMapOrThrow, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_VOID, NON_PREMIUM_COLLECTION_LIMIT, hasPremiumFlag } from \"./plugins/utils/index.js\";\nimport { fillObjectDataBeforeInsert, createRxCollectionStorageInstance, removeCollectionStorages, ensureRxCollectionIsNotClosed } from \"./rx-collection-helper.js\";\nimport { createRxQuery, _getDefaultQuery } from \"./rx-query.js\";\nimport { newRxError, newRxTypeError } from \"./rx-error.js\";\nimport { DocumentCache, mapDocumentsDataToCacheDocs } from \"./doc-cache.js\";\nimport { createQueryCache, defaultCacheReplacementPolicy } from \"./query-cache.js\";\nimport { createChangeEventBuffer } from \"./change-event-buffer.js\";\nimport { runAsyncPluginHooks, runPluginHooks } from \"./hooks.js\";\nimport { createNewRxDocument, getRxDocumentConstructor } from \"./rx-document-prototype-merge.js\";\nimport { getWrappedStorageInstance, getWrittenDocumentsFromBulkWriteResponse, throwIfIsStorageWriteError } from \"./rx-storage-helper.js\";\nimport { IncrementalWriteQueue } from \"./incremental-write.js\";\nimport { beforeDocumentUpdateWrite } from \"./rx-document.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { defaultConflictHandler } from \"./replication-protocol/default-conflict-handler.js\";\nimport { rxChangeEventBulkToRxChangeEvents } from \"./rx-change-event.js\";\nvar HOOKS_WHEN = ['pre', 'post'];\nvar HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nvar hooksApplied = false;\nexport var OPEN_COLLECTIONS = new Set();\nexport var RxCollectionBase = /*#__PURE__*/function () {\n  /**\n   * Stores all 'normal' documents\n   */\n\n  /**\n   * Before reads, all these methods are awaited. Used to \"block\" reads\n   * depending on other processes, like when the RxPipeline is running.\n   */\n\n  function RxCollectionBase(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options = {}, cacheReplacementPolicy = defaultCacheReplacementPolicy, statics = {}, conflictHandler = defaultConflictHandler) {\n    this.storageInstance = {};\n    this.timeouts = new Set();\n    this.incrementalWriteQueue = {};\n    this.awaitBeforeReads = new Set();\n    this._incrementalUpsertQueues = new Map();\n    this.synced = false;\n    this.hooks = {};\n    this._subs = [];\n    this._docCache = {};\n    this._queryCache = createQueryCache();\n    this.$ = {};\n    this.checkpoint$ = {};\n    this._changeEventBuffer = {};\n    this.eventBulks$ = {};\n    this.onClose = [];\n    this.closed = false;\n    this.onRemove = [];\n    this.database = database;\n    this.name = name;\n    this.schema = schema;\n    this.internalStorageInstance = internalStorageInstance;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.migrationStrategies = migrationStrategies;\n    this.methods = methods;\n    this.attachments = attachments;\n    this.options = options;\n    this.cacheReplacementPolicy = cacheReplacementPolicy;\n    this.statics = statics;\n    this.conflictHandler = conflictHandler;\n    _applyHookFunctions(this.asRxCollection);\n    if (database) {\n      // might be falsy on pseudoInstance\n      this.eventBulks$ = database.eventBulks$.pipe(filter(changeEventBulk => changeEventBulk.collectionName === this.name));\n    } else {}\n\n    /**\n     * Must be last because the hooks might throw on dev-mode\n     * checks and we do not want to have broken collections here.\n     * RxCollection instances created for testings do not have a database\n     * so we do not add these to the list.\n     */\n    if (this.database) {\n      OPEN_COLLECTIONS.add(this);\n    }\n  }\n  var _proto = RxCollectionBase.prototype;\n  _proto.prepare = async function prepare() {\n    if (!(await hasPremiumFlag())) {\n      /**\n       * When used in a test suite, we often open and close many databases with collections\n       * while not awaiting the database.close() call to improve the test times.\n       * So when reopening collections and the OPEN_COLLECTIONS size is full,\n       * we retry after some times to account for this.\n       */\n      var count = 0;\n      while (count < 10 && OPEN_COLLECTIONS.size > NON_PREMIUM_COLLECTION_LIMIT) {\n        count++;\n        await this.promiseWait(30);\n      }\n      if (OPEN_COLLECTIONS.size > NON_PREMIUM_COLLECTION_LIMIT) {\n        throw newRxError('COL23', {\n          database: this.database.name,\n          collection: this.name,\n          args: {\n            existing: Array.from(OPEN_COLLECTIONS.values()).map(c => ({\n              db: c.database ? c.database.name : '',\n              c: c.name\n            }))\n          }\n        });\n      }\n    }\n    this.storageInstance = getWrappedStorageInstance(this.database, this.internalStorageInstance, this.schema.jsonSchema);\n    this.incrementalWriteQueue = new IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => beforeDocumentUpdateWrite(this, newData, oldData), result => this._runHooks('post', 'save', result));\n    this.$ = this.eventBulks$.pipe(mergeMap(changeEventBulk => rxChangeEventBulkToRxChangeEvents(changeEventBulk)));\n    this.checkpoint$ = this.eventBulks$.pipe(map(changeEventBulk => changeEventBulk.checkpoint));\n    this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n    var documentConstructor;\n    this._docCache = new DocumentCache(this.schema.primaryPath, this.eventBulks$.pipe(filter(bulk => !bulk.isLocal), map(bulk => bulk.events)), docData => {\n      if (!documentConstructor) {\n        documentConstructor = getRxDocumentConstructor(this.asRxCollection);\n      }\n      return createNewRxDocument(this.asRxCollection, documentConstructor, docData);\n    });\n    var listenToRemoveSub = this.database.internalStore.changeStream().pipe(filter(bulk => {\n      var key = this.name + '-' + this.schema.version;\n      var found = bulk.events.find(event => {\n        return event.documentData.context === 'collection' && event.documentData.key === key && event.operation === 'DELETE';\n      });\n      return !!found;\n    })).subscribe(async () => {\n      await this.close();\n      await Promise.all(this.onRemove.map(fn => fn()));\n    });\n    this._subs.push(listenToRemoveSub);\n    var databaseStorageToken = await this.database.storageToken;\n    var subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n      var changeEventBulk = {\n        id: eventBulk.id,\n        isLocal: false,\n        internal: false,\n        collectionName: this.name,\n        storageToken: databaseStorageToken,\n        events: eventBulk.events,\n        databaseToken: this.database.token,\n        checkpoint: eventBulk.checkpoint,\n        context: eventBulk.context\n      };\n      this.database.$emit(changeEventBulk);\n    });\n    this._subs.push(subDocs);\n    return PROMISE_RESOLVE_VOID;\n  }\n\n  /**\n   * Manually call the cleanup function of the storage.\n   * @link https://rxdb.info/cleanup.html\n   */;\n  _proto.cleanup = function cleanup(_minimumDeletedTime) {\n    ensureRxCollectionIsNotClosed(this);\n    throw pluginMissing('cleanup');\n  }\n\n  // overwritten by migration-plugin\n  ;\n  _proto.migrationNeeded = function migrationNeeded() {\n    throw pluginMissing('migration-schema');\n  };\n  _proto.getMigrationState = function getMigrationState() {\n    throw pluginMissing('migration-schema');\n  };\n  _proto.startMigration = function startMigration(batchSize = 10) {\n    ensureRxCollectionIsNotClosed(this);\n    return this.getMigrationState().startMigration(batchSize);\n  };\n  _proto.migratePromise = function migratePromise(batchSize = 10) {\n    return this.getMigrationState().migratePromise(batchSize);\n  };\n  _proto.insert = async function insert(json) {\n    ensureRxCollectionIsNotClosed(this);\n    var writeResult = await this.bulkInsert([json]);\n    var isError = writeResult.error[0];\n    throwIfIsStorageWriteError(this, json[this.schema.primaryPath], json, isError);\n    var insertResult = ensureNotFalsy(writeResult.success[0]);\n    return insertResult;\n  };\n  _proto.insertIfNotExists = async function insertIfNotExists(json) {\n    var writeResult = await this.bulkInsert([json]);\n    if (writeResult.error.length > 0) {\n      var error = writeResult.error[0];\n      if (error.status === 409) {\n        var conflictDocData = error.documentInDb;\n        return mapDocumentsDataToCacheDocs(this._docCache, [conflictDocData])[0];\n      } else {\n        throw error;\n      }\n    }\n    return writeResult.success[0];\n  };\n  _proto.bulkInsert = async function bulkInsert(docsData) {\n    ensureRxCollectionIsNotClosed(this);\n    /**\n     * Optimization shortcut,\n     * do nothing when called with an empty array\n    */\n    if (docsData.length === 0) {\n      return {\n        success: [],\n        error: []\n      };\n    }\n    var primaryPath = this.schema.primaryPath;\n    var ids = new Set();\n\n    /**\n     * This code is a bit redundant for better performance.\n     * Instead of iterating multiple times,\n     * we directly transform the input to a write-row array.\n     */\n    var insertRows;\n    if (this.hasHooks('pre', 'insert')) {\n      insertRows = await Promise.all(docsData.map(docData => {\n        var useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n        return this._runHooks('pre', 'insert', useDocData).then(() => {\n          ids.add(useDocData[primaryPath]);\n          return {\n            document: useDocData\n          };\n        });\n      }));\n    } else {\n      insertRows = new Array(docsData.length);\n      var _schema = this.schema;\n      for (var index = 0; index < docsData.length; index++) {\n        var docData = docsData[index];\n        var useDocData = fillObjectDataBeforeInsert(_schema, docData);\n        ids.add(useDocData[primaryPath]);\n        insertRows[index] = {\n          document: useDocData\n        };\n      }\n    }\n    if (ids.size !== docsData.length) {\n      throw newRxError('COL22', {\n        collection: this.name,\n        args: {\n          documents: docsData\n        }\n      });\n    }\n    var results = await this.storageInstance.bulkWrite(insertRows, 'rx-collection-bulk-insert');\n\n    /**\n     * Often the user does not need to access the RxDocuments of the bulkInsert() call.\n     * So we transform the data to RxDocuments only if needed to use less CPU performance.\n     */\n    var rxDocuments;\n    var collection = this;\n    var ret = {\n      get success() {\n        if (!rxDocuments) {\n          var success = getWrittenDocumentsFromBulkWriteResponse(collection.schema.primaryPath, insertRows, results);\n          rxDocuments = mapDocumentsDataToCacheDocs(collection._docCache, success);\n        }\n        return rxDocuments;\n      },\n      error: results.error\n    };\n    if (this.hasHooks('post', 'insert')) {\n      var docsMap = new Map();\n      insertRows.forEach(row => {\n        var doc = row.document;\n        docsMap.set(doc[primaryPath], doc);\n      });\n      await Promise.all(ret.success.map(doc => {\n        return this._runHooks('post', 'insert', docsMap.get(doc.primary), doc);\n      }));\n    }\n    return ret;\n  };\n  _proto.bulkRemove = async function bulkRemove(\n  /**\n   * You can either remove the documents by their ids\n   * or by directly providing the RxDocument instances\n   * if you have them already. This improves performance a bit.\n   */\n  idsOrDocs) {\n    ensureRxCollectionIsNotClosed(this);\n    var primaryPath = this.schema.primaryPath;\n    /**\n     * Optimization shortcut,\n     * do nothing when called with an empty array\n     */\n    if (idsOrDocs.length === 0) {\n      return {\n        success: [],\n        error: []\n      };\n    }\n    var rxDocumentMap;\n    if (typeof idsOrDocs[0] === 'string') {\n      rxDocumentMap = await this.findByIds(idsOrDocs).exec();\n    } else {\n      rxDocumentMap = new Map();\n      idsOrDocs.forEach(d => rxDocumentMap.set(d.primary, d));\n    }\n    var docsData = [];\n    var docsMap = new Map();\n    Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n      var data = rxDocument.toMutableJSON(true);\n      docsData.push(data);\n      docsMap.set(rxDocument.primary, data);\n    });\n    await Promise.all(docsData.map(doc => {\n      var primary = doc[this.schema.primaryPath];\n      return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n    }));\n    var removeDocs = docsData.map(doc => {\n      var writeDoc = flatClone(doc);\n      writeDoc._deleted = true;\n      return {\n        previous: doc,\n        document: writeDoc\n      };\n    });\n    var results = await this.storageInstance.bulkWrite(removeDocs, 'rx-collection-bulk-remove');\n    var success = getWrittenDocumentsFromBulkWriteResponse(this.schema.primaryPath, removeDocs, results);\n    var deletedRxDocuments = [];\n    var successIds = success.map(d => {\n      var id = d[primaryPath];\n      var doc = this._docCache.getCachedRxDocument(d);\n      deletedRxDocuments.push(doc);\n      return id;\n    });\n\n    // run hooks\n    await Promise.all(successIds.map(id => {\n      return this._runHooks('post', 'remove', docsMap.get(id), rxDocumentMap.get(id));\n    }));\n    return {\n      success: deletedRxDocuments,\n      error: results.error\n    };\n  }\n\n  /**\n   * same as bulkInsert but overwrites existing document with same primary\n   */;\n  _proto.bulkUpsert = async function bulkUpsert(docsData) {\n    ensureRxCollectionIsNotClosed(this);\n    var insertData = [];\n    var useJsonByDocId = new Map();\n    docsData.forEach(docData => {\n      var useJson = fillObjectDataBeforeInsert(this.schema, docData);\n      var primary = useJson[this.schema.primaryPath];\n      if (!primary) {\n        throw newRxError('COL3', {\n          primaryPath: this.schema.primaryPath,\n          data: useJson,\n          schema: this.schema.jsonSchema\n        });\n      }\n      useJsonByDocId.set(primary, useJson);\n      insertData.push(useJson);\n    });\n    var insertResult = await this.bulkInsert(insertData);\n    var success = insertResult.success.slice(0);\n    var error = [];\n\n    // update the ones that existed already\n    await Promise.all(insertResult.error.map(async err => {\n      if (err.status !== 409) {\n        error.push(err);\n      } else {\n        var id = err.documentId;\n        var writeData = getFromMapOrThrow(useJsonByDocId, id);\n        var docDataInDb = ensureNotFalsy(err.documentInDb);\n        var doc = this._docCache.getCachedRxDocuments([docDataInDb])[0];\n        var newDoc = await doc.incrementalModify(() => writeData);\n        success.push(newDoc);\n      }\n    }));\n    return {\n      error,\n      success\n    };\n  }\n\n  /**\n   * same as insert but overwrites existing document with same primary\n   */;\n  _proto.upsert = async function upsert(json) {\n    ensureRxCollectionIsNotClosed(this);\n    var bulkResult = await this.bulkUpsert([json]);\n    throwIfIsStorageWriteError(this.asRxCollection, json[this.schema.primaryPath], json, bulkResult.error[0]);\n    return bulkResult.success[0];\n  }\n\n  /**\n   * upserts to a RxDocument, uses incrementalModify if document already exists\n   */;\n  _proto.incrementalUpsert = function incrementalUpsert(json) {\n    ensureRxCollectionIsNotClosed(this);\n    var useJson = fillObjectDataBeforeInsert(this.schema, json);\n    var primary = useJson[this.schema.primaryPath];\n    if (!primary) {\n      throw newRxError('COL4', {\n        data: json\n      });\n    }\n\n    // ensure that it won't try 2 parallel runs\n    var queue = this._incrementalUpsertQueues.get(primary);\n    if (!queue) {\n      queue = PROMISE_RESOLVE_VOID;\n    }\n    queue = queue.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then(wasInserted => {\n      if (!wasInserted.inserted) {\n        return _incrementalUpsertUpdate(wasInserted.doc, useJson);\n      } else {\n        return wasInserted.doc;\n      }\n    });\n    this._incrementalUpsertQueues.set(primary, queue);\n    return queue;\n  };\n  _proto.find = function find(queryObj) {\n    ensureRxCollectionIsNotClosed(this);\n    runPluginHooks('prePrepareRxQuery', {\n      op: 'find',\n      queryObj,\n      collection: this\n    });\n    if (!queryObj) {\n      queryObj = _getDefaultQuery();\n    }\n    var query = createRxQuery('find', queryObj, this);\n    return query;\n  };\n  _proto.findOne = function findOne(queryObj) {\n    ensureRxCollectionIsNotClosed(this);\n    runPluginHooks('prePrepareRxQuery', {\n      op: 'findOne',\n      queryObj,\n      collection: this\n    });\n    var query;\n    if (typeof queryObj === 'string') {\n      query = createRxQuery('findOne', {\n        selector: {\n          [this.schema.primaryPath]: queryObj\n        },\n        limit: 1\n      }, this);\n    } else {\n      if (!queryObj) {\n        queryObj = _getDefaultQuery();\n      }\n\n      // cannot have limit on findOne queries because it will be overwritten\n      if (queryObj.limit) {\n        throw newRxError('QU6');\n      }\n      queryObj = flatClone(queryObj);\n      queryObj.limit = 1;\n      query = createRxQuery('findOne', queryObj, this);\n    }\n    return query;\n  };\n  _proto.count = function count(queryObj) {\n    ensureRxCollectionIsNotClosed(this);\n    if (!queryObj) {\n      queryObj = _getDefaultQuery();\n    }\n    var query = createRxQuery('count', queryObj, this);\n    return query;\n  }\n\n  /**\n   * find a list documents by their primary key\n   * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n   */;\n  _proto.findByIds = function findByIds(ids) {\n    ensureRxCollectionIsNotClosed(this);\n    var mangoQuery = {\n      selector: {\n        [this.schema.primaryPath]: {\n          $in: ids.slice(0)\n        }\n      }\n    };\n    var query = createRxQuery('findByIds', mangoQuery, this);\n    return query;\n  }\n\n  /**\n   * Export collection to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON() {\n    throw pluginMissing('json-dump');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.insertCRDT = function insertCRDT(_updateObj) {\n    throw pluginMissing('crdt');\n  };\n  _proto.addPipeline = function addPipeline(_options) {\n    throw pluginMissing('pipeline');\n  }\n\n  /**\n   * HOOKS\n   */;\n  _proto.addHook = function addHook(when, key, fun, parallel = false) {\n    if (typeof fun !== 'function') {\n      throw newRxTypeError('COL7', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_WHEN.includes(when)) {\n      throw newRxTypeError('COL8', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_KEYS.includes(key)) {\n      throw newRxError('COL9', {\n        key\n      });\n    }\n    if (when === 'post' && key === 'create' && parallel === true) {\n      throw newRxError('COL10', {\n        when,\n        key,\n        parallel\n      });\n    }\n\n    // bind this-scope to hook-function\n    var boundFun = fun.bind(this);\n    var runName = parallel ? 'parallel' : 'series';\n    this.hooks[key] = this.hooks[key] || {};\n    this.hooks[key][when] = this.hooks[key][when] || {\n      series: [],\n      parallel: []\n    };\n    this.hooks[key][when][runName].push(boundFun);\n  };\n  _proto.getHooks = function getHooks(when, key) {\n    if (!this.hooks[key] || !this.hooks[key][when]) {\n      return {\n        series: [],\n        parallel: []\n      };\n    }\n    return this.hooks[key][when];\n  };\n  _proto.hasHooks = function hasHooks(when, key) {\n    /**\n     * Performance shortcut\n     * so that we not have to build the empty object.\n     */\n    if (!this.hooks[key] || !this.hooks[key][when]) {\n      return false;\n    }\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return false;\n    }\n    return hooks.series.length > 0 || hooks.parallel.length > 0;\n  };\n  _proto._runHooks = function _runHooks(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return PROMISE_RESOLVE_VOID;\n    }\n\n    // run parallel: false\n    var tasks = hooks.series.map(hook => () => hook(data, instance));\n    return promiseSeries(tasks)\n    // run parallel: true\n    .then(() => Promise.all(hooks.parallel.map(hook => hook(data, instance))));\n  }\n\n  /**\n   * does the same as ._runHooks() but with non-async-functions\n   */;\n  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {\n    if (!this.hasHooks(when, key)) {\n      return;\n    }\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return;\n    hooks.series.forEach(hook => hook(data, instance));\n  }\n\n  /**\n   * Returns a promise that resolves after the given time.\n   * Ensures that is properly cleans up when the collection is closed\n   * so that no running timeouts prevent the exit of the JavaScript process.\n   */;\n  _proto.promiseWait = function promiseWait(time) {\n    var ret = new Promise(res => {\n      var timeout = setTimeout(() => {\n        this.timeouts.delete(timeout);\n        res();\n      }, time);\n      this.timeouts.add(timeout);\n    });\n    return ret;\n  };\n  _proto.close = async function close() {\n    if (this.closed) {\n      return PROMISE_RESOLVE_FALSE;\n    }\n    OPEN_COLLECTIONS.delete(this);\n    await Promise.all(this.onClose.map(fn => fn()));\n\n    /**\n     * Settings closed = true\n     * must be the first thing to do,\n     * so for example the replication can directly stop\n     * instead of sending requests to a closed storage.\n     */\n    this.closed = true;\n    Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n    if (this._changeEventBuffer) {\n      this._changeEventBuffer.close();\n    }\n    /**\n     * First wait until the whole database is idle.\n     * This ensures that the storage does not get closed\n     * while some operation is running.\n     * It is important that we do not intercept a running call\n     * because it might lead to undefined behavior like when a doc is written\n     * but the change is not added to the changes collection.\n     */\n    return this.database.requestIdlePromise().then(() => this.storageInstance.close()).then(() => {\n      /**\n       * Unsubscribing must be done AFTER the storageInstance.close()\n       * Because the conflict handling is part of the subscriptions and\n       * otherwise there might be open conflicts to be resolved which\n       * will then stuck and never resolve.\n       */\n      this._subs.forEach(sub => sub.unsubscribe());\n      delete this.database.collections[this.name];\n      return runAsyncPluginHooks('postCloseRxCollection', this).then(() => true);\n    });\n  }\n\n  /**\n   * remove all data of the collection\n   */;\n  _proto.remove = async function remove() {\n    await this.close();\n    await Promise.all(this.onRemove.map(fn => fn()));\n    /**\n     * TODO here we should pass the already existing\n     * storage instances instead of creating new ones.\n     */\n    await removeCollectionStorages(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.multiInstance, this.database.password, this.database.hashFunction);\n  };\n  return _createClass(RxCollectionBase, [{\n    key: \"insert$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'INSERT'));\n    }\n  }, {\n    key: \"update$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'UPDATE'));\n    }\n  }, {\n    key: \"remove$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'DELETE'));\n    }\n\n    // defaults\n\n    /**\n     * Internally only use eventBulks$\n     * Do not use .$ or .observable$ because that has to transform\n     * the events which decreases performance.\n     */\n\n    /**\n     * When the collection is closed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n    */\n  }, {\n    key: \"asRxCollection\",\n    get: function () {\n      return this;\n    }\n  }]);\n}();\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(collection) {\n  if (hooksApplied) return; // already run\n  hooksApplied = true;\n  var colProto = Object.getPrototypeOf(collection);\n  HOOKS_KEYS.forEach(key => {\n    HOOKS_WHEN.map(when => {\n      var fnName = when + ucfirst(key);\n      colProto[fnName] = function (fun, parallel) {\n        return this.addHook(when, key, fun, parallel);\n      };\n    });\n  });\n}\nfunction _incrementalUpsertUpdate(doc, json) {\n  return doc.incrementalModify(_innerDoc => {\n    return json;\n  });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _incrementalUpsertEnsureRxDocumentExists(rxCollection, primary, json) {\n  /**\n   * Optimisation shortcut,\n   * first try to find the document in the doc-cache\n   */\n  var docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);\n  if (docDataFromCache) {\n    return Promise.resolve({\n      doc: rxCollection._docCache.getCachedRxDocuments([docDataFromCache])[0],\n      inserted: false\n    });\n  }\n  return rxCollection.findOne(primary).exec().then(doc => {\n    if (!doc) {\n      return rxCollection.insert(json).then(newDoc => ({\n        doc: newDoc,\n        inserted: true\n      }));\n    } else {\n      return {\n        doc,\n        inserted: false\n      };\n    }\n  });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection({\n  database,\n  name,\n  schema,\n  instanceCreationOptions = {},\n  migrationStrategies = {},\n  autoMigrate = true,\n  statics = {},\n  methods = {},\n  attachments = {},\n  options = {},\n  localDocuments = false,\n  cacheReplacementPolicy = defaultCacheReplacementPolicy,\n  conflictHandler = defaultConflictHandler\n}) {\n  var storageInstanceCreationParams = {\n    databaseInstanceToken: database.token,\n    databaseName: database.name,\n    collectionName: name,\n    schema: schema.jsonSchema,\n    options: instanceCreationOptions,\n    multiInstance: database.multiInstance,\n    password: database.password,\n    devMode: overwritable.isDevMode()\n  };\n  runPluginHooks('preCreateRxStorageInstance', storageInstanceCreationParams);\n  return createRxCollectionStorageInstance(database, storageInstanceCreationParams).then(storageInstance => {\n    var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics, conflictHandler);\n    return collection.prepare().then(() => {\n      // ORM add statics\n      Object.entries(statics).forEach(([funName, fun]) => {\n        Object.defineProperty(collection, funName, {\n          get: () => fun.bind(collection)\n        });\n      });\n      var ret = PROMISE_RESOLVE_VOID;\n      if (autoMigrate && collection.schema.version !== 0) {\n        ret = collection.migratePromise();\n      }\n      return ret;\n    }).then(() => {\n      runPluginHooks('createRxCollection', {\n        collection,\n        creator: {\n          name,\n          schema,\n          storageInstance,\n          instanceCreationOptions,\n          migrationStrategies,\n          methods,\n          attachments,\n          options,\n          cacheReplacementPolicy,\n          localDocuments,\n          statics\n        }\n      });\n      return collection;\n    })\n    /**\n     * If the collection creation fails,\n     * we yet have to close the storage instances.\n     */.catch(err => {\n      OPEN_COLLECTIONS.delete(collection);\n      return storageInstance.close().then(() => Promise.reject(err));\n    });\n  });\n}\nexport function isRxCollection(obj) {\n  return obj instanceof RxCollectionBase;\n}\n//# sourceMappingURL=rx-collection.js.map","import { isBulkWriteConflictError, newRxError } from \"./rx-error.js\";\nimport { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData } from \"./rx-schema-helper.js\";\nimport { getSingleDocument, getWrittenDocumentsFromBulkWriteResponse, writeSingle } from \"./rx-storage-helper.js\";\nimport { clone, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, randomToken } from \"./plugins/utils/index.js\";\nimport { prepareQuery } from \"./rx-query-helper.js\";\nexport var INTERNAL_CONTEXT_COLLECTION = 'collection';\nexport var INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';\nexport var INTERNAL_CONTEXT_MIGRATION_STATUS = 'rx-migration-status';\nexport var INTERNAL_CONTEXT_PIPELINE_CHECKPOINT = 'rx-pipeline-checkpoint';\n\n/**\n * Do not change the title,\n * we have to flag the internal schema so that\n * some RxStorage implementations are able\n * to detect if the created RxStorageInstance\n * is from the internals or not,\n * to do some optimizations in some cases.\n */\nexport var INTERNAL_STORE_SCHEMA_TITLE = 'RxInternalDocument';\nexport var INTERNAL_STORE_SCHEMA = fillWithDefaultSettings({\n  version: 0,\n  title: INTERNAL_STORE_SCHEMA_TITLE,\n  primaryKey: {\n    key: 'id',\n    fields: ['context', 'key'],\n    separator: '|'\n  },\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string',\n      maxLength: 200\n    },\n    key: {\n      type: 'string'\n    },\n    context: {\n      type: 'string',\n      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, INTERNAL_CONTEXT_MIGRATION_STATUS, INTERNAL_CONTEXT_PIPELINE_CHECKPOINT, 'OTHER']\n    },\n    data: {\n      type: 'object',\n      additionalProperties: true\n    }\n  },\n  indexes: [],\n  required: ['key', 'context', 'data'],\n  additionalProperties: false,\n  /**\n   * If the sharding plugin is used,\n   * it must not shard on the internal RxStorageInstance\n   * because that one anyway has only a small amount of documents\n   * and also its creation is in the hot path of the initial page load,\n   * so we should spend less time creating multiple RxStorageInstances.\n   */\n  sharding: {\n    shards: 1,\n    mode: 'collection'\n  }\n});\nexport function getPrimaryKeyOfInternalDocument(key, context) {\n  return getComposedPrimaryKeyOfDocumentData(INTERNAL_STORE_SCHEMA, {\n    key,\n    context\n  });\n}\n\n/**\n * Returns all internal documents\n * with context 'collection'\n */\nexport async function getAllCollectionDocuments(storageInstance) {\n  var getAllQueryPrepared = prepareQuery(storageInstance.schema, {\n    selector: {\n      context: INTERNAL_CONTEXT_COLLECTION,\n      _deleted: {\n        $eq: false\n      }\n    },\n    sort: [{\n      id: 'asc'\n    }],\n    skip: 0\n  });\n  var queryResult = await storageInstance.query(getAllQueryPrepared);\n  var allDocs = queryResult.documents;\n  return allDocs;\n}\n\n/**\n * to not confuse multiInstance-messages with other databases that have the same\n * name and adapter, but do not share state with this one (for example in-memory-instances),\n * we set a storage-token and use it in the broadcast-channel\n */\nexport var STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';\nexport var STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);\nexport async function ensureStorageTokenDocumentExists(rxDatabase) {\n  /**\n   * To have less read-write cycles,\n   * we just try to insert a new document\n   * and only fetch the existing one if a conflict happened.\n   */\n  var storageToken = randomToken(10);\n  var passwordHash = rxDatabase.password ? await rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) : undefined;\n  var docData = {\n    id: STORAGE_TOKEN_DOCUMENT_ID,\n    context: INTERNAL_CONTEXT_STORAGE_TOKEN,\n    key: STORAGE_TOKEN_DOCUMENT_KEY,\n    data: {\n      rxdbVersion: rxDatabase.rxdbVersion,\n      token: storageToken,\n      /**\n       * We add the instance token here\n       * to be able to detect if a given RxDatabase instance\n       * is the first instance that was ever created\n       * or if databases have existed earlier on that storage\n       * with the same database name.\n       */\n      instanceToken: rxDatabase.token,\n      passwordHash\n    },\n    _deleted: false,\n    _meta: getDefaultRxDocumentMeta(),\n    _rev: getDefaultRevision(),\n    _attachments: {}\n  };\n  var writeRows = [{\n    document: docData\n  }];\n  var writeResult = await rxDatabase.internalStore.bulkWrite(writeRows, 'internal-add-storage-token');\n  if (!writeResult.error[0]) {\n    return getWrittenDocumentsFromBulkWriteResponse('id', writeRows, writeResult)[0];\n  }\n\n  /**\n   * If we get a 409 error,\n   * it means another instance already inserted the storage token.\n   * So we get that token from the database and return that one.\n   */\n  var error = ensureNotFalsy(writeResult.error[0]);\n  if (error.isError && isBulkWriteConflictError(error)) {\n    var conflictError = error;\n    if (!isDatabaseStateVersionCompatibleWithDatabaseCode(conflictError.documentInDb.data.rxdbVersion, rxDatabase.rxdbVersion)) {\n      throw newRxError('DM5', {\n        args: {\n          database: rxDatabase.name,\n          databaseStateVersion: conflictError.documentInDb.data.rxdbVersion,\n          codeVersion: rxDatabase.rxdbVersion\n        }\n      });\n    }\n    if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {\n      throw newRxError('DB1', {\n        passwordHash,\n        existingPasswordHash: conflictError.documentInDb.data.passwordHash\n      });\n    }\n    var storageTokenDocInDb = conflictError.documentInDb;\n    return ensureNotFalsy(storageTokenDocInDb);\n  }\n  throw error;\n}\nexport function isDatabaseStateVersionCompatibleWithDatabaseCode(databaseStateVersion, codeVersion) {\n  if (!databaseStateVersion) {\n    return false;\n  }\n  var stateMajor = databaseStateVersion.split('.')[0];\n  var codeMajor = codeVersion.split('.')[0];\n\n  /**\n   * Version v15 data must be upwards compatible to v16\n   */\n  if (stateMajor === '15' && codeMajor === '16') {\n    return true;\n  }\n  if (stateMajor !== codeMajor) {\n    return false;\n  }\n  return true;\n}\nexport async function addConnectedStorageToCollection(collection, storageCollectionName, schema) {\n  if (collection.schema.version !== schema.version) {\n    throw newRxError('SNH', {\n      schema,\n      version: collection.schema.version,\n      name: collection.name,\n      collection,\n      args: {\n        storageCollectionName\n      }\n    });\n  }\n  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);\n  while (true) {\n    var collectionDoc = await getSingleDocument(collection.database.internalStore, collectionDocId);\n    var saveData = clone(ensureNotFalsy(collectionDoc));\n\n    // do nothing if already in array\n    var alreadyThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n    if (alreadyThere) {\n      return;\n    }\n\n    // otherwise add to array and save\n    saveData.data.connectedStorages.push({\n      collectionName: storageCollectionName,\n      schema\n    });\n    try {\n      await writeSingle(collection.database.internalStore, {\n        previous: ensureNotFalsy(collectionDoc),\n        document: saveData\n      }, 'add-connected-storage-to-collection');\n    } catch (err) {\n      if (!isBulkWriteConflictError(err)) {\n        throw err;\n      }\n      // retry on conflict\n    }\n  }\n}\nexport async function removeConnectedStorageFromCollection(collection, storageCollectionName, schema) {\n  if (collection.schema.version !== schema.version) {\n    throw newRxError('SNH', {\n      schema,\n      version: collection.schema.version,\n      name: collection.name,\n      collection,\n      args: {\n        storageCollectionName\n      }\n    });\n  }\n  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);\n  while (true) {\n    var collectionDoc = await getSingleDocument(collection.database.internalStore, collectionDocId);\n    var saveData = clone(ensureNotFalsy(collectionDoc));\n\n    // do nothing if not there\n    var isThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n    if (!isThere) {\n      return;\n    }\n\n    // otherwise remove from array and save\n    saveData.data.connectedStorages = saveData.data.connectedStorages.filter(item => item.collectionName !== storageCollectionName);\n    try {\n      await writeSingle(collection.database.internalStore, {\n        previous: ensureNotFalsy(collectionDoc),\n        document: saveData\n      }, 'remove-connected-storage-from-collection');\n    } catch (err) {\n      if (!isBulkWriteConflictError(err)) {\n        throw err;\n      }\n      // retry on conflict\n    }\n  }\n}\n\n/**\n * returns the primary for a given collection-data\n * used in the internal store of a RxDatabase\n */\nexport function _collectionNamePrimary(name, schema) {\n  return name + '-' + schema.version;\n}\n//# sourceMappingURL=rx-database-internal-store.js.map","import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { IdleQueue } from 'custom-idle-queue';\nimport { ObliviousSet } from 'oblivious-set';\nimport { pluginMissing, flatClone, PROMISE_RESOLVE_FALSE, randomToken, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, defaultHashSha256, RXDB_VERSION } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { createRxSchema } from \"./rx-schema.js\";\nimport { runPluginHooks, runAsyncPluginHooks } from \"./hooks.js\";\nimport { Subject } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\nimport { createRxCollection } from \"./rx-collection.js\";\nimport { flatCloneDocWithMeta, getSingleDocument, getWrappedStorageInstance, INTERNAL_STORAGE_NAME } from \"./rx-storage-helper.js\";\nimport { ensureStorageTokenDocumentExists, getAllCollectionDocuments, getPrimaryKeyOfInternalDocument, INTERNAL_CONTEXT_COLLECTION, INTERNAL_STORE_SCHEMA, _collectionNamePrimary } from \"./rx-database-internal-store.js\";\nimport { removeCollectionStorages } from \"./rx-collection-helper.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { rxChangeEventBulkToRxChangeEvents } from \"./rx-change-event.js\";\n\n/**\n * stores the used database names+storage names\n * so we can throw when the same database is created more then once.\n */\nvar USED_DATABASE_NAMES = new Set();\nvar DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP = new Map();\nvar DB_COUNT = 0;\nexport var RxDatabaseBase = /*#__PURE__*/function () {\n  /**\n   * Contains all known non-closed storage instances\n   * that belong to this database.\n   * Used in plugins and unit tests.\n   */\n\n  function RxDatabaseBase(name,\n  /**\n   * Uniquely identifies the instance\n   * of this RxDatabase.\n   */\n  token, storage, instanceCreationOptions, password, multiInstance, eventReduce = false, options = {},\n  /**\n   * Stores information documents about the collections of the database\n   */\n  internalStore, hashFunction, cleanupPolicy, allowSlowCount, reactivity, onClosed) {\n    this.idleQueue = new IdleQueue();\n    this.rxdbVersion = RXDB_VERSION;\n    this.storageInstances = new Set();\n    this._subs = [];\n    this.startupErrors = [];\n    this.onClose = [];\n    this.closed = false;\n    this.collections = {};\n    this.states = {};\n    this.eventBulks$ = new Subject();\n    this.closePromise = null;\n    this.observable$ = this.eventBulks$.pipe(mergeMap(changeEventBulk => rxChangeEventBulkToRxChangeEvents(changeEventBulk)));\n    this.storageToken = PROMISE_RESOLVE_FALSE;\n    this.storageTokenDocument = PROMISE_RESOLVE_FALSE;\n    this.emittedEventBulkIds = new ObliviousSet(60 * 1000);\n    this.name = name;\n    this.token = token;\n    this.storage = storage;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.password = password;\n    this.multiInstance = multiInstance;\n    this.eventReduce = eventReduce;\n    this.options = options;\n    this.internalStore = internalStore;\n    this.hashFunction = hashFunction;\n    this.cleanupPolicy = cleanupPolicy;\n    this.allowSlowCount = allowSlowCount;\n    this.reactivity = reactivity;\n    this.onClosed = onClosed;\n    DB_COUNT++;\n\n    /**\n     * In the dev-mode, we create a pseudoInstance\n     * to get all properties of RxDatabase and ensure they do not\n     * conflict with the collection names etc.\n     * So only if it is not pseudoInstance,\n     * we have all values to prepare a real RxDatabase.\n     *\n     * TODO this is ugly, we should use a different way in the dev-mode\n     * so that all non-dev-mode code can be cleaner.\n     */\n    if (this.name !== 'pseudoInstance') {\n      /**\n       * Wrap the internal store\n       * to ensure that calls to it also end up in\n       * calculation of the idle state and the hooks.\n       */\n      this.internalStore = getWrappedStorageInstance(this.asRxDatabase, internalStore, INTERNAL_STORE_SCHEMA);\n\n      /**\n       * Start writing the storage token.\n       * Do not await the creation because it would run\n       * in a critical path that increases startup time.\n       *\n       * Writing the token takes about 20 milliseconds\n       * even on a fast adapter, so this is worth it.\n       */\n      this.storageTokenDocument = ensureStorageTokenDocumentExists(this.asRxDatabase).catch(err => this.startupErrors.push(err));\n      this.storageToken = this.storageTokenDocument.then(doc => doc.data.token).catch(err => this.startupErrors.push(err));\n    }\n  }\n  var _proto = RxDatabaseBase.prototype;\n  _proto.getReactivityFactory = function getReactivityFactory() {\n    if (!this.reactivity) {\n      throw newRxError('DB14', {\n        database: this.name\n      });\n    }\n    return this.reactivity;\n  }\n\n  /**\n   * Because having unhandled exceptions would fail,\n   * we have to store the async errors of the constructor here\n   * so we can throw them later.\n   */\n\n  /**\n   * When the database is closed,\n   * these functions will be called an awaited.\n   * Used to automatically clean up stuff that\n   * belongs to this collection.\n   */\n\n  /**\n   * Internally only use eventBulks$\n   * Do not use .$ or .observable$ because that has to transform\n   * the events which decreases performance.\n   */\n\n  /**\n   * Unique token that is stored with the data.\n   * Used to detect if the dataset has been deleted\n   * and if two RxDatabase instances work on the same dataset or not.\n   *\n   * Because reading and writing the storageToken runs in the hot path\n   * of database creation, we do not await the storageWrites but instead\n   * work with the promise when we need the value.\n   */\n\n  /**\n   * Stores the whole state of the internal storage token document.\n   * We need this in some plugins.\n   */\n\n  /**\n   * Contains the ids of all event bulks that have been emitted\n   * by the database.\n   * Used to detect duplicates that come in again via BroadcastChannel\n   * or other streams.\n   * In the past we tried to remove this and to ensure\n   * all storages only emit the same event bulks only once\n   * but it turns out this is just not possible for all storages.\n   * JavaScript processes, workers and browser tabs can be closed and started at any time\n   * which can cause cases where it is not possible to know if an event bulk has been emitted already.\n   */;\n  /**\n   * This is the main handle-point for all change events\n   * ChangeEvents created by this instance go:\n   * RxDocument -> RxCollection -> RxDatabase.$emit -> MultiInstance\n   * ChangeEvents created by other instances go:\n   * MultiInstance -> RxDatabase.$emit -> RxCollection -> RxDatabase\n   */\n  _proto.$emit = function $emit(changeEventBulk) {\n    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {\n      return;\n    }\n    this.emittedEventBulkIds.add(changeEventBulk.id);\n    this.eventBulks$.next(changeEventBulk);\n  }\n\n  /**\n   * removes the collection-doc from the internalStore\n   */;\n  _proto.removeCollectionDoc = async function removeCollectionDoc(name, schema) {\n    var doc = await getSingleDocument(this.internalStore, getPrimaryKeyOfInternalDocument(_collectionNamePrimary(name, schema), INTERNAL_CONTEXT_COLLECTION));\n    if (!doc) {\n      throw newRxError('SNH', {\n        name,\n        schema\n      });\n    }\n    var writeDoc = flatCloneDocWithMeta(doc);\n    writeDoc._deleted = true;\n    await this.internalStore.bulkWrite([{\n      document: writeDoc,\n      previous: doc\n    }], 'rx-database-remove-collection');\n  }\n\n  /**\n   * creates multiple RxCollections at once\n   * to be much faster by saving db txs and doing stuff in bulk-operations\n   * This function is not called often, but mostly in the critical path at the initial page load\n   * So it must be as fast as possible.\n   */;\n  _proto.addCollections = async function addCollections(collectionCreators) {\n    var jsonSchemas = {};\n    var schemas = {};\n    var bulkPutDocs = [];\n    var useArgsByCollectionName = {};\n    await Promise.all(Object.entries(collectionCreators).map(async ([name, args]) => {\n      var collectionName = name;\n      var rxJsonSchema = args.schema;\n      jsonSchemas[collectionName] = rxJsonSchema;\n      var schema = createRxSchema(rxJsonSchema, this.hashFunction);\n      schemas[collectionName] = schema;\n\n      // collection already exists\n      if (this.collections[name]) {\n        throw newRxError('DB3', {\n          name\n        });\n      }\n      var collectionNameWithVersion = _collectionNamePrimary(name, rxJsonSchema);\n      var collectionDocData = {\n        id: getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION),\n        key: collectionNameWithVersion,\n        context: INTERNAL_CONTEXT_COLLECTION,\n        data: {\n          name: collectionName,\n          schemaHash: await schema.hash,\n          schema: schema.jsonSchema,\n          version: schema.version,\n          connectedStorages: []\n        },\n        _deleted: false,\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision(),\n        _attachments: {}\n      };\n      bulkPutDocs.push({\n        document: collectionDocData\n      });\n      var useArgs = Object.assign({}, args, {\n        name: collectionName,\n        schema,\n        database: this\n      });\n\n      // run hooks\n      var hookData = flatClone(args);\n      hookData.database = this;\n      hookData.name = name;\n      runPluginHooks('preCreateRxCollection', hookData);\n      useArgs.conflictHandler = hookData.conflictHandler;\n      useArgsByCollectionName[collectionName] = useArgs;\n    }));\n    var putDocsResult = await this.internalStore.bulkWrite(bulkPutDocs, 'rx-database-add-collection');\n    await ensureNoStartupErrors(this);\n    await Promise.all(putDocsResult.error.map(async error => {\n      if (error.status !== 409) {\n        throw newRxError('DB12', {\n          database: this.name,\n          writeError: error\n        });\n      }\n      var docInDb = ensureNotFalsy(error.documentInDb);\n      var collectionName = docInDb.data.name;\n      var schema = schemas[collectionName];\n      // collection already exists but has different schema\n      if (docInDb.data.schemaHash !== (await schema.hash)) {\n        throw newRxError('DB6', {\n          database: this.name,\n          collection: collectionName,\n          previousSchemaHash: docInDb.data.schemaHash,\n          schemaHash: await schema.hash,\n          previousSchema: docInDb.data.schema,\n          schema: ensureNotFalsy(jsonSchemas[collectionName])\n        });\n      }\n    }));\n    var ret = {};\n    await Promise.all(Object.keys(collectionCreators).map(async collectionName => {\n      var useArgs = useArgsByCollectionName[collectionName];\n      var collection = await createRxCollection(useArgs);\n      ret[collectionName] = collection;\n\n      // set as getter to the database\n      this.collections[collectionName] = collection;\n      if (!this[collectionName]) {\n        Object.defineProperty(this, collectionName, {\n          get: () => this.collections[collectionName]\n        });\n      }\n    }));\n    return ret;\n  }\n\n  /**\n   * runs the given function between idleQueue-locking\n   */;\n  _proto.lockedRun = function lockedRun(fn) {\n    return this.idleQueue.wrapCall(fn);\n  };\n  _proto.requestIdlePromise = function requestIdlePromise() {\n    return this.idleQueue.requestIdlePromise();\n  }\n\n  /**\n   * Export database to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON(_collections) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.addState = function addState(_name) {\n    throw pluginMissing('state');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<db>.exportJSON()` method.\n   * @note When an interface is loaded in this collection all base properties of the type are typed as `any`\n   * since data could be encrypted.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.backup = function backup(_options) {\n    throw pluginMissing('backup');\n  };\n  _proto.leaderElector = function leaderElector() {\n    throw pluginMissing('leader-election');\n  };\n  _proto.isLeader = function isLeader() {\n    throw pluginMissing('leader-election');\n  }\n  /**\n   * returns a promise which resolves when the instance becomes leader\n   */;\n  _proto.waitForLeadership = function waitForLeadership() {\n    throw pluginMissing('leader-election');\n  };\n  _proto.migrationStates = function migrationStates() {\n    throw pluginMissing('migration-schema');\n  }\n\n  /**\n   * closes the database-instance and all collections\n   */;\n  _proto.close = function close() {\n    if (this.closePromise) {\n      return this.closePromise;\n    }\n    var {\n      promise,\n      resolve\n    } = createPromiseWithResolvers();\n    var resolveClosePromise = result => {\n      if (this.onClosed) {\n        this.onClosed();\n      }\n      this.closed = true;\n      resolve(result);\n    };\n    this.closePromise = promise;\n    (async () => {\n      await runAsyncPluginHooks('preCloseRxDatabase', this);\n      /**\n       * Complete the event stream\n       * to stop all subscribers who forgot to unsubscribe.\n       */\n      this.eventBulks$.complete();\n      DB_COUNT--;\n      this._subs.map(sub => sub.unsubscribe());\n\n      /**\n       * closing the pseudo instance will throw\n       * because stuff is missing\n       * TODO we should not need the pseudo instance on runtime.\n       * we should generate the property list on build time.\n       */\n      if (this.name === 'pseudoInstance') {\n        resolveClosePromise(false);\n        return;\n      }\n\n      /**\n       * First wait until the database is idle\n       */\n      return this.requestIdlePromise().then(() => Promise.all(this.onClose.map(fn => fn())))\n      // close all collections\n      .then(() => Promise.all(Object.keys(this.collections).map(key => this.collections[key]).map(col => col.close())))\n      // close internal storage instances\n      .then(() => this.internalStore.close()).then(() => resolveClosePromise(true));\n    })();\n    return promise;\n  }\n\n  /**\n   * deletes the database and its stored data.\n   * Returns the names of all removed collections.\n   */;\n  _proto.remove = function remove() {\n    return this.close().then(() => removeRxDatabase(this.name, this.storage, this.multiInstance, this.password));\n  };\n  return _createClass(RxDatabaseBase, [{\n    key: \"$\",\n    get: function () {\n      return this.observable$;\n    }\n  }, {\n    key: \"asRxDatabase\",\n    get: function () {\n      return this;\n    }\n  }]);\n}();\n\n/**\n * checks if an instance with same name and storage already exists\n * @throws {RxError} if used\n */\nfunction throwIfDatabaseNameUsed(name, storage) {\n  if (USED_DATABASE_NAMES.has(getDatabaseNameKey(name, storage))) {\n    throw newRxError('DB8', {\n      name,\n      storage: storage.name,\n      link: 'https://rxdb.info/rx-database.html#ignoreduplicate'\n    });\n  }\n}\n\n/**\n * ponyfill for https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\n */\nfunction createPromiseWithResolvers() {\n  var resolve;\n  var reject;\n  var promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\nfunction getDatabaseNameKey(name, storage) {\n  return storage.name + '|' + name;\n}\n\n/**\n * Creates the storage instances that are used internally in the database\n * to store schemas and other configuration stuff.\n */\nexport async function createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, options, multiInstance, password) {\n  var internalStore = await storage.createStorageInstance({\n    databaseInstanceToken,\n    databaseName,\n    collectionName: INTERNAL_STORAGE_NAME,\n    schema: INTERNAL_STORE_SCHEMA,\n    options,\n    multiInstance,\n    password,\n    devMode: overwritable.isDevMode()\n  });\n  return internalStore;\n}\nexport function createRxDatabase({\n  storage,\n  instanceCreationOptions,\n  name,\n  password,\n  multiInstance = true,\n  eventReduce = true,\n  ignoreDuplicate = false,\n  options = {},\n  cleanupPolicy,\n  closeDuplicates = false,\n  allowSlowCount = false,\n  localDocuments = false,\n  hashFunction = defaultHashSha256,\n  reactivity\n}) {\n  runPluginHooks('preCreateRxDatabase', {\n    storage,\n    instanceCreationOptions,\n    name,\n    password,\n    multiInstance,\n    eventReduce,\n    ignoreDuplicate,\n    options,\n    localDocuments\n  });\n  var databaseNameKey = getDatabaseNameKey(name, storage);\n  var databaseNameKeyUnclosedInstancesSet = DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP.get(databaseNameKey) || new Set();\n  var instancePromiseWithResolvers = createPromiseWithResolvers();\n  var closeDuplicatesPromises = Array.from(databaseNameKeyUnclosedInstancesSet);\n  var onInstanceClosed = () => {\n    databaseNameKeyUnclosedInstancesSet.delete(instancePromiseWithResolvers.promise);\n    USED_DATABASE_NAMES.delete(databaseNameKey);\n  };\n  databaseNameKeyUnclosedInstancesSet.add(instancePromiseWithResolvers.promise);\n  DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP.set(databaseNameKey, databaseNameKeyUnclosedInstancesSet);\n  (async () => {\n    if (closeDuplicates) {\n      await Promise.all(closeDuplicatesPromises.map(unclosedInstancePromise => unclosedInstancePromise.catch(() => null).then(instance => instance && instance.close())));\n    }\n    if (ignoreDuplicate) {\n      if (!overwritable.isDevMode()) {\n        throw newRxError('DB9', {\n          database: name\n        });\n      }\n    } else {\n      // check if combination already used\n      throwIfDatabaseNameUsed(name, storage);\n    }\n    USED_DATABASE_NAMES.add(databaseNameKey);\n    var databaseInstanceToken = randomToken(10);\n    var storageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password);\n    var rxDatabase = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce, options, storageInstance, hashFunction, cleanupPolicy, allowSlowCount, reactivity, onInstanceClosed);\n    await runAsyncPluginHooks('createRxDatabase', {\n      database: rxDatabase,\n      creator: {\n        storage,\n        instanceCreationOptions,\n        name,\n        password,\n        multiInstance,\n        eventReduce,\n        ignoreDuplicate,\n        options,\n        localDocuments\n      }\n    });\n    return rxDatabase;\n  })().then(rxDatabase => {\n    instancePromiseWithResolvers.resolve(rxDatabase);\n  }).catch(err => {\n    instancePromiseWithResolvers.reject(err);\n    onInstanceClosed();\n  });\n  return instancePromiseWithResolvers.promise;\n}\n\n/**\n * Removes the database and all its known data\n * with all known collections and all internal meta data.\n *\n * Returns the names of the removed collections.\n */\nexport async function removeRxDatabase(databaseName, storage, multiInstance = true, password) {\n  var databaseInstanceToken = randomToken(10);\n  var dbInternalsStorageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, multiInstance, password);\n  var collectionDocs = await getAllCollectionDocuments(dbInternalsStorageInstance);\n  var collectionNames = new Set();\n  collectionDocs.forEach(doc => collectionNames.add(doc.data.name));\n  var removedCollectionNames = Array.from(collectionNames);\n  await Promise.all(removedCollectionNames.map(collectionName => removeCollectionStorages(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName, multiInstance, password)));\n  await runAsyncPluginHooks('postRemoveRxDatabase', {\n    databaseName,\n    storage\n  });\n  await dbInternalsStorageInstance.remove();\n  return removedCollectionNames;\n}\nexport function isRxDatabase(obj) {\n  return obj instanceof RxDatabaseBase;\n}\nexport function dbCount() {\n  return DB_COUNT;\n}\n\n/**\n * Returns true if the given RxDatabase was the first\n * instance that was created on the storage with this name.\n *\n * Can be used for some optimizations because on the first instantiation,\n * we can assume that no data was written before.\n */\nexport async function isRxDatabaseFirstTimeInstantiated(database) {\n  var tokenDoc = await database.storageTokenDocument;\n  return tokenDoc.data.instanceToken === database.token;\n}\n\n/**\n * For better performance some tasks run async\n * and are awaited later.\n * But we still have to ensure that there have been no errors\n * on database creation.\n */\nexport async function ensureNoStartupErrors(rxDatabase) {\n  await rxDatabase.storageToken;\n  if (rxDatabase.startupErrors[0]) {\n    throw rxDatabase.startupErrors[0];\n  }\n}\n//# sourceMappingURL=rx-database.js.map","/**\n * For the ORM capabilities,\n * we have to merge the document prototype\n * with the ORM functions and the data\n * We do this iterating over the properties and\n * adding them to a new object.\n * In the future we should do this by chaining the __proto__ objects\n */\n\nimport { createRxDocumentConstructor, basePrototype, createWithConstructor as createRxDocumentWithConstructor } from \"./rx-document.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { getFromMapOrCreate } from \"./plugins/utils/index.js\";\nvar constructorForCollection = new WeakMap();\nexport function getDocumentPrototype(rxCollection) {\n  var schemaProto = rxCollection.schema.getDocumentPrototype();\n  var ormProto = getDocumentOrmPrototype(rxCollection);\n  var baseProto = basePrototype;\n  var proto = {};\n  [schemaProto, ormProto, baseProto].forEach(obj => {\n    var props = Object.getOwnPropertyNames(obj);\n    props.forEach(key => {\n      var desc = Object.getOwnPropertyDescriptor(obj, key);\n      /**\n       * When enumerable is true, it will show on console dir(instance)\n       * To not pollute the output, only getters and methods are enumerable\n       */\n      var enumerable = true;\n      if (key.startsWith('_') || key.endsWith('_') || key.startsWith('$') || key.endsWith('$')) enumerable = false;\n      if (typeof desc.value === 'function') {\n        // when getting a function, we automatically do a .bind(this)\n        Object.defineProperty(proto, key, {\n          get() {\n            return desc.value.bind(this);\n          },\n          enumerable,\n          configurable: false\n        });\n      } else {\n        desc.enumerable = enumerable;\n        desc.configurable = false;\n        if (desc.writable) desc.writable = false;\n        Object.defineProperty(proto, key, desc);\n      }\n    });\n  });\n  return proto;\n}\nexport function getRxDocumentConstructor(rxCollection) {\n  return getFromMapOrCreate(constructorForCollection, rxCollection, () => createRxDocumentConstructor(getDocumentPrototype(rxCollection)));\n}\n\n/**\n * Create a RxDocument-instance from the jsonData\n * and the prototype merge.\n * You should never call this method directly,\n * instead you should get the document from collection._docCache.getCachedRxDocument().\n */\nexport function createNewRxDocument(rxCollection, documentConstructor, docData) {\n  var doc = createRxDocumentWithConstructor(documentConstructor, rxCollection, overwritable.deepFreezeWhenDevMode(docData));\n  rxCollection._runHooksSync('post', 'create', docData, doc);\n  runPluginHooks('postCreateRxDocument', doc);\n  return doc;\n}\n\n/**\n * returns the prototype-object\n * that contains the orm-methods,\n * used in the proto-merge\n */\nexport function getDocumentOrmPrototype(rxCollection) {\n  var proto = {};\n  Object.entries(rxCollection.methods).forEach(([k, v]) => {\n    proto[k] = v;\n  });\n  return proto;\n}\n//# sourceMappingURL=rx-document-prototype-merge.js.map","import { distinctUntilChanged, filter, map, shareReplay, startWith } from 'rxjs/operators';\nimport { clone, trimDots, pluginMissing, flatClone, PROMISE_RESOLVE_NULL, RXJS_SHARE_REPLAY_DEFAULTS, getProperty, getFromMapOrCreate, ensureNotFalsy } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { getDocumentDataOfRxChangeEvent } from \"./rx-change-event.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { getSchemaByObjectPath } from \"./rx-schema-helper.js\";\nimport { getWrittenDocumentsFromBulkWriteResponse, throwIfIsStorageWriteError } from \"./rx-storage-helper.js\";\nimport { modifierFromPublicToInternal } from \"./incremental-write.js\";\nexport var basePrototype = {\n  get primaryPath() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this.collection.schema.primaryPath;\n  },\n  get primary() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data[_this.primaryPath];\n  },\n  get revision() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data._rev;\n  },\n  get deleted$() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this.$.pipe(map(d => d._data._deleted));\n  },\n  get deleted$$() {\n    var _this = this;\n    var reactivity = _this.collection.database.getReactivityFactory();\n    return reactivity.fromObservable(_this.deleted$, _this.getLatest().deleted, _this.collection.database);\n  },\n  get deleted() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data._deleted;\n  },\n  getLatest() {\n    var latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);\n    return this.collection._docCache.getCachedRxDocument(latestDocData);\n  },\n  /**\n   * returns the observable which emits the plain-data of this document\n   */\n  get $() {\n    var _this = this;\n    var id = this.primary;\n    return _this.collection.eventBulks$.pipe(filter(bulk => !bulk.isLocal), map(bulk => bulk.events.find(ev => ev.documentId === id)), filter(event => !!event), map(changeEvent => getDocumentDataOfRxChangeEvent(ensureNotFalsy(changeEvent))), startWith(_this.collection._docCache.getLatestDocumentData(id)), distinctUntilChanged((prev, curr) => prev._rev === curr._rev), map(docData => this.collection._docCache.getCachedRxDocument(docData)), shareReplay(RXJS_SHARE_REPLAY_DEFAULTS));\n  },\n  get $$() {\n    var _this = this;\n    var reactivity = _this.collection.database.getReactivityFactory();\n    return reactivity.fromObservable(_this.$, _this.getLatest()._data, _this.collection.database);\n  },\n  /**\n   * returns observable of the value of the given path\n   */\n  get$(path) {\n    if (overwritable.isDevMode()) {\n      if (path.includes('.item.')) {\n        throw newRxError('DOC1', {\n          path\n        });\n      }\n      if (path === this.primaryPath) {\n        throw newRxError('DOC2');\n      }\n\n      // final fields cannot be modified and so also not observed\n      if (this.collection.schema.finalFields.includes(path)) {\n        throw newRxError('DOC3', {\n          path\n        });\n      }\n      var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);\n      if (!schemaObj) {\n        throw newRxError('DOC4', {\n          path\n        });\n      }\n    }\n    return this.$.pipe(map(data => getProperty(data, path)), distinctUntilChanged());\n  },\n  get$$(path) {\n    var obs = this.get$(path);\n    var reactivity = this.collection.database.getReactivityFactory();\n    return reactivity.fromObservable(obs, this.getLatest().get(path), this.collection.database);\n  },\n  /**\n   * populate the given path\n   */\n  populate(path) {\n    var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);\n    var value = this.get(path);\n    if (!value) {\n      return PROMISE_RESOLVE_NULL;\n    }\n    if (!schemaObj) {\n      throw newRxError('DOC5', {\n        path\n      });\n    }\n    if (!schemaObj.ref) {\n      throw newRxError('DOC6', {\n        path,\n        schemaObj\n      });\n    }\n    var refCollection = this.collection.database.collections[schemaObj.ref];\n    if (!refCollection) {\n      throw newRxError('DOC7', {\n        ref: schemaObj.ref,\n        path,\n        schemaObj\n      });\n    }\n    if (schemaObj.type === 'array') {\n      return refCollection.findByIds(value).exec().then(res => {\n        var valuesIterator = res.values();\n        return Array.from(valuesIterator);\n      });\n    } else {\n      return refCollection.findOne(value).exec();\n    }\n  },\n  /**\n   * get data by objectPath\n   * @hotPath Performance here is really important,\n   * run some tests before changing anything.\n   */\n  get(objPath) {\n    return getDocumentProperty(this, objPath);\n  },\n  toJSON(withMetaFields = false) {\n    if (!withMetaFields) {\n      var data = flatClone(this._data);\n      delete data._rev;\n      delete data._attachments;\n      delete data._deleted;\n      delete data._meta;\n      return overwritable.deepFreezeWhenDevMode(data);\n    } else {\n      return overwritable.deepFreezeWhenDevMode(this._data);\n    }\n  },\n  toMutableJSON(withMetaFields = false) {\n    return clone(this.toJSON(withMetaFields));\n  },\n  /**\n   * updates document\n   * @overwritten by plugin (optional)\n   * @param updateObj mongodb-like syntax\n   */\n  update(_updateObj) {\n    throw pluginMissing('update');\n  },\n  incrementalUpdate(_updateObj) {\n    throw pluginMissing('update');\n  },\n  updateCRDT(_updateObj) {\n    throw pluginMissing('crdt');\n  },\n  putAttachment() {\n    throw pluginMissing('attachments');\n  },\n  getAttachment() {\n    throw pluginMissing('attachments');\n  },\n  allAttachments() {\n    throw pluginMissing('attachments');\n  },\n  get allAttachments$() {\n    throw pluginMissing('attachments');\n  },\n  async modify(mutationFunction,\n  // used by some plugins that wrap the method\n  _context) {\n    var oldData = this._data;\n    var newData = await modifierFromPublicToInternal(mutationFunction)(oldData);\n    return this._saveData(newData, oldData);\n  },\n  /**\n   * runs an incremental update over the document\n   * @param function that takes the document-data and returns a new data-object\n   */\n  incrementalModify(mutationFunction,\n  // used by some plugins that wrap the method\n  _context) {\n    return this.collection.incrementalWriteQueue.addWrite(this._data, modifierFromPublicToInternal(mutationFunction)).then(result => this.collection._docCache.getCachedRxDocument(result));\n  },\n  patch(patch) {\n    var oldData = this._data;\n    var newData = clone(oldData);\n    Object.entries(patch).forEach(([k, v]) => {\n      newData[k] = v;\n    });\n    return this._saveData(newData, oldData);\n  },\n  /**\n   * patches the given properties\n   */\n  incrementalPatch(patch) {\n    return this.incrementalModify(docData => {\n      Object.entries(patch).forEach(([k, v]) => {\n        docData[k] = v;\n      });\n      return docData;\n    });\n  },\n  /**\n   * saves the new document-data\n   * and handles the events\n   */\n  async _saveData(newData, oldData) {\n    newData = flatClone(newData);\n\n    // deleted documents cannot be changed\n    if (this._data._deleted) {\n      throw newRxError('DOC11', {\n        id: this.primary,\n        document: this\n      });\n    }\n    await beforeDocumentUpdateWrite(this.collection, newData, oldData);\n    var writeRows = [{\n      previous: oldData,\n      document: newData\n    }];\n    var writeResult = await this.collection.storageInstance.bulkWrite(writeRows, 'rx-document-save-data');\n    var isError = writeResult.error[0];\n    throwIfIsStorageWriteError(this.collection, this.primary, newData, isError);\n    await this.collection._runHooks('post', 'save', newData, this);\n    return this.collection._docCache.getCachedRxDocument(getWrittenDocumentsFromBulkWriteResponse(this.collection.schema.primaryPath, writeRows, writeResult)[0]);\n  },\n  /**\n   * Remove the document.\n   * Notice that there is no hard delete,\n   * instead deleted documents get flagged with _deleted=true.\n   */\n  async remove() {\n    if (this.deleted) {\n      return Promise.reject(newRxError('DOC13', {\n        document: this,\n        id: this.primary\n      }));\n    }\n    var removeResult = await this.collection.bulkRemove([this]);\n    if (removeResult.error.length > 0) {\n      var error = removeResult.error[0];\n      throwIfIsStorageWriteError(this.collection, this.primary, this._data, error);\n    }\n    return removeResult.success[0];\n  },\n  incrementalRemove() {\n    return this.incrementalModify(async docData => {\n      await this.collection._runHooks('pre', 'remove', docData, this);\n      docData._deleted = true;\n      return docData;\n    }).then(async newDoc => {\n      await this.collection._runHooks('post', 'remove', newDoc._data, newDoc);\n      return newDoc;\n    });\n  },\n  close() {\n    throw newRxError('DOC14');\n  }\n};\nexport function createRxDocumentConstructor(proto = basePrototype) {\n  var constructor = function RxDocumentConstructor(collection, docData) {\n    this.collection = collection;\n\n    // assume that this is always equal to the doc-data in the database\n    this._data = docData;\n    this._propertyCache = new Map();\n\n    /**\n     * because of the prototype-merge,\n     * we can not use the native instanceof operator\n     */\n    this.isInstanceOfRxDocument = true;\n  };\n  constructor.prototype = proto;\n  return constructor;\n}\nexport function createWithConstructor(constructor, collection, jsonData) {\n  var doc = new constructor(collection, jsonData);\n  runPluginHooks('createRxDocument', doc);\n  return doc;\n}\nexport function isRxDocument(obj) {\n  return typeof obj === 'object' && obj !== null && 'isInstanceOfRxDocument' in obj;\n}\nexport function beforeDocumentUpdateWrite(collection, newData, oldData) {\n  /**\n   * Meta values must always be merged\n   * instead of overwritten.\n   * This ensures that different plugins do not overwrite\n   * each others meta properties.\n   */\n  newData._meta = Object.assign({}, oldData._meta, newData._meta);\n\n  // ensure modifications are ok\n  if (overwritable.isDevMode()) {\n    collection.schema.validateChange(oldData, newData);\n  }\n  return collection._runHooks('pre', 'save', newData, oldData);\n}\nfunction getDocumentProperty(doc, objPath) {\n  return getFromMapOrCreate(doc._propertyCache, objPath, () => {\n    var valueObj = getProperty(doc._data, objPath);\n\n    // direct return if array or non-object\n    if (typeof valueObj !== 'object' || valueObj === null || Array.isArray(valueObj)) {\n      return overwritable.deepFreezeWhenDevMode(valueObj);\n    }\n    var proxy = new Proxy(\n    /**\n     * In dev-mode, the _data is deep-frozen\n     * so we have to flat clone here so that\n     * the proxy can work.\n     */\n    flatClone(valueObj), {\n      /**\n       * @performance is really important here\n       * because people access nested properties very often\n       * and might not be aware that this is internally using a Proxy\n       */\n      get(target, property) {\n        if (typeof property !== 'string') {\n          return target[property];\n        }\n        var lastChar = property.charAt(property.length - 1);\n        if (lastChar === '$') {\n          if (property.endsWith('$$')) {\n            var key = property.slice(0, -2);\n            return doc.get$$(trimDots(objPath + '.' + key));\n          } else {\n            var _key = property.slice(0, -1);\n            return doc.get$(trimDots(objPath + '.' + _key));\n          }\n        } else if (lastChar === '_') {\n          var _key2 = property.slice(0, -1);\n          return doc.populate(trimDots(objPath + '.' + _key2));\n        } else {\n          /**\n           * Performance shortcut\n           * In most cases access to nested properties\n           * will only access simple values which can be directly returned\n           * without creating a new Proxy or utilizing the cache.\n           */\n          var plainValue = target[property];\n          if (typeof plainValue === 'number' || typeof plainValue === 'string' || typeof plainValue === 'boolean') {\n            return plainValue;\n          }\n          return getDocumentProperty(doc, trimDots(objPath + '.' + property));\n        }\n      }\n    });\n    return proxy;\n  });\n}\n;\n//# sourceMappingURL=rx-document.js.map","import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inheritsLoose from \"@babel/runtime/helpers/inheritsLoose\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/wrapNativeSuper\";\n/**\n * here we use custom errors with the additional field 'parameters'\n */\n\nimport { overwritable } from \"./overwritable.js\";\n/**\n * transform an object of parameters to a presentable string\n */\nfunction parametersToString(parameters) {\n  var ret = '';\n  if (Object.keys(parameters).length === 0) return ret;\n  ret += '-'.repeat(20) + '\\n';\n  ret += 'Parameters:\\n';\n  ret += Object.keys(parameters).map(k => {\n    var paramStr = '[object Object]';\n    try {\n      if (k === 'errors') {\n        paramStr = parameters[k].map(err => JSON.stringify(err, Object.getOwnPropertyNames(err)));\n      } else {\n        paramStr = JSON.stringify(parameters[k], function (_k, v) {\n          return v === undefined ? null : v;\n        }, 2);\n      }\n    } catch (e) {}\n    return k + ': ' + paramStr;\n  }).join('\\n');\n  ret += '\\n';\n  return ret;\n}\nfunction messageForError(message, code, parameters) {\n  return '' + '\\n' + message + '\\n' + parametersToString(parameters);\n}\nexport var RxError = /*#__PURE__*/function (_Error) {\n  // always true, use this to detect if its an rxdb-error\n\n  function RxError(code, message, parameters = {}) {\n    var _this;\n    var mes = messageForError(message, code, parameters);\n    _this = _Error.call(this, mes) || this;\n    _this.code = code;\n    _this.message = mes;\n    _this.url = getErrorUrl(code);\n    _this.parameters = parameters;\n    _this.rxdb = true; // tag them as internal\n    return _this;\n  }\n  _inheritsLoose(RxError, _Error);\n  var _proto = RxError.prototype;\n  _proto.toString = function toString() {\n    return this.message;\n  };\n  return _createClass(RxError, [{\n    key: \"name\",\n    get: function () {\n      return 'RxError (' + this.code + ')';\n    }\n  }, {\n    key: \"typeError\",\n    get: function () {\n      return false;\n    }\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(Error));\nexport var RxTypeError = /*#__PURE__*/function (_TypeError) {\n  // always true, use this to detect if its an rxdb-error\n\n  function RxTypeError(code, message, parameters = {}) {\n    var _this2;\n    var mes = messageForError(message, code, parameters);\n    _this2 = _TypeError.call(this, mes) || this;\n    _this2.code = code;\n    _this2.message = mes;\n    _this2.url = getErrorUrl(code);\n    _this2.parameters = parameters;\n    _this2.rxdb = true; // tag them as internal\n    return _this2;\n  }\n  _inheritsLoose(RxTypeError, _TypeError);\n  var _proto2 = RxTypeError.prototype;\n  _proto2.toString = function toString() {\n    return this.message;\n  };\n  return _createClass(RxTypeError, [{\n    key: \"name\",\n    get: function () {\n      return 'RxTypeError (' + this.code + ')';\n    }\n  }, {\n    key: \"typeError\",\n    get: function () {\n      return true;\n    }\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(TypeError));\nexport function getErrorUrl(code) {\n  return 'https://rxdb.info/errors.html?console=errors#' + code;\n}\nexport function errorUrlHint(code) {\n  return '\\nFind out more about this error here: ' + getErrorUrl(code) + ' \\n';\n}\nexport function newRxError(code, parameters) {\n  return new RxError(code, overwritable.tunnelErrorMessage(code) + errorUrlHint(code), parameters);\n}\nexport function newRxTypeError(code, parameters) {\n  return new RxTypeError(code, overwritable.tunnelErrorMessage(code) + errorUrlHint(code), parameters);\n}\n\n/**\n * Returns the error if it is a 409 conflict,\n * return false if it is another error.\n */\nexport function isBulkWriteConflictError(err) {\n  if (err && err.status === 409) {\n    return err;\n  } else {\n    return false;\n  }\n}\nvar STORAGE_WRITE_ERROR_CODE_TO_MESSAGE = {\n  409: 'document write conflict',\n  422: 'schema validation error',\n  510: 'attachment data missing'\n};\nexport function rxStorageWriteErrorToRxError(err) {\n  return newRxError('COL20', {\n    name: STORAGE_WRITE_ERROR_CODE_TO_MESSAGE[err.status],\n    document: err.documentId,\n    writeError: err\n  });\n}\n//# sourceMappingURL=rx-error.js.map","import { LOGICAL_OPERATORS, getQueryPlan } from \"./query-planner.js\";\nimport { getPrimaryFieldOfPrimaryKey } from \"./rx-schema-helper.js\";\nimport { clone, firstPropertyNameOfObject, toArray, isMaybeReadonlyArray, flatClone, objectPathMonad } from \"./plugins/utils/index.js\";\nimport { compare as mingoSortComparator } from 'mingo/util';\nimport { newRxError } from \"./rx-error.js\";\nimport { getMingoQuery } from \"./rx-query-mingo.js\";\n\n/**\n * Normalize the query to ensure we have all fields set\n * and queries that represent the same query logic are detected as equal by the caching.\n */\nexport function normalizeMangoQuery(schema, mangoQuery) {\n  var primaryKey = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n  mangoQuery = flatClone(mangoQuery);\n  var normalizedMangoQuery = clone(mangoQuery);\n  if (typeof normalizedMangoQuery.skip !== 'number') {\n    normalizedMangoQuery.skip = 0;\n  }\n  if (!normalizedMangoQuery.selector) {\n    normalizedMangoQuery.selector = {};\n  } else {\n    normalizedMangoQuery.selector = normalizedMangoQuery.selector;\n    /**\n     * In mango query, it is possible to have an\n     * equals comparison by directly assigning a value\n     * to a property, without the '$eq' operator.\n     * Like:\n     * selector: {\n     *   foo: 'bar'\n     * }\n     * For normalization, we have to normalize this\n     * so our checks can perform properly.\n     *\n     *\n     * TODO this must work recursive with nested queries that\n     * contain multiple selectors via $and or $or etc.\n     */\n    Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n      if (typeof matcher !== 'object' || matcher === null) {\n        normalizedMangoQuery.selector[field] = {\n          $eq: matcher\n        };\n      }\n    });\n  }\n\n  /**\n   * Ensure that if an index is specified,\n   * the primaryKey is inside of it.\n   */\n  if (normalizedMangoQuery.index) {\n    var indexAr = toArray(normalizedMangoQuery.index);\n    if (!indexAr.includes(primaryKey)) {\n      indexAr.push(primaryKey);\n    }\n    normalizedMangoQuery.index = indexAr;\n  }\n\n  /**\n   * To ensure a deterministic sorting,\n   * we have to ensure the primary key is always part\n   * of the sort query.\n   * Primary sorting is added as last sort parameter,\n   * similar to how we add the primary key to indexes that do not have it.\n   *\n   */\n  if (!normalizedMangoQuery.sort) {\n    /**\n     * If no sort is given at all,\n     * we can assume that the user does not care about sort order at al.\n     *\n     * we cannot just use the primary key as sort parameter\n     * because it would likely cause the query to run over the primary key index\n     * which has a bad performance in most cases.\n     */\n    if (normalizedMangoQuery.index) {\n      normalizedMangoQuery.sort = normalizedMangoQuery.index.map(field => {\n        return {\n          [field]: 'asc'\n        };\n      });\n    } else {\n      /**\n       * Find the index that best matches the fields with the logical operators\n       */\n      if (schema.indexes) {\n        var fieldsWithLogicalOperator = new Set();\n        Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n          var hasLogical = false;\n          if (typeof matcher === 'object' && matcher !== null) {\n            hasLogical = !!Object.keys(matcher).find(operator => LOGICAL_OPERATORS.has(operator));\n          } else {\n            hasLogical = true;\n          }\n          if (hasLogical) {\n            fieldsWithLogicalOperator.add(field);\n          }\n        });\n        var currentFieldsAmount = -1;\n        var currentBestIndexForSort;\n        schema.indexes.forEach(index => {\n          var useIndex = isMaybeReadonlyArray(index) ? index : [index];\n          var firstWrongIndex = useIndex.findIndex(indexField => !fieldsWithLogicalOperator.has(indexField));\n          if (firstWrongIndex > 0 && firstWrongIndex > currentFieldsAmount) {\n            currentFieldsAmount = firstWrongIndex;\n            currentBestIndexForSort = useIndex;\n          }\n        });\n        if (currentBestIndexForSort) {\n          normalizedMangoQuery.sort = currentBestIndexForSort.map(field => {\n            return {\n              [field]: 'asc'\n            };\n          });\n        }\n      }\n\n      /**\n       * If no good index was found as default sort-order,\n       * just use the first index of the schema.\n       * If no index is in the schema, use the default-index which\n       * is created by RxDB ONLY if there is no other index defined.\n       */\n      if (!normalizedMangoQuery.sort) {\n        if (schema.indexes && schema.indexes.length > 0) {\n          var firstIndex = schema.indexes[0];\n          var useIndex = isMaybeReadonlyArray(firstIndex) ? firstIndex : [firstIndex];\n          normalizedMangoQuery.sort = useIndex.map(field => ({\n            [field]: 'asc'\n          }));\n        } else {\n          normalizedMangoQuery.sort = [{\n            [primaryKey]: 'asc'\n          }];\n        }\n      }\n    }\n  } else {\n    var isPrimaryInSort = normalizedMangoQuery.sort.find(p => firstPropertyNameOfObject(p) === primaryKey);\n    if (!isPrimaryInSort) {\n      normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);\n      normalizedMangoQuery.sort.push({\n        [primaryKey]: 'asc'\n      });\n    }\n  }\n  return normalizedMangoQuery;\n}\n\n/**\n * Returns the sort-comparator,\n * which is able to sort documents in the same way\n * a query over the db would do.\n */\nexport function getSortComparator(schema, query) {\n  if (!query.sort) {\n    throw newRxError('SNH', {\n      query\n    });\n  }\n  var sortParts = [];\n  query.sort.forEach(sortBlock => {\n    var key = Object.keys(sortBlock)[0];\n    var direction = Object.values(sortBlock)[0];\n    sortParts.push({\n      key,\n      direction,\n      getValueFn: objectPathMonad(key)\n    });\n  });\n  var fun = (a, b) => {\n    for (var i = 0; i < sortParts.length; ++i) {\n      var sortPart = sortParts[i];\n      var valueA = sortPart.getValueFn(a);\n      var valueB = sortPart.getValueFn(b);\n      if (valueA !== valueB) {\n        var ret = sortPart.direction === 'asc' ? mingoSortComparator(valueA, valueB) : mingoSortComparator(valueB, valueA);\n        return ret;\n      }\n    }\n  };\n  return fun;\n}\n\n/**\n * Returns a function\n * that can be used to check if a document\n * matches the query.\n */\nexport function getQueryMatcher(_schema, query) {\n  if (!query.sort) {\n    throw newRxError('SNH', {\n      query\n    });\n  }\n  var mingoQuery = getMingoQuery(query.selector);\n  var fun = doc => {\n    return mingoQuery.test(doc);\n  };\n  return fun;\n}\nexport async function runQueryUpdateFunction(rxQuery, fn) {\n  var docs = await rxQuery.exec();\n  if (!docs) {\n    // only findOne() queries can return null\n    return null;\n  }\n  if (Array.isArray(docs)) {\n    return Promise.all(docs.map(doc => fn(doc)));\n  } else if (docs instanceof Map) {\n    return Promise.all([...docs.values()].map(doc => fn(doc)));\n  } else {\n    // via findOne()\n    var result = await fn(docs);\n    return result;\n  }\n}\n\n/**\n * @returns a format of the query that can be used with the storage\n * when calling RxStorageInstance().query()\n */\nexport function prepareQuery(schema, mutateableQuery) {\n  if (!mutateableQuery.sort) {\n    throw newRxError('SNH', {\n      query: mutateableQuery\n    });\n  }\n\n  /**\n   * Store the query plan together with the\n   * prepared query to save performance.\n   */\n  var queryPlan = getQueryPlan(schema, mutateableQuery);\n  return {\n    query: mutateableQuery,\n    queryPlan\n  };\n}\n//# sourceMappingURL=rx-query-helper.js.map","import { useOperators, OperatorType } from 'mingo/core';\nimport { Query } from 'mingo/query';\nimport { $project, $sort } from 'mingo/operators/pipeline';\nimport { $and, $not, $or, $nor } from 'mingo/operators/query/logical';\nimport { $eq, $ne, $gt, $gte, $lt, $lte, $nin, $in } from 'mingo/operators/query/comparison';\nimport { $regex, $mod } from 'mingo/operators/query/evaluation';\nimport { $elemMatch, $size } from 'mingo/operators/query/array';\nimport { $exists, $type } from 'mingo/operators/query/element';\nvar mingoInitDone = false;\n\n/**\n * The MongoDB query library is huge and we do not need all the operators.\n * If you add an operator here, make sure that you properly add a test in\n * the file /test/unit/rx-storage-query-correctness.test.ts\n *\n * @link https://github.com/kofrasa/mingo#es6\n */\nexport function getMingoQuery(selector) {\n  if (!mingoInitDone) {\n    useOperators(OperatorType.PIPELINE, {\n      $sort,\n      $project\n    });\n    useOperators(OperatorType.QUERY, {\n      $and,\n      $eq,\n      $elemMatch,\n      $exists,\n      $gt,\n      $gte,\n      $in,\n      $lt,\n      $lte,\n      $ne,\n      $nin,\n      $mod,\n      $nor,\n      $not,\n      $or,\n      $regex,\n      $size,\n      $type\n    });\n    mingoInitDone = true;\n  }\n  return new Query(selector);\n}\n//# sourceMappingURL=rx-query-mingo.js.map","import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { mapDocumentsDataToCacheDocs } from \"./doc-cache.js\";\nimport { now, overwriteGetterForCaching } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\n/**\n * RxDB needs the query results in multiple formats.\n * Sometimes as a Map or an array with only the documentData.\n * For better performance we work with this class\n * that initializes stuff lazily so that\n * we can directly work with the query results after RxQuery.exec()\n */\nexport var RxQuerySingleResult = /*#__PURE__*/function () {\n  /**\n   * Time at which the current _result state was created.\n   * Used to determine if the result set has changed since X\n   * so that we do not emit the same result multiple times on subscription.\n   */\n\n  function RxQuerySingleResult(query,\n  // only used internally, do not use outside, use this.docsData instead\n  docsDataFromStorageInstance,\n  // can be overwritten for count-queries\n  count) {\n    this.time = now();\n    this.query = query;\n    this.count = count;\n    this.documents = mapDocumentsDataToCacheDocs(this.query.collection._docCache, docsDataFromStorageInstance);\n  }\n\n  /**\n   * Instead of using the newResultData in the result cache,\n   * we directly use the objects that are stored in the RxDocument\n   * to ensure we do not store the same data twice and fill up the memory.\n   * @overwrites itself with the actual value\n   */\n  var _proto = RxQuerySingleResult.prototype;\n  _proto.getValue = function getValue(throwIfMissing) {\n    var op = this.query.op;\n    if (op === 'count') {\n      return this.count;\n    } else if (op === 'findOne') {\n      // findOne()-queries emit RxDocument or null\n      var doc = this.documents.length === 0 ? null : this.documents[0];\n      if (!doc && throwIfMissing) {\n        throw newRxError('QU10', {\n          collection: this.query.collection.name,\n          query: this.query.mangoQuery,\n          op\n        });\n      } else {\n        return doc;\n      }\n    } else if (op === 'findByIds') {\n      return this.docsMap;\n    } else {\n      // find()-queries emit RxDocument[]\n      // Flat copy the array so it won't matter if the user modifies it.\n      return this.documents.slice(0);\n    }\n  };\n  return _createClass(RxQuerySingleResult, [{\n    key: \"docsData\",\n    get: function () {\n      return overwriteGetterForCaching(this, 'docsData', this.documents.map(d => d._data));\n    }\n\n    // A key->document map, used in the event reduce optimization.\n  }, {\n    key: \"docsDataMap\",\n    get: function () {\n      var map = new Map();\n      this.documents.forEach(d => {\n        map.set(d.primary, d._data);\n      });\n      return overwriteGetterForCaching(this, 'docsDataMap', map);\n    }\n  }, {\n    key: \"docsMap\",\n    get: function () {\n      var map = new Map();\n      var documents = this.documents;\n      for (var i = 0; i < documents.length; i++) {\n        var doc = documents[i];\n        map.set(doc.primary, doc);\n      }\n      return overwriteGetterForCaching(this, 'docsMap', map);\n    }\n  }]);\n}();\n//# sourceMappingURL=rx-query-single-result.js.map","import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { BehaviorSubject, merge } from 'rxjs';\nimport { mergeMap, filter, map, startWith, distinctUntilChanged, shareReplay } from 'rxjs/operators';\nimport { sortObject, pluginMissing, overwriteGetterForCaching, now, PROMISE_RESOLVE_FALSE, RXJS_SHARE_REPLAY_DEFAULTS, ensureNotFalsy, areRxDocumentArraysEqual, appendToArray } from \"./plugins/utils/index.js\";\nimport { newRxError, rxStorageWriteErrorToRxError } from \"./rx-error.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { calculateNewResults } from \"./event-reduce.js\";\nimport { triggerCacheReplacement } from \"./query-cache.js\";\nimport { getQueryMatcher, normalizeMangoQuery, prepareQuery, runQueryUpdateFunction } from \"./rx-query-helper.js\";\nimport { RxQuerySingleResult } from \"./rx-query-single-result.js\";\nvar _queryCount = 0;\nvar newQueryID = function () {\n  return ++_queryCount;\n};\nexport var RxQueryBase = /*#__PURE__*/function () {\n  /**\n   * Some stats then are used for debugging and cache replacement policies\n   */\n\n  // used in the query-cache to determine if the RxQuery can be cleaned up.\n\n  // used to count the subscribers to the query\n\n  /**\n   * Contains the current result state\n   * or null if query has not run yet.\n   */\n\n  function RxQueryBase(op, mangoQuery, collection,\n  // used by some plugins\n  other = {}) {\n    this.id = newQueryID();\n    this._execOverDatabaseCount = 0;\n    this._creationTime = now();\n    this._lastEnsureEqual = 0;\n    this.uncached = false;\n    this.refCount$ = new BehaviorSubject(null);\n    this._result = null;\n    this._latestChangeEvent = -1;\n    this._ensureEqualQueue = PROMISE_RESOLVE_FALSE;\n    this.op = op;\n    this.mangoQuery = mangoQuery;\n    this.collection = collection;\n    this.other = other;\n    if (!mangoQuery) {\n      this.mangoQuery = _getDefaultQuery();\n    }\n    this.isFindOneByIdQuery = isFindOneByIdQuery(this.collection.schema.primaryPath, mangoQuery);\n  }\n  var _proto = RxQueryBase.prototype;\n  /**\n   * Returns an observable that emits the results\n   * This should behave like an rxjs-BehaviorSubject which means:\n   * - Emit the current result-set on subscribe\n   * - Emit the new result-set when an RxChangeEvent comes in\n   * - Do not emit anything before the first result-set was created (no null)\n   */\n  /**\n   * set the new result-data as result-docs of the query\n   * @param newResultData json-docs that were received from the storage\n   */\n  _proto._setResultData = function _setResultData(newResultData) {\n    if (typeof newResultData === 'undefined') {\n      throw newRxError('QU18', {\n        database: this.collection.database.name,\n        collection: this.collection.name\n      });\n    }\n    if (typeof newResultData === 'number') {\n      this._result = new RxQuerySingleResult(this, [], newResultData);\n      return;\n    } else if (newResultData instanceof Map) {\n      newResultData = Array.from(newResultData.values());\n    }\n    var newQueryResult = new RxQuerySingleResult(this, newResultData, newResultData.length);\n    this._result = newQueryResult;\n  }\n\n  /**\n   * executes the query on the database\n   * @return results-array with document-data\n   */;\n  _proto._execOverDatabase = async function _execOverDatabase() {\n    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n    if (this.op === 'count') {\n      var preparedQuery = this.getPreparedQuery();\n      var result = await this.collection.storageInstance.count(preparedQuery);\n      if (result.mode === 'slow' && !this.collection.database.allowSlowCount) {\n        throw newRxError('QU14', {\n          collection: this.collection,\n          queryObj: this.mangoQuery\n        });\n      } else {\n        return result.count;\n      }\n    }\n    if (this.op === 'findByIds') {\n      var ids = ensureNotFalsy(this.mangoQuery.selector)[this.collection.schema.primaryPath].$in;\n      var ret = new Map();\n      var mustBeQueried = [];\n      // first try to fill from docCache\n      ids.forEach(id => {\n        var docData = this.collection._docCache.getLatestDocumentDataIfExists(id);\n        if (docData) {\n          if (!docData._deleted) {\n            var doc = this.collection._docCache.getCachedRxDocument(docData);\n            ret.set(id, doc);\n          }\n        } else {\n          mustBeQueried.push(id);\n        }\n      });\n      // everything which was not in docCache must be fetched from the storage\n      if (mustBeQueried.length > 0) {\n        var docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);\n        docs.forEach(docData => {\n          var doc = this.collection._docCache.getCachedRxDocument(docData);\n          ret.set(doc.primary, doc);\n        });\n      }\n      return ret;\n    }\n    var docsPromise = queryCollection(this);\n    return docsPromise.then(docs => {\n      return docs;\n    });\n  }\n\n  /**\n   * Execute the query\n   * To have an easier implementations,\n   * just subscribe and use the first result\n   */;\n  _proto.exec = async function exec(throwIfMissing) {\n    if (throwIfMissing && this.op !== 'findOne') {\n      throw newRxError('QU9', {\n        collection: this.collection.name,\n        query: this.mangoQuery,\n        op: this.op\n      });\n    }\n\n    /**\n     * run _ensureEqual() here,\n     * this will make sure that errors in the query which throw inside of the RxStorage,\n     * will be thrown at this execution context and not in the background.\n     */\n    await _ensureEqual(this);\n    var useResult = ensureNotFalsy(this._result);\n    return useResult.getValue(throwIfMissing);\n  }\n\n  /**\n   * cached call to get the queryMatcher\n   * @overwrites itself with the actual value\n   */;\n  /**\n   * returns a string that is used for equal-comparisons\n   * @overwrites itself with the actual value\n   */\n  _proto.toString = function toString() {\n    var stringObj = sortObject({\n      op: this.op,\n      query: normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery),\n      other: this.other\n    }, true);\n    var value = JSON.stringify(stringObj);\n    this.toString = () => value;\n    return value;\n  }\n\n  /**\n   * returns the prepared query\n   * which can be send to the storage instance to query for documents.\n   * @overwrites itself with the actual value.\n   */;\n  _proto.getPreparedQuery = function getPreparedQuery() {\n    var hookInput = {\n      rxQuery: this,\n      // can be mutated by the hooks so we have to deep clone first.\n      mangoQuery: normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery)\n    };\n    hookInput.mangoQuery.selector._deleted = {\n      $eq: false\n    };\n    if (hookInput.mangoQuery.index) {\n      hookInput.mangoQuery.index.unshift('_deleted');\n    }\n    runPluginHooks('prePrepareQuery', hookInput);\n    var value = prepareQuery(this.collection.schema.jsonSchema, hookInput.mangoQuery);\n    this.getPreparedQuery = () => value;\n    return value;\n  }\n\n  /**\n   * returns true if the document matches the query,\n   * does not use the 'skip' and 'limit'\n   */;\n  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {\n    // if doc is deleted, it cannot match\n    if (docData._deleted) {\n      return false;\n    }\n    return this.queryMatcher(docData);\n  }\n\n  /**\n   * deletes all found documents\n   * @return promise with deleted documents\n   */;\n  _proto.remove = async function remove() {\n    var docs = await this.exec();\n    if (Array.isArray(docs)) {\n      var result = await this.collection.bulkRemove(docs);\n      if (result.error.length > 0) {\n        throw rxStorageWriteErrorToRxError(result.error[0]);\n      } else {\n        return result.success;\n      }\n    } else {\n      return docs.remove();\n    }\n  };\n  _proto.incrementalRemove = function incrementalRemove() {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.incrementalRemove());\n  }\n\n  /**\n   * helper function to transform RxQueryBase to RxQuery type\n   */;\n  /**\n   * updates all found documents\n   * @overwritten by plugin (optional)\n   */\n  _proto.update = function update(_updateObj) {\n    throw pluginMissing('update');\n  };\n  _proto.patch = function patch(_patch) {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.patch(_patch));\n  };\n  _proto.incrementalPatch = function incrementalPatch(patch) {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.incrementalPatch(patch));\n  };\n  _proto.modify = function modify(mutationFunction) {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.modify(mutationFunction));\n  };\n  _proto.incrementalModify = function incrementalModify(mutationFunction) {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.incrementalModify(mutationFunction));\n  }\n\n  // we only set some methods of query-builder here\n  // because the others depend on these ones\n  ;\n  _proto.where = function where(_queryObj) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.sort = function sort(_params) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.skip = function skip(_amount) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.limit = function limit(_amount) {\n    throw pluginMissing('query-builder');\n  };\n  return _createClass(RxQueryBase, [{\n    key: \"$\",\n    get: function () {\n      if (!this._$) {\n        var results$ = this.collection.eventBulks$.pipe(\n        /**\n         * Performance shortcut.\n         * Changes to local documents are not relevant for the query.\n         */\n        filter(bulk => !bulk.isLocal),\n        /**\n         * Start once to ensure the querying also starts\n         * when there where no changes.\n         */\n        startWith(null),\n        // ensure query results are up to date.\n        mergeMap(() => _ensureEqual(this)),\n        // use the current result set, written by _ensureEqual().\n        map(() => this._result),\n        // do not run stuff above for each new subscriber, only once.\n        shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),\n        // do not proceed if result set has not changed.\n        distinctUntilChanged((prev, curr) => {\n          if (prev && prev.time === ensureNotFalsy(curr).time) {\n            return true;\n          } else {\n            return false;\n          }\n        }), filter(result => !!result),\n        /**\n         * Map the result set to a single RxDocument or an array,\n         * depending on query type\n         */\n        map(result => {\n          return ensureNotFalsy(result).getValue();\n        }));\n        this._$ = merge(results$,\n        /**\n         * Also add the refCount$ to the query observable\n         * to allow us to count the amount of subscribers.\n         */\n        this.refCount$.pipe(filter(() => false)));\n      }\n      return this._$;\n    }\n  }, {\n    key: \"$$\",\n    get: function () {\n      var reactivity = this.collection.database.getReactivityFactory();\n      return reactivity.fromObservable(this.$, undefined, this.collection.database);\n    }\n\n    // stores the changeEvent-number of the last handled change-event\n\n    /**\n     * ensures that the exec-runs\n     * are not run in parallel\n     */\n  }, {\n    key: \"queryMatcher\",\n    get: function () {\n      var schema = this.collection.schema.jsonSchema;\n      var normalizedQuery = normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery);\n      return overwriteGetterForCaching(this, 'queryMatcher', getQueryMatcher(schema, normalizedQuery));\n    }\n  }, {\n    key: \"asRxQuery\",\n    get: function () {\n      return this;\n    }\n  }]);\n}();\nexport function _getDefaultQuery() {\n  return {\n    selector: {}\n  };\n}\n\n/**\n * run this query through the QueryCache\n */\nexport function tunnelQueryCache(rxQuery) {\n  return rxQuery.collection._queryCache.getByQuery(rxQuery);\n}\nexport function createRxQuery(op, queryObj, collection, other) {\n  runPluginHooks('preCreateRxQuery', {\n    op,\n    queryObj,\n    collection,\n    other\n  });\n  var ret = new RxQueryBase(op, queryObj, collection, other);\n\n  // ensure when created with same params, only one is created\n  ret = tunnelQueryCache(ret);\n  triggerCacheReplacement(collection);\n  return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery) {\n  var currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n  if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nasync function _ensureEqual(rxQuery) {\n  if (rxQuery.collection.awaitBeforeReads.size > 0) {\n    await Promise.all(Array.from(rxQuery.collection.awaitBeforeReads).map(fn => fn()));\n  }\n\n  // Optimisation shortcut\n  if (rxQuery.collection.database.closed || _isResultsInSync(rxQuery)) {\n    return false;\n  }\n  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(() => __ensureEqual(rxQuery));\n  return rxQuery._ensureEqualQueue;\n}\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nfunction __ensureEqual(rxQuery) {\n  rxQuery._lastEnsureEqual = now();\n\n  /**\n   * Optimisation shortcuts\n   */\n  if (\n  // db is closed\n  rxQuery.collection.database.closed ||\n  // nothing happened since last run\n  _isResultsInSync(rxQuery)) {\n    return PROMISE_RESOLVE_FALSE;\n  }\n  var ret = false;\n  var mustReExec = false; // if this becomes true, a whole execution over the database is made\n  if (rxQuery._latestChangeEvent === -1) {\n    // have not executed yet -> must run\n    mustReExec = true;\n  }\n\n  /**\n   * try to use EventReduce to calculate the new results\n   */\n  if (!mustReExec) {\n    var missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n    if (missedChangeEvents === null) {\n      // changeEventBuffer is of bounds -> we must re-execute over the database\n      mustReExec = true;\n    } else {\n      rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n      var runChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);\n      if (rxQuery.op === 'count') {\n        // 'count' query\n        var previousCount = ensureNotFalsy(rxQuery._result).count;\n        var newCount = previousCount;\n        runChangeEvents.forEach(cE => {\n          var didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);\n          var doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);\n          if (!didMatchBefore && doesMatchNow) {\n            newCount++;\n          }\n          if (didMatchBefore && !doesMatchNow) {\n            newCount--;\n          }\n        });\n        if (newCount !== previousCount) {\n          ret = true; // true because results changed\n          rxQuery._setResultData(newCount);\n        }\n      } else {\n        // 'find' or 'findOne' query\n        var eventReduceResult = calculateNewResults(rxQuery, runChangeEvents);\n        if (eventReduceResult.runFullQueryAgain) {\n          // could not calculate the new results, execute must be done\n          mustReExec = true;\n        } else if (eventReduceResult.changed) {\n          // we got the new results, we do not have to re-execute, mustReExec stays false\n          ret = true; // true because results changed\n          rxQuery._setResultData(eventReduceResult.newResults);\n        }\n      }\n    }\n  }\n\n  // oh no we have to re-execute the whole query over the database\n  if (mustReExec) {\n    return rxQuery._execOverDatabase().then(newResultData => {\n      /**\n       * The RxStorage is defined to always first emit events and then return\n       * on bulkWrite() calls. So here we have to use the counter AFTER the execOverDatabase()\n       * has been run, not the one from before.\n       */\n      rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.getCounter();\n\n      // A count query needs a different has-changed check.\n      if (typeof newResultData === 'number') {\n        if (!rxQuery._result || newResultData !== rxQuery._result.count) {\n          ret = true;\n          rxQuery._setResultData(newResultData);\n        }\n        return ret;\n      }\n      if (!rxQuery._result || !areRxDocumentArraysEqual(rxQuery.collection.schema.primaryPath, newResultData, rxQuery._result.docsData)) {\n        ret = true; // true because results changed\n        rxQuery._setResultData(newResultData);\n      }\n      return ret;\n    });\n  }\n  return Promise.resolve(ret); // true if results have changed\n}\n\n/**\n * Runs the query over the storage instance\n * of the collection.\n * Does some optimizations to ensure findById is used\n * when specific queries are used.\n */\nexport async function queryCollection(rxQuery) {\n  var docs = [];\n  var collection = rxQuery.collection;\n\n  /**\n   * Optimizations shortcut.\n   * If query is find-one-document-by-id,\n   * then we do not have to use the slow query() method\n   * but instead can use findDocumentsById()\n   */\n  if (rxQuery.isFindOneByIdQuery) {\n    if (Array.isArray(rxQuery.isFindOneByIdQuery)) {\n      var docIds = rxQuery.isFindOneByIdQuery;\n      docIds = docIds.filter(docId => {\n        // first try to fill from docCache\n        var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n        if (docData) {\n          if (!docData._deleted) {\n            docs.push(docData);\n          }\n          return false;\n        } else {\n          return true;\n        }\n      });\n      // otherwise get from storage\n      if (docIds.length > 0) {\n        var docsFromStorage = await collection.storageInstance.findDocumentsById(docIds, false);\n        appendToArray(docs, docsFromStorage);\n      }\n    } else {\n      var docId = rxQuery.isFindOneByIdQuery;\n\n      // first try to fill from docCache\n      var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n      if (!docData) {\n        // otherwise get from storage\n        var fromStorageList = await collection.storageInstance.findDocumentsById([docId], false);\n        if (fromStorageList[0]) {\n          docData = fromStorageList[0];\n        }\n      }\n      if (docData && !docData._deleted) {\n        docs.push(docData);\n      }\n    }\n  } else {\n    var preparedQuery = rxQuery.getPreparedQuery();\n    var queryResult = await collection.storageInstance.query(preparedQuery);\n    docs = queryResult.documents;\n  }\n  return docs;\n}\n\n/**\n * Returns true if the given query\n * selects exactly one document by its id.\n * Used to optimize performance because these kind of\n * queries do not have to run over an index and can use get-by-id instead.\n * Returns false if no query of that kind.\n * Returns the document id otherwise.\n */\nexport function isFindOneByIdQuery(primaryPath, query) {\n  // must have exactly one operator which must be $eq || $in\n  if (!query.skip && query.selector && Object.keys(query.selector).length === 1 && query.selector[primaryPath]) {\n    var value = query.selector[primaryPath];\n    if (typeof value === 'string') {\n      return value;\n    } else if (Object.keys(value).length === 1 && typeof value.$eq === 'string') {\n      return value.$eq;\n    }\n\n    // same with $in string arrays\n    if (Object.keys(value).length === 1 && Array.isArray(value.$eq) &&\n    // must only contain strings\n    !value.$eq.find(r => typeof r !== 'string')) {\n      return value.$eq;\n    }\n  }\n  return false;\n}\nexport function isRxQuery(obj) {\n  return obj instanceof RxQueryBase;\n}\n//# sourceMappingURL=rx-query.js.map","import { newRxError } from \"./rx-error.js\";\nimport { appendToArray, ensureNotFalsy, flatClone, getProperty, isMaybeReadonlyArray, REGEX_ALL_DOTS, RX_META_LWT_MINIMUM, sortObject, trimDots } from \"./plugins/utils/index.js\";\n/**\n * Helper function to create a valid RxJsonSchema\n * with a given version.\n */\nexport function getPseudoSchemaForVersion(version, primaryKey) {\n  var pseudoSchema = fillWithDefaultSettings({\n    version,\n    type: 'object',\n    primaryKey: primaryKey,\n    properties: {\n      [primaryKey]: {\n        type: 'string',\n        maxLength: 100\n      },\n      value: {\n        type: 'string'\n      }\n    },\n    indexes: [[primaryKey]],\n    required: [primaryKey]\n  });\n  return pseudoSchema;\n}\n\n/**\n * Returns the sub-schema for a given path\n */\nexport function getSchemaByObjectPath(rxJsonSchema, path) {\n  var usePath = path;\n  usePath = usePath.replace(REGEX_ALL_DOTS, '.properties.');\n  usePath = 'properties.' + usePath;\n  usePath = trimDots(usePath);\n  var ret = getProperty(rxJsonSchema, usePath);\n  return ret;\n}\nexport function fillPrimaryKey(primaryPath, jsonSchema, documentData) {\n  // optimization shortcut.\n  if (typeof jsonSchema.primaryKey === 'string') {\n    return documentData;\n  }\n  var newPrimary = getComposedPrimaryKeyOfDocumentData(jsonSchema, documentData);\n  var existingPrimary = documentData[primaryPath];\n  if (existingPrimary && existingPrimary !== newPrimary) {\n    throw newRxError('DOC19', {\n      args: {\n        documentData,\n        existingPrimary,\n        newPrimary\n      },\n      schema: jsonSchema\n    });\n  }\n  documentData[primaryPath] = newPrimary;\n  return documentData;\n}\nexport function getPrimaryFieldOfPrimaryKey(primaryKey) {\n  if (typeof primaryKey === 'string') {\n    return primaryKey;\n  } else {\n    return primaryKey.key;\n  }\n}\nexport function getLengthOfPrimaryKey(schema) {\n  var primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n  var schemaPart = getSchemaByObjectPath(schema, primaryPath);\n  return ensureNotFalsy(schemaPart.maxLength);\n}\n\n/**\n * Returns the composed primaryKey of a document by its data.\n */\nexport function getComposedPrimaryKeyOfDocumentData(jsonSchema, documentData) {\n  if (typeof jsonSchema.primaryKey === 'string') {\n    return documentData[jsonSchema.primaryKey];\n  }\n  var compositePrimary = jsonSchema.primaryKey;\n  return compositePrimary.fields.map(field => {\n    var value = getProperty(documentData, field);\n    if (typeof value === 'undefined') {\n      throw newRxError('DOC18', {\n        args: {\n          field,\n          documentData\n        }\n      });\n    }\n    return value;\n  }).join(compositePrimary.separator);\n}\n\n/**\n * Normalize the RxJsonSchema.\n * We need this to ensure everything is set up properly\n * and we have the same hash on schemas that represent the same value but\n * have different json.\n *\n * - Orders the schemas attributes by alphabetical order\n * - Adds the primaryKey to all indexes that do not contain the primaryKey\n * - We need this for deterministic sort order on all queries, which is required for event-reduce to work.\n *\n * @return RxJsonSchema - ordered and filled\n */\nexport function normalizeRxJsonSchema(jsonSchema) {\n  var normalizedSchema = sortObject(jsonSchema, true);\n  return normalizedSchema;\n}\n\n/**\n * If the schema does not specify any index,\n * we add this index so we at least can run RxQuery()\n * and only select non-deleted fields.\n */\nexport function getDefaultIndex(primaryPath) {\n  return ['_deleted', primaryPath];\n}\n\n/**\n * fills the schema-json with default-settings\n * @return cloned schemaObj\n */\nexport function fillWithDefaultSettings(schemaObj) {\n  schemaObj = flatClone(schemaObj);\n  var primaryPath = getPrimaryFieldOfPrimaryKey(schemaObj.primaryKey);\n  schemaObj.properties = flatClone(schemaObj.properties);\n\n  // additionalProperties is always false\n  schemaObj.additionalProperties = false;\n\n  // fill with key-compression-state ()\n  if (!Object.prototype.hasOwnProperty.call(schemaObj, 'keyCompression')) {\n    schemaObj.keyCompression = false;\n  }\n\n  // indexes must be array\n  schemaObj.indexes = schemaObj.indexes ? schemaObj.indexes.slice(0) : [];\n\n  // required must be array\n  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];\n\n  // encrypted must be array\n  schemaObj.encrypted = schemaObj.encrypted ? schemaObj.encrypted.slice(0) : [];\n\n  // add _rev\n  schemaObj.properties._rev = {\n    type: 'string',\n    minLength: 1\n  };\n\n  // add attachments\n  schemaObj.properties._attachments = {\n    type: 'object'\n  };\n\n  // add deleted flag\n  schemaObj.properties._deleted = {\n    type: 'boolean'\n  };\n\n  // add meta property\n  schemaObj.properties._meta = RX_META_SCHEMA;\n\n  /**\n   * meta fields are all required\n   */\n  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];\n  schemaObj.required.push('_deleted');\n  schemaObj.required.push('_rev');\n  schemaObj.required.push('_meta');\n  schemaObj.required.push('_attachments');\n\n  // final fields are always required\n  var finalFields = getFinalFields(schemaObj);\n  appendToArray(schemaObj.required, finalFields);\n  schemaObj.required = schemaObj.required.filter(field => !field.includes('.')).filter((elem, pos, arr) => arr.indexOf(elem) === pos); // unique;\n\n  // version is 0 by default\n  schemaObj.version = schemaObj.version || 0;\n  var useIndexes = schemaObj.indexes.map(index => {\n    var arIndex = isMaybeReadonlyArray(index) ? index.slice(0) : [index];\n    /**\n     * Append primary key to indexes that do not contain the primaryKey.\n     * All indexes must have the primaryKey to ensure a deterministic sort order.\n     */\n    if (!arIndex.includes(primaryPath)) {\n      arIndex.push(primaryPath);\n    }\n\n    // add _deleted flag to all indexes so we can query only non-deleted fields\n    // in RxDB itself\n    if (arIndex[0] !== '_deleted') {\n      arIndex.unshift('_deleted');\n    }\n    return arIndex;\n  });\n  if (useIndexes.length === 0) {\n    useIndexes.push(getDefaultIndex(primaryPath));\n  }\n\n  // we need this index for the getChangedDocumentsSince() method\n  useIndexes.push(['_meta.lwt', primaryPath]);\n\n  // also add the internalIndexes\n  if (schemaObj.internalIndexes) {\n    schemaObj.internalIndexes.map(idx => {\n      useIndexes.push(idx);\n    });\n  }\n\n  // make indexes unique\n  var hasIndex = new Set();\n  useIndexes.filter(index => {\n    var indexStr = index.join(',');\n    if (hasIndex.has(indexStr)) {\n      return false;\n    } else {\n      hasIndex.add(indexStr);\n      return true;\n    }\n  });\n  schemaObj.indexes = useIndexes;\n  return schemaObj;\n}\nexport var RX_META_SCHEMA = {\n  type: 'object',\n  properties: {\n    /**\n     * The last-write time.\n     * Unix time in milliseconds.\n     */\n    lwt: {\n      type: 'number',\n      /**\n       * We use 1 as minimum so that the value is never falsy.\n       */\n      minimum: RX_META_LWT_MINIMUM,\n      maximum: 1000000000000000,\n      multipleOf: 0.01\n    }\n  },\n  /**\n   * Additional properties are allowed\n   * and can be used by plugins to set various flags.\n   */\n  additionalProperties: true,\n  required: ['lwt']\n};\n\n/**\n * returns the final-fields of the schema\n * @return field-names of the final-fields\n */\nexport function getFinalFields(jsonSchema) {\n  var ret = Object.keys(jsonSchema.properties).filter(key => jsonSchema.properties[key].final);\n\n  // primary is also final\n  var primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);\n  ret.push(primaryPath);\n\n  // fields of composite primary are final\n  if (typeof jsonSchema.primaryKey !== 'string') {\n    jsonSchema.primaryKey.fields.forEach(field => ret.push(field));\n  }\n  return ret;\n}\n\n/**\n * fills all unset fields with default-values if set\n * @hotPath\n */\nexport function fillObjectWithDefaults(rxSchema, obj) {\n  var defaultKeys = Object.keys(rxSchema.defaultValues);\n  for (var i = 0; i < defaultKeys.length; ++i) {\n    var key = defaultKeys[i];\n    if (!Object.prototype.hasOwnProperty.call(obj, key) || typeof obj[key] === 'undefined') {\n      obj[key] = rxSchema.defaultValues[key];\n    }\n  }\n  return obj;\n}\nexport var DEFAULT_CHECKPOINT_SCHEMA = {\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string'\n    },\n    lwt: {\n      type: 'number'\n    }\n  },\n  required: ['id', 'lwt'],\n  additionalProperties: false\n};\n//# sourceMappingURL=rx-schema-helper.js.map","import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { overwriteGetterForCaching, isMaybeReadonlyArray, deepEqual } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData, getFinalFields, getPrimaryFieldOfPrimaryKey, getSchemaByObjectPath, normalizeRxJsonSchema } from \"./rx-schema-helper.js\";\nimport { overwritable } from \"./overwritable.js\";\nexport var RxSchema = /*#__PURE__*/function () {\n  function RxSchema(jsonSchema, hashFunction) {\n    this.jsonSchema = jsonSchema;\n    this.hashFunction = hashFunction;\n    this.indexes = getIndexes(this.jsonSchema);\n\n    // primary is always required\n    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.jsonSchema.primaryKey);\n\n    /**\n     * Many people accidentally put in wrong schema state\n     * without the dev-mode plugin, so we need this check here\n     * even in non-dev-mode.\n     */\n    if (!jsonSchema.properties[this.primaryPath].maxLength) {\n      throw newRxError('SC39', {\n        schema: jsonSchema\n      });\n    }\n    this.finalFields = getFinalFields(this.jsonSchema);\n  }\n  var _proto = RxSchema.prototype;\n  /**\n   * checks if a given change on a document is allowed\n   * Ensures that:\n   * - final fields are not modified\n   * @throws {Error} if not valid\n   */\n  _proto.validateChange = function validateChange(dataBefore, dataAfter) {\n    this.finalFields.forEach(fieldName => {\n      if (!deepEqual(dataBefore[fieldName], dataAfter[fieldName])) {\n        throw newRxError('DOC9', {\n          dataBefore,\n          dataAfter,\n          fieldName,\n          schema: this.jsonSchema\n        });\n      }\n    });\n  }\n\n  /**\n   * creates the schema-based document-prototype,\n   * see RxCollection.getDocumentPrototype()\n   */;\n  _proto.getDocumentPrototype = function getDocumentPrototype() {\n    var proto = {};\n\n    /**\n     * On the top level, we know all keys\n     * and therefore do not have to create a new Proxy object\n     * for each document. Instead we define the getter in the prototype once.\n     */\n    var pathProperties = getSchemaByObjectPath(this.jsonSchema, '');\n    Object.keys(pathProperties).forEach(key => {\n      var fullPath = key;\n\n      // getter - value\n      proto.__defineGetter__(key, function () {\n        if (!this.get || typeof this.get !== 'function') {\n          /**\n           * When an object gets added to the state of a vuejs-component,\n           * it happens that this getter is called with another scope.\n           * To prevent errors, we have to return undefined in this case\n           */\n          return undefined;\n        }\n        var ret = this.get(fullPath);\n        return ret;\n      });\n      // getter - observable$\n      Object.defineProperty(proto, key + '$', {\n        get: function () {\n          return this.get$(fullPath);\n        },\n        enumerable: false,\n        configurable: false\n      });\n      // getter - reactivity$$\n      Object.defineProperty(proto, key + '$$', {\n        get: function () {\n          return this.get$$(fullPath);\n        },\n        enumerable: false,\n        configurable: false\n      });\n      // getter - populate_\n      Object.defineProperty(proto, key + '_', {\n        get: function () {\n          return this.populate(fullPath);\n        },\n        enumerable: false,\n        configurable: false\n      });\n    });\n    overwriteGetterForCaching(this, 'getDocumentPrototype', () => proto);\n    return proto;\n  };\n  _proto.getPrimaryOfDocumentData = function getPrimaryOfDocumentData(documentData) {\n    return getComposedPrimaryKeyOfDocumentData(this.jsonSchema, documentData);\n  };\n  return _createClass(RxSchema, [{\n    key: \"version\",\n    get: function () {\n      return this.jsonSchema.version;\n    }\n  }, {\n    key: \"defaultValues\",\n    get: function () {\n      var values = {};\n      Object.entries(this.jsonSchema.properties).filter(([, v]) => Object.prototype.hasOwnProperty.call(v, 'default')).forEach(([k, v]) => values[k] = v.default);\n      return overwriteGetterForCaching(this, 'defaultValues', values);\n    }\n\n    /**\n     * @overrides itself on the first call\n     */\n  }, {\n    key: \"hash\",\n    get: function () {\n      return overwriteGetterForCaching(this, 'hash', this.hashFunction(JSON.stringify(this.jsonSchema)));\n    }\n  }]);\n}();\nexport function getIndexes(jsonSchema) {\n  return (jsonSchema.indexes || []).map(index => isMaybeReadonlyArray(index) ? index : [index]);\n}\n\n/**\n * array with previous version-numbers\n */\nexport function getPreviousVersions(schema) {\n  var version = schema.version ? schema.version : 0;\n  var c = 0;\n  return new Array(version).fill(0).map(() => c++);\n}\nexport function createRxSchema(jsonSchema, hashFunction, runPreCreateHooks = true) {\n  if (runPreCreateHooks) {\n    runPluginHooks('preCreateRxSchema', jsonSchema);\n  }\n  var useJsonSchema = fillWithDefaultSettings(jsonSchema);\n  useJsonSchema = normalizeRxJsonSchema(useJsonSchema);\n  overwritable.deepFreezeWhenDevMode(useJsonSchema);\n  var schema = new RxSchema(useJsonSchema, hashFunction);\n  runPluginHooks('createRxSchema', schema);\n  return schema;\n}\nexport function isRxSchema(obj) {\n  return obj instanceof RxSchema;\n}\n\n/**\n * Used as helper function the generate the document type out of the schema via typescript.\n * @link https://github.com/pubkey/rxdb/discussions/3467\n */\nexport function toTypedRxJsonSchema(schema) {\n  return schema;\n}\n//# sourceMappingURL=rx-schema.js.map","/**\n * Helper functions for accessing the RxStorage instances.\n */\n\nimport { overwritable } from \"./overwritable.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { getPrimaryFieldOfPrimaryKey } from \"./rx-schema-helper.js\";\nimport { PROMISE_RESOLVE_TRUE, RXDB_VERSION, RX_META_LWT_MINIMUM, appendToArray, createRevision, ensureNotFalsy, flatClone, getFromMapOrCreate, lastOfArray, now, promiseWait, randomToken } from \"./plugins/utils/index.js\";\nimport { filter, map, startWith, switchMap } from 'rxjs';\nimport { normalizeMangoQuery, prepareQuery } from \"./rx-query-helper.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nexport var INTERNAL_STORAGE_NAME = '_rxdb_internal';\nexport var RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = 'rxdatabase_storage_local';\nexport async function getSingleDocument(storageInstance, documentId) {\n  var results = await storageInstance.findDocumentsById([documentId], false);\n  var doc = results[0];\n  if (doc) {\n    return doc;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Writes a single document,\n * throws RxStorageBulkWriteError on failure\n */\nexport async function writeSingle(instance, writeRow, context) {\n  var writeResult = await instance.bulkWrite([writeRow], context);\n  if (writeResult.error.length > 0) {\n    var error = writeResult.error[0];\n    throw error;\n  } else {\n    var primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n    var success = getWrittenDocumentsFromBulkWriteResponse(primaryPath, [writeRow], writeResult);\n    var ret = success[0];\n    return ret;\n  }\n}\n\n/**\n * Observe the plain document data of a single document.\n * Do not forget to unsubscribe.\n */\nexport function observeSingle(storageInstance, documentId) {\n  var firstFindPromise = getSingleDocument(storageInstance, documentId);\n  var ret = storageInstance.changeStream().pipe(map(evBulk => evBulk.events.find(ev => ev.documentId === documentId)), filter(ev => !!ev), map(ev => Promise.resolve(ensureNotFalsy(ev).documentData)), startWith(firstFindPromise), switchMap(v => v), filter(v => !!v));\n  return ret;\n}\n\n/**\n * Checkpoints must be stackable over another.\n * This is required form some RxStorage implementations\n * like the sharding plugin, where a checkpoint only represents\n * the document state from some, but not all shards.\n */\nexport function stackCheckpoints(checkpoints) {\n  return Object.assign({}, ...checkpoints);\n}\nexport function throwIfIsStorageWriteError(collection, documentId, writeData, error) {\n  if (error) {\n    if (error.status === 409) {\n      throw newRxError('CONFLICT', {\n        collection: collection.name,\n        id: documentId,\n        writeError: error,\n        data: writeData\n      });\n    } else if (error.status === 422) {\n      throw newRxError('VD2', {\n        collection: collection.name,\n        id: documentId,\n        writeError: error,\n        data: writeData\n      });\n    } else {\n      throw error;\n    }\n  }\n}\n\n/**\n * Analyzes a list of BulkWriteRows and determines\n * which documents must be inserted, updated or deleted\n * and which events must be emitted and which documents cause a conflict\n * and must not be written.\n * Used as helper inside of some RxStorage implementations.\n * @hotPath The performance of this function is critical\n */\nexport function categorizeBulkWriteRows(storageInstance, primaryPath,\n/**\n * Current state of the documents\n * inside of the storage. Used to determine\n * which writes cause conflicts.\n * This must be a Map for better performance.\n */\ndocsInDb,\n/**\n * The write rows that are passed to\n * RxStorageInstance().bulkWrite().\n */\nbulkWriteRows, context,\n/**\n * Used by some storages for better performance.\n * For example when get-by-id and insert/update can run in parallel.\n */\nonInsert, onUpdate) {\n  var hasAttachments = !!storageInstance.schema.attachments;\n  var bulkInsertDocs = [];\n  var bulkUpdateDocs = [];\n  var errors = [];\n  var eventBulkId = randomToken(10);\n  var eventBulk = {\n    id: eventBulkId,\n    events: [],\n    checkpoint: null,\n    context\n  };\n  var eventBulkEvents = eventBulk.events;\n  var attachmentsAdd = [];\n  var attachmentsRemove = [];\n  var attachmentsUpdate = [];\n  var hasDocsInDb = docsInDb.size > 0;\n  var newestRow;\n\n  /**\n   * @performance is really important in this loop!\n   */\n  var rowAmount = bulkWriteRows.length;\n  var _loop = function () {\n    var writeRow = bulkWriteRows[rowId];\n\n    // use these variables to have less property accesses\n    var document = writeRow.document;\n    var previous = writeRow.previous;\n    var docId = document[primaryPath];\n    var documentDeleted = document._deleted;\n    var previousDeleted = previous && previous._deleted;\n    var documentInDb = undefined;\n    if (hasDocsInDb) {\n      documentInDb = docsInDb.get(docId);\n    }\n    var attachmentError;\n    if (!documentInDb) {\n      /**\n       * It is possible to insert already deleted documents,\n       * this can happen on replication.\n       */\n      var insertedIsDeleted = documentDeleted ? true : false;\n      if (hasAttachments) {\n        Object.entries(document._attachments).forEach(([attachmentId, attachmentData]) => {\n          if (!attachmentData.data) {\n            attachmentError = {\n              documentId: docId,\n              isError: true,\n              status: 510,\n              writeRow,\n              attachmentId\n            };\n            errors.push(attachmentError);\n          } else {\n            attachmentsAdd.push({\n              documentId: docId,\n              attachmentId,\n              attachmentData: attachmentData,\n              digest: attachmentData.digest\n            });\n          }\n        });\n      }\n      if (!attachmentError) {\n        if (hasAttachments) {\n          bulkInsertDocs.push(stripAttachmentsDataFromRow(writeRow));\n          if (onInsert) {\n            onInsert(document);\n          }\n        } else {\n          bulkInsertDocs.push(writeRow);\n          if (onInsert) {\n            onInsert(document);\n          }\n        }\n        newestRow = writeRow;\n      }\n      if (!insertedIsDeleted) {\n        var event = {\n          documentId: docId,\n          operation: 'INSERT',\n          documentData: hasAttachments ? stripAttachmentsDataFromDocument(document) : document,\n          previousDocumentData: hasAttachments && previous ? stripAttachmentsDataFromDocument(previous) : previous\n        };\n        eventBulkEvents.push(event);\n      }\n    } else {\n      // update existing document\n      var revInDb = documentInDb._rev;\n\n      /**\n       * Check for conflict\n       */\n      if (!previous || !!previous && revInDb !== previous._rev) {\n        // is conflict error\n        var err = {\n          isError: true,\n          status: 409,\n          documentId: docId,\n          writeRow: writeRow,\n          documentInDb\n        };\n        errors.push(err);\n        return 1; // continue\n      }\n\n      // handle attachments data\n\n      var updatedRow = hasAttachments ? stripAttachmentsDataFromRow(writeRow) : writeRow;\n      if (hasAttachments) {\n        if (documentDeleted) {\n          /**\n           * Deleted documents must have cleared all their attachments.\n           */\n          if (previous) {\n            Object.keys(previous._attachments).forEach(attachmentId => {\n              attachmentsRemove.push({\n                documentId: docId,\n                attachmentId,\n                digest: ensureNotFalsy(previous)._attachments[attachmentId].digest\n              });\n            });\n          }\n        } else {\n          // first check for errors\n          Object.entries(document._attachments).find(([attachmentId, attachmentData]) => {\n            var previousAttachmentData = previous ? previous._attachments[attachmentId] : undefined;\n            if (!previousAttachmentData && !attachmentData.data) {\n              attachmentError = {\n                documentId: docId,\n                documentInDb: documentInDb,\n                isError: true,\n                status: 510,\n                writeRow,\n                attachmentId\n              };\n            }\n            return true;\n          });\n          if (!attachmentError) {\n            Object.entries(document._attachments).forEach(([attachmentId, attachmentData]) => {\n              var previousAttachmentData = previous ? previous._attachments[attachmentId] : undefined;\n              if (!previousAttachmentData) {\n                attachmentsAdd.push({\n                  documentId: docId,\n                  attachmentId,\n                  attachmentData: attachmentData,\n                  digest: attachmentData.digest\n                });\n              } else {\n                var newDigest = updatedRow.document._attachments[attachmentId].digest;\n                if (attachmentData.data &&\n                /**\n                 * Performance shortcut,\n                 * do not update the attachment data if it did not change.\n                 */\n                previousAttachmentData.digest !== newDigest) {\n                  attachmentsUpdate.push({\n                    documentId: docId,\n                    attachmentId,\n                    attachmentData: attachmentData,\n                    digest: attachmentData.digest\n                  });\n                }\n              }\n            });\n          }\n        }\n      }\n      if (attachmentError) {\n        errors.push(attachmentError);\n      } else {\n        if (hasAttachments) {\n          bulkUpdateDocs.push(stripAttachmentsDataFromRow(updatedRow));\n          if (onUpdate) {\n            onUpdate(document);\n          }\n        } else {\n          bulkUpdateDocs.push(updatedRow);\n          if (onUpdate) {\n            onUpdate(document);\n          }\n        }\n        newestRow = updatedRow;\n      }\n      var eventDocumentData = null;\n      var previousEventDocumentData = null;\n      var operation = null;\n      if (previousDeleted && !documentDeleted) {\n        operation = 'INSERT';\n        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document) : document;\n      } else if (previous && !previousDeleted && !documentDeleted) {\n        operation = 'UPDATE';\n        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document) : document;\n        previousEventDocumentData = previous;\n      } else if (documentDeleted) {\n        operation = 'DELETE';\n        eventDocumentData = ensureNotFalsy(document);\n        previousEventDocumentData = previous;\n      } else {\n        throw newRxError('SNH', {\n          args: {\n            writeRow\n          }\n        });\n      }\n      var _event = {\n        documentId: docId,\n        documentData: eventDocumentData,\n        previousDocumentData: previousEventDocumentData,\n        operation: operation\n      };\n      eventBulkEvents.push(_event);\n    }\n  };\n  for (var rowId = 0; rowId < rowAmount; rowId++) {\n    if (_loop()) continue;\n  }\n  return {\n    bulkInsertDocs,\n    bulkUpdateDocs,\n    newestRow,\n    errors,\n    eventBulk,\n    attachmentsAdd,\n    attachmentsRemove,\n    attachmentsUpdate\n  };\n}\nexport function stripAttachmentsDataFromRow(writeRow) {\n  return {\n    previous: writeRow.previous,\n    document: stripAttachmentsDataFromDocument(writeRow.document)\n  };\n}\nexport function getAttachmentSize(attachmentBase64String) {\n  return atob(attachmentBase64String).length;\n}\n\n/**\n * Used in custom RxStorage implementations.\n */\nexport function attachmentWriteDataToNormalData(writeData) {\n  var data = writeData.data;\n  if (!data) {\n    return writeData;\n  }\n  var ret = {\n    length: getAttachmentSize(data),\n    digest: writeData.digest,\n    type: writeData.type\n  };\n  return ret;\n}\nexport function stripAttachmentsDataFromDocument(doc) {\n  if (!doc._attachments || Object.keys(doc._attachments).length === 0) {\n    return doc;\n  }\n  var useDoc = flatClone(doc);\n  useDoc._attachments = {};\n  Object.entries(doc._attachments).forEach(([attachmentId, attachmentData]) => {\n    useDoc._attachments[attachmentId] = attachmentWriteDataToNormalData(attachmentData);\n  });\n  return useDoc;\n}\n\n/**\n * Flat clone the document data\n * and also the _meta field.\n * Used many times when we want to change the meta\n * during replication etc.\n */\nexport function flatCloneDocWithMeta(doc) {\n  return Object.assign({}, doc, {\n    _meta: flatClone(doc._meta)\n  });\n}\n/**\n * Wraps the normal storageInstance of a RxCollection\n * to ensure that all access is properly using the hooks\n * and other data transformations and also ensure that database.lockedRun()\n * is used properly.\n */\nexport function getWrappedStorageInstance(database, storageInstance,\n/**\n * The original RxJsonSchema\n * before it was mutated by hooks.\n */\nrxJsonSchema) {\n  overwritable.deepFreezeWhenDevMode(rxJsonSchema);\n  var primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);\n  var ret = {\n    originalStorageInstance: storageInstance,\n    schema: storageInstance.schema,\n    internals: storageInstance.internals,\n    collectionName: storageInstance.collectionName,\n    databaseName: storageInstance.databaseName,\n    options: storageInstance.options,\n    async bulkWrite(rows, context) {\n      var databaseToken = database.token;\n      var toStorageWriteRows = new Array(rows.length);\n      /**\n       * Use the same timestamp for all docs of this rows-set.\n       * This improves performance because calling Date.now() inside of the now() function\n       * is too costly.\n       */\n      var time = now();\n      for (var index = 0; index < rows.length; index++) {\n        var writeRow = rows[index];\n        var document = flatCloneDocWithMeta(writeRow.document);\n        document._meta.lwt = time;\n\n        /**\n         * Yes we really want to set the revision here.\n         * If you make a plugin that relies on having its own revision\n         * stored into the storage, use this.originalStorageInstance.bulkWrite() instead.\n         */\n        var previous = writeRow.previous;\n        document._rev = createRevision(databaseToken, previous);\n        toStorageWriteRows[index] = {\n          document,\n          previous\n        };\n      }\n      runPluginHooks('preStorageWrite', {\n        storageInstance: this.originalStorageInstance,\n        rows: toStorageWriteRows\n      });\n      var writeResult = await database.lockedRun(() => storageInstance.bulkWrite(toStorageWriteRows, context));\n\n      /**\n       * The RxStorageInstance MUST NOT allow to insert already _deleted documents,\n       * without sending the previous document version.\n       * But for better developer experience, RxDB does allow to re-insert deleted documents.\n       * We do this by automatically fixing the conflict errors for that case\n       * by running another bulkWrite() and merging the results.\n       * @link https://github.com/pubkey/rxdb/pull/3839\n      */\n      var useWriteResult = {\n        error: []\n      };\n      BULK_WRITE_ROWS_BY_RESPONSE.set(useWriteResult, toStorageWriteRows);\n      var reInsertErrors = writeResult.error.length === 0 ? [] : writeResult.error.filter(error => {\n        if (error.status === 409 && !error.writeRow.previous && !error.writeRow.document._deleted && ensureNotFalsy(error.documentInDb)._deleted) {\n          return true;\n        }\n\n        // add the \"normal\" errors to the parent error array.\n        useWriteResult.error.push(error);\n        return false;\n      });\n      if (reInsertErrors.length > 0) {\n        var reInsertIds = new Set();\n        var reInserts = reInsertErrors.map(error => {\n          reInsertIds.add(error.documentId);\n          return {\n            previous: error.documentInDb,\n            document: Object.assign({}, error.writeRow.document, {\n              _rev: createRevision(database.token, error.documentInDb)\n            })\n          };\n        });\n        var subResult = await database.lockedRun(() => storageInstance.bulkWrite(reInserts, context));\n        appendToArray(useWriteResult.error, subResult.error);\n        var successArray = getWrittenDocumentsFromBulkWriteResponse(primaryPath, toStorageWriteRows, useWriteResult, reInsertIds);\n        var subSuccess = getWrittenDocumentsFromBulkWriteResponse(primaryPath, reInserts, subResult);\n        appendToArray(successArray, subSuccess);\n        return useWriteResult;\n      }\n      return useWriteResult;\n    },\n    query(preparedQuery) {\n      return database.lockedRun(() => storageInstance.query(preparedQuery));\n    },\n    count(preparedQuery) {\n      return database.lockedRun(() => storageInstance.count(preparedQuery));\n    },\n    findDocumentsById(ids, deleted) {\n      return database.lockedRun(() => storageInstance.findDocumentsById(ids, deleted));\n    },\n    getAttachmentData(documentId, attachmentId, digest) {\n      return database.lockedRun(() => storageInstance.getAttachmentData(documentId, attachmentId, digest));\n    },\n    getChangedDocumentsSince: !storageInstance.getChangedDocumentsSince ? undefined : (limit, checkpoint) => {\n      return database.lockedRun(() => storageInstance.getChangedDocumentsSince(ensureNotFalsy(limit), checkpoint));\n    },\n    cleanup(minDeletedTime) {\n      return database.lockedRun(() => storageInstance.cleanup(minDeletedTime));\n    },\n    remove() {\n      database.storageInstances.delete(ret);\n      return database.lockedRun(() => storageInstance.remove());\n    },\n    close() {\n      database.storageInstances.delete(ret);\n      return database.lockedRun(() => storageInstance.close());\n    },\n    changeStream() {\n      return storageInstance.changeStream();\n    }\n  };\n  database.storageInstances.add(ret);\n  return ret;\n}\n\n/**\n * Each RxStorage implementation should\n * run this method at the first step of createStorageInstance()\n * to ensure that the configuration is correct.\n */\nexport function ensureRxStorageInstanceParamsAreCorrect(params) {\n  if (params.schema.keyCompression) {\n    throw newRxError('UT5', {\n      args: {\n        params\n      }\n    });\n  }\n  if (hasEncryption(params.schema)) {\n    throw newRxError('UT6', {\n      args: {\n        params\n      }\n    });\n  }\n  if (params.schema.attachments && params.schema.attachments.compression) {\n    throw newRxError('UT7', {\n      args: {\n        params\n      }\n    });\n  }\n}\nexport function hasEncryption(jsonSchema) {\n  if (!!jsonSchema.encrypted && jsonSchema.encrypted.length > 0 || jsonSchema.attachments && jsonSchema.attachments.encrypted) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function getChangedDocumentsSinceQuery(storageInstance, limit, checkpoint) {\n  var primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);\n  var sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n  var sinceId = checkpoint ? checkpoint.id : '';\n  return normalizeMangoQuery(storageInstance.schema, {\n    selector: {\n      $or: [{\n        '_meta.lwt': {\n          $gt: sinceLwt\n        }\n      }, {\n        '_meta.lwt': {\n          $eq: sinceLwt\n        },\n        [primaryPath]: {\n          $gt: checkpoint ? sinceId : ''\n        }\n      }],\n      // add this hint for better index usage\n      '_meta.lwt': {\n        $gte: sinceLwt\n      }\n    },\n    sort: [{\n      '_meta.lwt': 'asc'\n    }, {\n      [primaryPath]: 'asc'\n    }],\n    skip: 0,\n    limit\n    /**\n     * DO NOT SET A SPECIFIC INDEX HERE!\n     * The query might be modified by some plugin\n     * before sending it to the storage.\n     * We can be sure that in the end the query planner\n     * will find the best index.\n     */\n    // index: ['_meta.lwt', primaryPath]\n  });\n}\nexport async function getChangedDocumentsSince(storageInstance, limit, checkpoint) {\n  if (storageInstance.getChangedDocumentsSince) {\n    return storageInstance.getChangedDocumentsSince(limit, checkpoint);\n  }\n  var primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);\n  var query = prepareQuery(storageInstance.schema, getChangedDocumentsSinceQuery(storageInstance, limit, checkpoint));\n  var result = await storageInstance.query(query);\n  var documents = result.documents;\n  var lastDoc = lastOfArray(documents);\n  return {\n    documents: documents,\n    checkpoint: lastDoc ? {\n      id: lastDoc[primaryPath],\n      lwt: lastDoc._meta.lwt\n    } : checkpoint ? checkpoint : {\n      id: '',\n      lwt: 0\n    }\n  };\n}\nvar BULK_WRITE_ROWS_BY_RESPONSE = new WeakMap();\nvar BULK_WRITE_SUCCESS_MAP = new WeakMap();\n\n/**\n * For better performance, this is done only when accessed\n * because most of the time we do not need the results, only the errors.\n */\nexport function getWrittenDocumentsFromBulkWriteResponse(primaryPath, writeRows, response, reInsertIds) {\n  return getFromMapOrCreate(BULK_WRITE_SUCCESS_MAP, response, () => {\n    var ret = [];\n    var realWriteRows = BULK_WRITE_ROWS_BY_RESPONSE.get(response);\n    if (!realWriteRows) {\n      realWriteRows = writeRows;\n    }\n    if (response.error.length > 0 || reInsertIds) {\n      var errorIds = reInsertIds ? reInsertIds : new Set();\n      for (var index = 0; index < response.error.length; index++) {\n        var error = response.error[index];\n        errorIds.add(error.documentId);\n      }\n      for (var _index = 0; _index < realWriteRows.length; _index++) {\n        var doc = realWriteRows[_index].document;\n        if (!errorIds.has(doc[primaryPath])) {\n          ret.push(stripAttachmentsDataFromDocument(doc));\n        }\n      }\n    } else {\n      // pre-set array size for better performance\n      ret.length = writeRows.length - response.error.length;\n      for (var _index2 = 0; _index2 < realWriteRows.length; _index2++) {\n        var _doc = realWriteRows[_index2].document;\n        ret[_index2] = stripAttachmentsDataFromDocument(_doc);\n      }\n    }\n    return ret;\n  });\n}\n\n/**\n * Wraps the storage and simluates\n * delays. Mostly used in tests.\n */\nexport function randomDelayStorage(input) {\n  /**\n   * Ensure writes to a delay storage\n   * are still correctly run in order.\n   */\n  var randomDelayStorageWriteQueue = PROMISE_RESOLVE_TRUE;\n  var retStorage = {\n    name: 'random-delay-' + input.storage.name,\n    rxdbVersion: RXDB_VERSION,\n    async createStorageInstance(params) {\n      await promiseWait(input.delayTimeBefore());\n      var storageInstance = await input.storage.createStorageInstance(params);\n      await promiseWait(input.delayTimeAfter());\n      return {\n        databaseName: storageInstance.databaseName,\n        internals: storageInstance.internals,\n        options: storageInstance.options,\n        schema: storageInstance.schema,\n        collectionName: storageInstance.collectionName,\n        bulkWrite(a, b) {\n          randomDelayStorageWriteQueue = randomDelayStorageWriteQueue.then(async () => {\n            await promiseWait(input.delayTimeBefore());\n            var response = await storageInstance.bulkWrite(a, b);\n            await promiseWait(input.delayTimeAfter());\n            return response;\n          });\n          var ret = randomDelayStorageWriteQueue;\n          return ret;\n        },\n        async findDocumentsById(a, b) {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.findDocumentsById(a, b);\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        },\n        async query(a) {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.query(a);\n          return ret;\n        },\n        async count(a) {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.count(a);\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        },\n        async getAttachmentData(a, b, c) {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.getAttachmentData(a, b, c);\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        },\n        getChangedDocumentsSince: !storageInstance.getChangedDocumentsSince ? undefined : async (a, b) => {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await ensureNotFalsy(storageInstance.getChangedDocumentsSince)(a, b);\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        },\n        changeStream() {\n          return storageInstance.changeStream();\n        },\n        async cleanup(a) {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.cleanup(a);\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        },\n        async close() {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.close();\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        },\n        async remove() {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.remove();\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        }\n      };\n    }\n  };\n  return retStorage;\n}\n//# sourceMappingURL=rx-storage-helper.js.map","/**\n * When a persistent RxStorage is used in more the one JavaScript process,\n * the even stream of the changestream() function must be broadcasted to the other\n * RxStorageInstances of the same databaseName+collectionName.\n *\n * In the past this was done by RxDB but it makes more sense to do this\n * at the RxStorage level so that the broadcasting etc can all happen inside of a WebWorker\n * and not on the main thread.\n * Also it makes it less complex to stack up different RxStorages onto each other\n * like what we do with the in-memory plugin.\n *\n * This is intended to be used inside of createStorageInstance() of a storage.\n * Do not use this if the storage anyway broadcasts the events like when using MongoDB\n * or in the future W3C might introduce a way to listen to IndexedDB changes.\n */\n\nimport { Subject } from 'rxjs';\nimport { mergeWith } from 'rxjs/operators';\nimport { BroadcastChannel } from 'broadcast-channel';\n\n/**\n * The broadcast-channel is reused by the databaseInstanceToken.\n * This is required so that it is easy to simulate multi-tab usage\n * in the test where different instances of the same RxDatabase must\n * have different broadcast channels.\n * But also it ensures that for each RxDatabase we only create a single\n * broadcast channel that can even be reused in the leader election plugin.\n */\nexport var BROADCAST_CHANNEL_BY_TOKEN = new Map();\nexport function getBroadcastChannelReference(storageName, databaseInstanceToken, databaseName, refObject) {\n  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);\n  if (!state) {\n    state = {\n      /**\n       * We have to use the databaseName instead of the databaseInstanceToken\n       * in the BroadcastChannel name because different instances must end with the same\n       * channel name to be able to broadcast messages between each other.\n       */\n      bc: new BroadcastChannel(['RxDB:', storageName, databaseName].join('|')),\n      refs: new Set()\n    };\n    BROADCAST_CHANNEL_BY_TOKEN.set(databaseInstanceToken, state);\n  }\n  state.refs.add(refObject);\n  return state.bc;\n}\nexport function removeBroadcastChannelReference(databaseInstanceToken, refObject) {\n  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);\n  if (!state) {\n    return;\n  }\n  state.refs.delete(refObject);\n  if (state.refs.size === 0) {\n    BROADCAST_CHANNEL_BY_TOKEN.delete(databaseInstanceToken);\n    return state.bc.close();\n  }\n}\nexport function addRxStorageMultiInstanceSupport(storageName, instanceCreationParams, instance,\n/**\n * If provided, that channel will be used\n * instead of an own one.\n */\nprovidedBroadcastChannel) {\n  if (!instanceCreationParams.multiInstance) {\n    return;\n  }\n  var broadcastChannel = providedBroadcastChannel ? providedBroadcastChannel : getBroadcastChannelReference(storageName, instanceCreationParams.databaseInstanceToken, instance.databaseName, instance);\n  var changesFromOtherInstances$ = new Subject();\n  var eventListener = msg => {\n    if (msg.storageName === storageName && msg.databaseName === instanceCreationParams.databaseName && msg.collectionName === instanceCreationParams.collectionName && msg.version === instanceCreationParams.schema.version) {\n      changesFromOtherInstances$.next(msg.eventBulk);\n    }\n  };\n  broadcastChannel.addEventListener('message', eventListener);\n  var oldChangestream$ = instance.changeStream();\n  var closed = false;\n  var sub = oldChangestream$.subscribe(eventBulk => {\n    if (closed) {\n      return;\n    }\n    broadcastChannel.postMessage({\n      storageName: storageName,\n      databaseName: instanceCreationParams.databaseName,\n      collectionName: instanceCreationParams.collectionName,\n      version: instanceCreationParams.schema.version,\n      eventBulk\n    });\n  });\n  instance.changeStream = function () {\n    return changesFromOtherInstances$.asObservable().pipe(mergeWith(oldChangestream$));\n  };\n  var oldClose = instance.close.bind(instance);\n  instance.close = async function () {\n    closed = true;\n    sub.unsubscribe();\n    broadcastChannel.removeEventListener('message', eventListener);\n    if (!providedBroadcastChannel) {\n      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);\n    }\n    return oldClose();\n  };\n  var oldRemove = instance.remove.bind(instance);\n  instance.remove = async function () {\n    closed = true;\n    sub.unsubscribe();\n    broadcastChannel.removeEventListener('message', eventListener);\n    if (!providedBroadcastChannel) {\n      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);\n    }\n    return oldRemove();\n  };\n}\n//# sourceMappingURL=rx-storage-multiinstance.js.map","import { __extends } from \"tslib\";\nimport { Subject } from './Subject';\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        var _this = _super.call(this) || this;\n        _this._value = _value;\n        return _this;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        !subscription.closed && subscriber.next(this._value);\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;\n        if (hasError) {\n            throw thrownError;\n        }\n        this._throwIfClosed();\n        return _value;\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, (this._value = value));\n    };\n    return BehaviorSubject;\n}(Subject));\nexport { BehaviorSubject };\n//# sourceMappingURL=BehaviorSubject.js.map","export var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();\nexport function errorNotification(error) {\n    return createNotification('E', undefined, error);\n}\nexport function nextNotification(value) {\n    return createNotification('N', value, undefined);\n}\nexport function createNotification(kind, value, error) {\n    return {\n        kind: kind,\n        value: value,\n        error: error,\n    };\n}\n//# sourceMappingURL=NotificationFactories.js.map","import { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription } from './Subscription';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\nvar Observable = (function () {\n    function Observable(subscribe) {\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var _this = this;\n        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n        errorContext(function () {\n            var _a = _this, operator = _a.operator, source = _a.source;\n            subscriber.add(operator\n                ?\n                    operator.call(subscriber, source)\n                : source\n                    ?\n                        _this._subscribe(subscriber)\n                    :\n                        _this._trySubscribe(subscriber));\n        });\n        return subscriber;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.error(err);\n        }\n    };\n    Observable.prototype.forEach = function (next, promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var subscriber = new SafeSubscriber({\n                next: function (value) {\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscriber.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve,\n            });\n            _this.subscribe(subscriber);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        var _a;\n        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);\n    };\n    Observable.prototype[Symbol_observable] = function () {\n        return this;\n    };\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i] = arguments[_i];\n        }\n        return pipeFromArray(operations)(this);\n    };\n    Observable.prototype.toPromise = function (promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexport { Observable };\nfunction getPromiseCtor(promiseCtor) {\n    var _a;\n    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;\n}\nfunction isObserver(value) {\n    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\nfunction isSubscriber(value) {\n    return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n//# sourceMappingURL=Observable.js.map","import { __extends } from \"tslib\";\nimport { Subject } from './Subject';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\nvar ReplaySubject = (function (_super) {\n    __extends(ReplaySubject, _super);\n    function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {\n        if (_bufferSize === void 0) { _bufferSize = Infinity; }\n        if (_windowTime === void 0) { _windowTime = Infinity; }\n        if (_timestampProvider === void 0) { _timestampProvider = dateTimestampProvider; }\n        var _this = _super.call(this) || this;\n        _this._bufferSize = _bufferSize;\n        _this._windowTime = _windowTime;\n        _this._timestampProvider = _timestampProvider;\n        _this._buffer = [];\n        _this._infiniteTimeWindow = true;\n        _this._infiniteTimeWindow = _windowTime === Infinity;\n        _this._bufferSize = Math.max(1, _bufferSize);\n        _this._windowTime = Math.max(1, _windowTime);\n        return _this;\n    }\n    ReplaySubject.prototype.next = function (value) {\n        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;\n        if (!isStopped) {\n            _buffer.push(value);\n            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n        }\n        this._trimBuffer();\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        this._throwIfClosed();\n        this._trimBuffer();\n        var subscription = this._innerSubscribe(subscriber);\n        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;\n        var copy = _buffer.slice();\n        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n            subscriber.next(copy[i]);\n        }\n        this._checkFinalizedStatuses(subscriber);\n        return subscription;\n    };\n    ReplaySubject.prototype._trimBuffer = function () {\n        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;\n        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n        if (!_infiniteTimeWindow) {\n            var now = _timestampProvider.now();\n            var last = 0;\n            for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {\n                last = i;\n            }\n            last && _buffer.splice(0, last + 1);\n        }\n    };\n    return ReplaySubject;\n}(Subject));\nexport { ReplaySubject };\n//# sourceMappingURL=ReplaySubject.js.map","import { __extends, __values } from \"tslib\";\nimport { Observable } from './Observable';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        var _this = _super.call(this) || this;\n        _this.closed = false;\n        _this.currentObservers = null;\n        _this.observers = [];\n        _this.isStopped = false;\n        _this.hasError = false;\n        _this.thrownError = null;\n        return _this;\n    }\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype._throwIfClosed = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n    };\n    Subject.prototype.next = function (value) {\n        var _this = this;\n        errorContext(function () {\n            var e_1, _a;\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                if (!_this.currentObservers) {\n                    _this.currentObservers = Array.from(_this.observers);\n                }\n                try {\n                    for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var observer = _c.value;\n                        observer.next(value);\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        });\n    };\n    Subject.prototype.error = function (err) {\n        var _this = this;\n        errorContext(function () {\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                _this.hasError = _this.isStopped = true;\n                _this.thrownError = err;\n                var observers = _this.observers;\n                while (observers.length) {\n                    observers.shift().error(err);\n                }\n            }\n        });\n    };\n    Subject.prototype.complete = function () {\n        var _this = this;\n        errorContext(function () {\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                _this.isStopped = true;\n                var observers = _this.observers;\n                while (observers.length) {\n                    observers.shift().complete();\n                }\n            }\n        });\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = this.closed = true;\n        this.observers = this.currentObservers = null;\n    };\n    Object.defineProperty(Subject.prototype, \"observed\", {\n        get: function () {\n            var _a;\n            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Subject.prototype._trySubscribe = function (subscriber) {\n        this._throwIfClosed();\n        return _super.prototype._trySubscribe.call(this, subscriber);\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        this._throwIfClosed();\n        this._checkFinalizedStatuses(subscriber);\n        return this._innerSubscribe(subscriber);\n    };\n    Subject.prototype._innerSubscribe = function (subscriber) {\n        var _this = this;\n        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;\n        if (hasError || isStopped) {\n            return EMPTY_SUBSCRIPTION;\n        }\n        this.currentObservers = null;\n        observers.push(subscriber);\n        return new Subscription(function () {\n            _this.currentObservers = null;\n            arrRemove(observers, subscriber);\n        });\n    };\n    Subject.prototype._checkFinalizedStatuses = function (subscriber) {\n        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;\n        if (hasError) {\n            subscriber.error(thrownError);\n        }\n        else if (isStopped) {\n            subscriber.complete();\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable));\nexport { Subject };\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        var _this = _super.call(this) || this;\n        _this.destination = destination;\n        _this.source = source;\n        return _this;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var _a, _b;\n        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;\n    };\n    return AnonymousSubject;\n}(Subject));\nexport { AnonymousSubject };\n//# sourceMappingURL=Subject.js.map","import { __extends } from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    function Subscriber(destination) {\n        var _this = _super.call(this) || this;\n        _this.isStopped = false;\n        if (destination) {\n            _this.destination = destination;\n            if (isSubscription(destination)) {\n                destination.add(_this);\n            }\n        }\n        else {\n            _this.destination = EMPTY_OBSERVER;\n        }\n        return _this;\n    }\n    Subscriber.create = function (next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    };\n    Subscriber.prototype.next = function (value) {\n        if (this.isStopped) {\n            handleStoppedNotification(nextNotification(value), this);\n        }\n        else {\n            this._next(value);\n        }\n    };\n    Subscriber.prototype.error = function (err) {\n        if (this.isStopped) {\n            handleStoppedNotification(errorNotification(err), this);\n        }\n        else {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    Subscriber.prototype.complete = function () {\n        if (this.isStopped) {\n            handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n        }\n        else {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.isStopped = true;\n            _super.prototype.unsubscribe.call(this);\n            this.destination = null;\n        }\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        try {\n            this.destination.error(err);\n        }\n        finally {\n            this.unsubscribe();\n        }\n    };\n    Subscriber.prototype._complete = function () {\n        try {\n            this.destination.complete();\n        }\n        finally {\n            this.unsubscribe();\n        }\n    };\n    return Subscriber;\n}(Subscription));\nexport { Subscriber };\nvar _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n    return _bind.call(fn, thisArg);\n}\nvar ConsumerObserver = (function () {\n    function ConsumerObserver(partialObserver) {\n        this.partialObserver = partialObserver;\n    }\n    ConsumerObserver.prototype.next = function (value) {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.next) {\n            try {\n                partialObserver.next(value);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    };\n    ConsumerObserver.prototype.error = function (err) {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.error) {\n            try {\n                partialObserver.error(err);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n        else {\n            handleUnhandledError(err);\n        }\n    };\n    ConsumerObserver.prototype.complete = function () {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.complete) {\n            try {\n                partialObserver.complete();\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    };\n    return ConsumerObserver;\n}());\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(observerOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        var partialObserver;\n        if (isFunction(observerOrNext) || !observerOrNext) {\n            partialObserver = {\n                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),\n                error: error !== null && error !== void 0 ? error : undefined,\n                complete: complete !== null && complete !== void 0 ? complete : undefined,\n            };\n        }\n        else {\n            var context_1;\n            if (_this && config.useDeprecatedNextContext) {\n                context_1 = Object.create(observerOrNext);\n                context_1.unsubscribe = function () { return _this.unsubscribe(); };\n                partialObserver = {\n                    next: observerOrNext.next && bind(observerOrNext.next, context_1),\n                    error: observerOrNext.error && bind(observerOrNext.error, context_1),\n                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),\n                };\n            }\n            else {\n                partialObserver = observerOrNext;\n            }\n        }\n        _this.destination = new ConsumerObserver(partialObserver);\n        return _this;\n    }\n    return SafeSubscriber;\n}(Subscriber));\nexport { SafeSubscriber };\nfunction handleUnhandledError(error) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        captureError(error);\n    }\n    else {\n        reportUnhandledError(error);\n    }\n}\nfunction defaultErrorHandler(err) {\n    throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n    var onStoppedNotification = config.onStoppedNotification;\n    onStoppedNotification && timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });\n}\nexport var EMPTY_OBSERVER = {\n    closed: true,\n    next: noop,\n    error: defaultErrorHandler,\n    complete: noop,\n};\n//# sourceMappingURL=Subscriber.js.map","import { __read, __spreadArray, __values } from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { arrRemove } from './util/arrRemove';\nvar Subscription = (function () {\n    function Subscription(initialTeardown) {\n        this.initialTeardown = initialTeardown;\n        this.closed = false;\n        this._parentage = null;\n        this._finalizers = null;\n    }\n    Subscription.prototype.unsubscribe = function () {\n        var e_1, _a, e_2, _b;\n        var errors;\n        if (!this.closed) {\n            this.closed = true;\n            var _parentage = this._parentage;\n            if (_parentage) {\n                this._parentage = null;\n                if (Array.isArray(_parentage)) {\n                    try {\n                        for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {\n                            var parent_1 = _parentage_1_1.value;\n                            parent_1.remove(this);\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                }\n                else {\n                    _parentage.remove(this);\n                }\n            }\n            var initialFinalizer = this.initialTeardown;\n            if (isFunction(initialFinalizer)) {\n                try {\n                    initialFinalizer();\n                }\n                catch (e) {\n                    errors = e instanceof UnsubscriptionError ? e.errors : [e];\n                }\n            }\n            var _finalizers = this._finalizers;\n            if (_finalizers) {\n                this._finalizers = null;\n                try {\n                    for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {\n                        var finalizer = _finalizers_1_1.value;\n                        try {\n                            execFinalizer(finalizer);\n                        }\n                        catch (err) {\n                            errors = errors !== null && errors !== void 0 ? errors : [];\n                            if (err instanceof UnsubscriptionError) {\n                                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));\n                            }\n                            else {\n                                errors.push(err);\n                            }\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n            if (errors) {\n                throw new UnsubscriptionError(errors);\n            }\n        }\n    };\n    Subscription.prototype.add = function (teardown) {\n        var _a;\n        if (teardown && teardown !== this) {\n            if (this.closed) {\n                execFinalizer(teardown);\n            }\n            else {\n                if (teardown instanceof Subscription) {\n                    if (teardown.closed || teardown._hasParent(this)) {\n                        return;\n                    }\n                    teardown._addParent(this);\n                }\n                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);\n            }\n        }\n    };\n    Subscription.prototype._hasParent = function (parent) {\n        var _parentage = this._parentage;\n        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _parentage = this._parentage;\n        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n    };\n    Subscription.prototype._removeParent = function (parent) {\n        var _parentage = this._parentage;\n        if (_parentage === parent) {\n            this._parentage = null;\n        }\n        else if (Array.isArray(_parentage)) {\n            arrRemove(_parentage, parent);\n        }\n    };\n    Subscription.prototype.remove = function (teardown) {\n        var _finalizers = this._finalizers;\n        _finalizers && arrRemove(_finalizers, teardown);\n        if (teardown instanceof Subscription) {\n            teardown._removeParent(this);\n        }\n    };\n    Subscription.EMPTY = (function () {\n        var empty = new Subscription();\n        empty.closed = true;\n        return empty;\n    })();\n    return Subscription;\n}());\nexport { Subscription };\nexport var EMPTY_SUBSCRIPTION = Subscription.EMPTY;\nexport function isSubscription(value) {\n    return (value instanceof Subscription ||\n        (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));\n}\nfunction execFinalizer(finalizer) {\n    if (isFunction(finalizer)) {\n        finalizer();\n    }\n    else {\n        finalizer.unsubscribe();\n    }\n}\n//# sourceMappingURL=Subscription.js.map","export var config = {\n    onUnhandledError: null,\n    onStoppedNotification: null,\n    Promise: undefined,\n    useDeprecatedSynchronousErrorHandling: false,\n    useDeprecatedNextContext: false,\n};\n//# sourceMappingURL=config.js.map","import { EmptyError } from './util/EmptyError';\nimport { SafeSubscriber } from './Subscriber';\nexport function firstValueFrom(source, config) {\n    var hasConfig = typeof config === 'object';\n    return new Promise(function (resolve, reject) {\n        var subscriber = new SafeSubscriber({\n            next: function (value) {\n                resolve(value);\n                subscriber.unsubscribe();\n            },\n            error: reject,\n            complete: function () {\n                if (hasConfig) {\n                    resolve(config.defaultValue);\n                }\n                else {\n                    reject(new EmptyError());\n                }\n            },\n        });\n        source.subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=firstValueFrom.js.map","import { Observable } from '../Observable';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function combineLatest() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = popScheduler(args);\n    var resultSelector = popResultSelector(args);\n    var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;\n    if (observables.length === 0) {\n        return from([], scheduler);\n    }\n    var result = new Observable(combineLatestInit(observables, scheduler, keys\n        ?\n            function (values) { return createObject(keys, values); }\n        :\n            identity));\n    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\nexport function combineLatestInit(observables, scheduler, valueTransform) {\n    if (valueTransform === void 0) { valueTransform = identity; }\n    return function (subscriber) {\n        maybeSchedule(scheduler, function () {\n            var length = observables.length;\n            var values = new Array(length);\n            var active = length;\n            var remainingFirstValues = length;\n            var _loop_1 = function (i) {\n                maybeSchedule(scheduler, function () {\n                    var source = from(observables[i], scheduler);\n                    var hasFirstValue = false;\n                    source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n                        values[i] = value;\n                        if (!hasFirstValue) {\n                            hasFirstValue = true;\n                            remainingFirstValues--;\n                        }\n                        if (!remainingFirstValues) {\n                            subscriber.next(valueTransform(values.slice()));\n                        }\n                    }, function () {\n                        if (!--active) {\n                            subscriber.complete();\n                        }\n                    }));\n                }, subscriber);\n            };\n            for (var i = 0; i < length; i++) {\n                _loop_1(i);\n            }\n        }, subscriber);\n    };\n}\nfunction maybeSchedule(scheduler, execute, subscription) {\n    if (scheduler) {\n        executeSchedule(subscription, scheduler, execute);\n    }\n    else {\n        execute();\n    }\n}\n//# sourceMappingURL=combineLatest.js.map","import { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function concat() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return concatAll()(from(args, popScheduler(args)));\n}\n//# sourceMappingURL=concat.js.map","import { Observable } from '../Observable';\nexport var EMPTY = new Observable(function (subscriber) { return subscriber.complete(); });\nexport function empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });\n}\n//# sourceMappingURL=empty.js.map","import { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\nexport function from(input, scheduler) {\n    return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n//# sourceMappingURL=from.js.map","import { __asyncValues, __awaiter, __generator, __values } from \"tslib\";\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\nexport function innerFrom(input) {\n    if (input instanceof Observable) {\n        return input;\n    }\n    if (input != null) {\n        if (isInteropObservable(input)) {\n            return fromInteropObservable(input);\n        }\n        if (isArrayLike(input)) {\n            return fromArrayLike(input);\n        }\n        if (isPromise(input)) {\n            return fromPromise(input);\n        }\n        if (isAsyncIterable(input)) {\n            return fromAsyncIterable(input);\n        }\n        if (isIterable(input)) {\n            return fromIterable(input);\n        }\n        if (isReadableStreamLike(input)) {\n            return fromReadableStreamLike(input);\n        }\n    }\n    throw createInvalidObservableTypeError(input);\n}\nexport function fromInteropObservable(obj) {\n    return new Observable(function (subscriber) {\n        var obs = obj[Symbol_observable]();\n        if (isFunction(obs.subscribe)) {\n            return obs.subscribe(subscriber);\n        }\n        throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    });\n}\nexport function fromArrayLike(array) {\n    return new Observable(function (subscriber) {\n        for (var i = 0; i < array.length && !subscriber.closed; i++) {\n            subscriber.next(array[i]);\n        }\n        subscriber.complete();\n    });\n}\nexport function fromPromise(promise) {\n    return new Observable(function (subscriber) {\n        promise\n            .then(function (value) {\n            if (!subscriber.closed) {\n                subscriber.next(value);\n                subscriber.complete();\n            }\n        }, function (err) { return subscriber.error(err); })\n            .then(null, reportUnhandledError);\n    });\n}\nexport function fromIterable(iterable) {\n    return new Observable(function (subscriber) {\n        var e_1, _a;\n        try {\n            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {\n                var value = iterable_1_1.value;\n                subscriber.next(value);\n                if (subscriber.closed) {\n                    return;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        subscriber.complete();\n    });\n}\nexport function fromAsyncIterable(asyncIterable) {\n    return new Observable(function (subscriber) {\n        process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });\n    });\n}\nexport function fromReadableStreamLike(readableStream) {\n    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\nfunction process(asyncIterable, subscriber) {\n    var asyncIterable_1, asyncIterable_1_1;\n    var e_2, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var value, e_2_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 5, 6, 11]);\n                    asyncIterable_1 = __asyncValues(asyncIterable);\n                    _b.label = 1;\n                case 1: return [4, asyncIterable_1.next()];\n                case 2:\n                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];\n                    value = asyncIterable_1_1.value;\n                    subscriber.next(value);\n                    if (subscriber.closed) {\n                        return [2];\n                    }\n                    _b.label = 3;\n                case 3: return [3, 1];\n                case 4: return [3, 11];\n                case 5:\n                    e_2_1 = _b.sent();\n                    e_2 = { error: e_2_1 };\n                    return [3, 11];\n                case 6:\n                    _b.trys.push([6, , 9, 10]);\n                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];\n                    return [4, _a.call(asyncIterable_1)];\n                case 7:\n                    _b.sent();\n                    _b.label = 8;\n                case 8: return [3, 10];\n                case 9:\n                    if (e_2) throw e_2.error;\n                    return [7];\n                case 10: return [7];\n                case 11:\n                    subscriber.complete();\n                    return [2];\n            }\n        });\n    });\n}\n//# sourceMappingURL=innerFrom.js.map","import { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\nexport function merge() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = popScheduler(args);\n    var concurrent = popNumber(args, Infinity);\n    var sources = args;\n    return !sources.length\n        ?\n            EMPTY\n        : sources.length === 1\n            ?\n                innerFrom(sources[0])\n            :\n                mergeAll(concurrent)(from(sources, scheduler));\n}\n//# sourceMappingURL=merge.js.map","import { __extends } from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\n    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\nvar OperatorSubscriber = (function (_super) {\n    __extends(OperatorSubscriber, _super);\n    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {\n        var _this = _super.call(this, destination) || this;\n        _this.onFinalize = onFinalize;\n        _this.shouldUnsubscribe = shouldUnsubscribe;\n        _this._next = onNext\n            ? function (value) {\n                try {\n                    onNext(value);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n            }\n            : _super.prototype._next;\n        _this._error = onError\n            ? function (err) {\n                try {\n                    onError(err);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : _super.prototype._error;\n        _this._complete = onComplete\n            ? function () {\n                try {\n                    onComplete();\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : _super.prototype._complete;\n        return _this;\n    }\n    OperatorSubscriber.prototype.unsubscribe = function () {\n        var _a;\n        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n            var closed_1 = this.closed;\n            _super.prototype.unsubscribe.call(this);\n            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\n        }\n    };\n    return OperatorSubscriber;\n}(Subscriber));\nexport { OperatorSubscriber };\n//# sourceMappingURL=OperatorSubscriber.js.map","import { mergeAll } from './mergeAll';\nexport function concatAll() {\n    return mergeAll(1);\n}\n//# sourceMappingURL=concatAll.js.map","import { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function distinctUntilChanged(comparator, keySelector) {\n    if (keySelector === void 0) { keySelector = identity; }\n    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;\n    return operate(function (source, subscriber) {\n        var previousKey;\n        var first = true;\n        source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n            var currentKey = keySelector(value);\n            if (first || !comparator(previousKey, currentKey)) {\n                first = false;\n                previousKey = currentKey;\n                subscriber.next(value);\n            }\n        }));\n    });\n}\nfunction defaultCompare(a, b) {\n    return a === b;\n}\n//# sourceMappingURL=distinctUntilChanged.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function filter(predicate, thisArg) {\n    return operate(function (source, subscriber) {\n        var index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));\n    });\n}\n//# sourceMappingURL=filter.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function map(project, thisArg) {\n    return operate(function (source, subscriber) {\n        var index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n            subscriber.next(project.call(thisArg, value, index++));\n        }));\n    });\n}\n//# sourceMappingURL=map.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { operate } from '../util/lift';\nimport { mergeAll } from './mergeAll';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from '../observable/from';\nexport function merge() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = popScheduler(args);\n    var concurrent = popNumber(args, Infinity);\n    return operate(function (source, subscriber) {\n        mergeAll(concurrent)(from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=merge.js.map","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nexport function mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Infinity; }\n    return mergeMap(identity, concurrent);\n}\n//# sourceMappingURL=mergeAll.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    var buffer = [];\n    var active = 0;\n    var index = 0;\n    var isComplete = false;\n    var checkComplete = function () {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };\n    var doInnerSub = function (value) {\n        expand && subscriber.next(value);\n        active++;\n        var innerComplete = false;\n        innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function (innerValue) {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            }\n            else {\n                subscriber.next(innerValue);\n            }\n        }, function () {\n            innerComplete = true;\n        }, undefined, function () {\n            if (innerComplete) {\n                try {\n                    active--;\n                    var _loop_1 = function () {\n                        var bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            executeSchedule(subscriber, innerSubScheduler, function () { return doInnerSub(bufferedValue); });\n                        }\n                        else {\n                            doInnerSub(bufferedValue);\n                        }\n                    };\n                    while (buffer.length && active < concurrent) {\n                        _loop_1();\n                    }\n                    checkComplete();\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe(createOperatorSubscriber(subscriber, outerNext, function () {\n        isComplete = true;\n        checkComplete();\n    }));\n    return function () {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n}\n//# sourceMappingURL=mergeInternals.js.map","import { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\nexport function mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Infinity; }\n    if (isFunction(resultSelector)) {\n        return mergeMap(function (a, i) { return map(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom(project(a, i))); }, concurrent);\n    }\n    else if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return operate(function (source, subscriber) { return mergeInternals(source, subscriber, project, concurrent); });\n}\n//# sourceMappingURL=mergeMap.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { merge } from './merge';\nexport function mergeWith() {\n    var otherSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        otherSources[_i] = arguments[_i];\n    }\n    return merge.apply(void 0, __spreadArray([], __read(otherSources)));\n}\n//# sourceMappingURL=mergeWith.js.map","import { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return operate(function (source, subscriber) {\n        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return executeSchedule(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return executeSchedule(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return executeSchedule(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));\n    });\n}\n//# sourceMappingURL=observeOn.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { operate } from '../util/lift';\nexport function share(options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.connector, connector = _a === void 0 ? function () { return new Subject(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;\n    return function (wrapperSource) {\n        var connection;\n        var resetConnection;\n        var subject;\n        var refCount = 0;\n        var hasCompleted = false;\n        var hasErrored = false;\n        var cancelReset = function () {\n            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();\n            resetConnection = undefined;\n        };\n        var reset = function () {\n            cancelReset();\n            connection = subject = undefined;\n            hasCompleted = hasErrored = false;\n        };\n        var resetAndUnsubscribe = function () {\n            var conn = connection;\n            reset();\n            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();\n        };\n        return operate(function (source, subscriber) {\n            refCount++;\n            if (!hasErrored && !hasCompleted) {\n                cancelReset();\n            }\n            var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());\n            subscriber.add(function () {\n                refCount--;\n                if (refCount === 0 && !hasErrored && !hasCompleted) {\n                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n                }\n            });\n            dest.subscribe(subscriber);\n            if (!connection &&\n                refCount > 0) {\n                connection = new SafeSubscriber({\n                    next: function (value) { return dest.next(value); },\n                    error: function (err) {\n                        hasErrored = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnError, err);\n                        dest.error(err);\n                    },\n                    complete: function () {\n                        hasCompleted = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnComplete);\n                        dest.complete();\n                    },\n                });\n                innerFrom(source).subscribe(connection);\n            }\n        })(wrapperSource);\n    };\n}\nfunction handleReset(reset, on) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    if (on === true) {\n        reset();\n        return;\n    }\n    if (on === false) {\n        return;\n    }\n    var onSubscriber = new SafeSubscriber({\n        next: function () {\n            onSubscriber.unsubscribe();\n            reset();\n        },\n    });\n    return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);\n}\n//# sourceMappingURL=share.js.map","import { ReplaySubject } from '../ReplaySubject';\nimport { share } from './share';\nexport function shareReplay(configOrBufferSize, windowTime, scheduler) {\n    var _a, _b, _c;\n    var bufferSize;\n    var refCount = false;\n    if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n        (_a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler);\n    }\n    else {\n        bufferSize = (configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity);\n    }\n    return share({\n        connector: function () { return new ReplaySubject(bufferSize, windowTime, scheduler); },\n        resetOnError: true,\n        resetOnComplete: false,\n        resetOnRefCountZero: refCount,\n    });\n}\n//# sourceMappingURL=shareReplay.js.map","import { concat } from '../observable/concat';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\nexport function startWith() {\n    var values = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        values[_i] = arguments[_i];\n    }\n    var scheduler = popScheduler(values);\n    return operate(function (source, subscriber) {\n        (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=startWith.js.map","import { operate } from '../util/lift';\nexport function subscribeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return operate(function (source, subscriber) {\n        subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));\n    });\n}\n//# sourceMappingURL=subscribeOn.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function switchMap(project, resultSelector) {\n    return operate(function (source, subscriber) {\n        var innerSubscriber = null;\n        var index = 0;\n        var isComplete = false;\n        var checkComplete = function () { return isComplete && !innerSubscriber && subscriber.complete(); };\n        source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();\n            var innerIndex = 0;\n            var outerIndex = index++;\n            innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = createOperatorSubscriber(subscriber, function (innerValue) { return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue); }, function () {\n                innerSubscriber = null;\n                checkComplete();\n            })));\n        }, function () {\n            isComplete = true;\n            checkComplete();\n        }));\n    });\n}\n//# sourceMappingURL=switchMap.js.map","import { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\nexport function tap(observerOrNext, error, complete) {\n    var tapObserver = isFunction(observerOrNext) || error || complete\n        ?\n            { next: observerOrNext, error: error, complete: complete }\n        : observerOrNext;\n    return tapObserver\n        ? operate(function (source, subscriber) {\n            var _a;\n            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n            var isUnsub = true;\n            source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n                var _a;\n                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);\n                subscriber.next(value);\n            }, function () {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                subscriber.complete();\n            }, function (err) {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);\n                subscriber.error(err);\n            }, function () {\n                var _a, _b;\n                if (isUnsub) {\n                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                }\n                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);\n            }));\n        })\n        :\n            identity;\n}\n//# sourceMappingURL=tap.js.map","import { Observable } from '../Observable';\nexport function scheduleArray(input, scheduler) {\n    return new Observable(function (subscriber) {\n        var i = 0;\n        return scheduler.schedule(function () {\n            if (i === input.length) {\n                subscriber.complete();\n            }\n            else {\n                subscriber.next(input[i++]);\n                if (!subscriber.closed) {\n                    this.schedule();\n                }\n            }\n        });\n    });\n}\n//# sourceMappingURL=scheduleArray.js.map","import { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function scheduleAsyncIterable(input, scheduler) {\n    if (!input) {\n        throw new Error('Iterable cannot be null');\n    }\n    return new Observable(function (subscriber) {\n        executeSchedule(subscriber, scheduler, function () {\n            var iterator = input[Symbol.asyncIterator]();\n            executeSchedule(subscriber, scheduler, function () {\n                iterator.next().then(function (result) {\n                    if (result.done) {\n                        subscriber.complete();\n                    }\n                    else {\n                        subscriber.next(result.value);\n                    }\n                });\n            }, 0, true);\n        });\n    });\n}\n//# sourceMappingURL=scheduleAsyncIterable.js.map","import { Observable } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function scheduleIterable(input, scheduler) {\n    return new Observable(function (subscriber) {\n        var iterator;\n        executeSchedule(subscriber, scheduler, function () {\n            iterator = input[Symbol_iterator]();\n            executeSchedule(subscriber, scheduler, function () {\n                var _a;\n                var value;\n                var done;\n                try {\n                    (_a = iterator.next(), value = _a.value, done = _a.done);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (done) {\n                    subscriber.complete();\n                }\n                else {\n                    subscriber.next(value);\n                }\n            }, 0, true);\n        });\n        return function () { return isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return(); };\n    });\n}\n//# sourceMappingURL=scheduleIterable.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nexport function scheduleObservable(input, scheduler) {\n    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n//# sourceMappingURL=scheduleObservable.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nexport function schedulePromise(input, scheduler) {\n    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n//# sourceMappingURL=schedulePromise.js.map","import { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nexport function scheduleReadableStreamLike(input, scheduler) {\n    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n//# sourceMappingURL=scheduleReadableStreamLike.js.map","import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\nexport function scheduled(input, scheduler) {\n    if (input != null) {\n        if (isInteropObservable(input)) {\n            return scheduleObservable(input, scheduler);\n        }\n        if (isArrayLike(input)) {\n            return scheduleArray(input, scheduler);\n        }\n        if (isPromise(input)) {\n            return schedulePromise(input, scheduler);\n        }\n        if (isAsyncIterable(input)) {\n            return scheduleAsyncIterable(input, scheduler);\n        }\n        if (isIterable(input)) {\n            return scheduleIterable(input, scheduler);\n        }\n        if (isReadableStreamLike(input)) {\n            return scheduleReadableStreamLike(input, scheduler);\n        }\n    }\n    throw createInvalidObservableTypeError(input);\n}\n//# sourceMappingURL=scheduled.js.map","export var dateTimestampProvider = {\n    now: function () {\n        return (dateTimestampProvider.delegate || Date).now();\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=dateTimestampProvider.js.map","import { __read, __spreadArray } from \"tslib\";\nexport var timeoutProvider = {\n    setTimeout: function (handler, timeout) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var delegate = timeoutProvider.delegate;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {\n            return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));\n        }\n        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));\n    },\n    clearTimeout: function (handle) {\n        var delegate = timeoutProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=timeoutProvider.js.map","export function getSymbolIterator() {\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\n        return '@@iterator';\n    }\n    return Symbol.iterator;\n}\nexport var iterator = getSymbolIterator();\n//# sourceMappingURL=iterator.js.map","export var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();\n//# sourceMappingURL=observable.js.map","import { createErrorClass } from './createErrorClass';\nexport var EmptyError = createErrorClass(function (_super) {\n    return function EmptyErrorImpl() {\n        _super(this);\n        this.name = 'EmptyError';\n        this.message = 'no elements in sequence';\n    };\n});\n//# sourceMappingURL=EmptyError.js.map","import { createErrorClass } from './createErrorClass';\nexport var ObjectUnsubscribedError = createErrorClass(function (_super) {\n    return function ObjectUnsubscribedErrorImpl() {\n        _super(this);\n        this.name = 'ObjectUnsubscribedError';\n        this.message = 'object unsubscribed';\n    };\n});\n//# sourceMappingURL=ObjectUnsubscribedError.js.map","import { createErrorClass } from './createErrorClass';\nexport var UnsubscriptionError = createErrorClass(function (_super) {\n    return function UnsubscriptionErrorImpl(errors) {\n        _super(this);\n        this.message = errors\n            ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return i + 1 + \") \" + err.toString(); }).join('\\n  ')\n            : '';\n        this.name = 'UnsubscriptionError';\n        this.errors = errors;\n    };\n});\n//# sourceMappingURL=UnsubscriptionError.js.map","import { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nexport function popResultSelector(args) {\n    return isFunction(last(args)) ? args.pop() : undefined;\n}\nexport function popScheduler(args) {\n    return isScheduler(last(args)) ? args.pop() : undefined;\n}\nexport function popNumber(args, defaultValue) {\n    return typeof last(args) === 'number' ? args.pop() : defaultValue;\n}\n//# sourceMappingURL=args.js.map","var isArray = Array.isArray;\nvar getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;\nexport function argsArgArrayOrObject(args) {\n    if (args.length === 1) {\n        var first_1 = args[0];\n        if (isArray(first_1)) {\n            return { args: first_1, keys: null };\n        }\n        if (isPOJO(first_1)) {\n            var keys = getKeys(first_1);\n            return {\n                args: keys.map(function (key) { return first_1[key]; }),\n                keys: keys,\n            };\n        }\n    }\n    return { args: args, keys: null };\n}\nfunction isPOJO(obj) {\n    return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n//# sourceMappingURL=argsArgArrayOrObject.js.map","export function arrRemove(arr, item) {\n    if (arr) {\n        var index = arr.indexOf(item);\n        0 <= index && arr.splice(index, 1);\n    }\n}\n//# sourceMappingURL=arrRemove.js.map","export function createErrorClass(createImpl) {\n    var _super = function (instance) {\n        Error.call(instance);\n        instance.stack = new Error().stack;\n    };\n    var ctorFunc = createImpl(_super);\n    ctorFunc.prototype = Object.create(Error.prototype);\n    ctorFunc.prototype.constructor = ctorFunc;\n    return ctorFunc;\n}\n//# sourceMappingURL=createErrorClass.js.map","export function createObject(keys, values) {\n    return keys.reduce(function (result, key, i) { return ((result[key] = values[i]), result); }, {});\n}\n//# sourceMappingURL=createObject.js.map","import { config } from '../config';\nvar context = null;\nexport function errorContext(cb) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        var isRoot = !context;\n        if (isRoot) {\n            context = { errorThrown: false, error: null };\n        }\n        cb();\n        if (isRoot) {\n            var _a = context, errorThrown = _a.errorThrown, error = _a.error;\n            context = null;\n            if (errorThrown) {\n                throw error;\n            }\n        }\n    }\n    else {\n        cb();\n    }\n}\nexport function captureError(err) {\n    if (config.useDeprecatedSynchronousErrorHandling && context) {\n        context.errorThrown = true;\n        context.error = err;\n    }\n}\n//# sourceMappingURL=errorContext.js.map","export function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {\n    if (delay === void 0) { delay = 0; }\n    if (repeat === void 0) { repeat = false; }\n    var scheduleSubscription = scheduler.schedule(function () {\n        work();\n        if (repeat) {\n            parentSubscription.add(this.schedule(null, delay));\n        }\n        else {\n            this.unsubscribe();\n        }\n    }, delay);\n    parentSubscription.add(scheduleSubscription);\n    if (!repeat) {\n        return scheduleSubscription;\n    }\n}\n//# sourceMappingURL=executeSchedule.js.map","export function identity(x) {\n    return x;\n}\n//# sourceMappingURL=identity.js.map","export var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });\n//# sourceMappingURL=isArrayLike.js.map","import { isFunction } from './isFunction';\nexport function isAsyncIterable(obj) {\n    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);\n}\n//# sourceMappingURL=isAsyncIterable.js.map","export function isFunction(value) {\n    return typeof value === 'function';\n}\n//# sourceMappingURL=isFunction.js.map","import { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\nexport function isInteropObservable(input) {\n    return isFunction(input[Symbol_observable]);\n}\n//# sourceMappingURL=isInteropObservable.js.map","import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\nexport function isIterable(input) {\n    return isFunction(input === null || input === void 0 ? void 0 : input[Symbol_iterator]);\n}\n//# sourceMappingURL=isIterable.js.map","import { isFunction } from \"./isFunction\";\nexport function isPromise(value) {\n    return isFunction(value === null || value === void 0 ? void 0 : value.then);\n}\n//# sourceMappingURL=isPromise.js.map","import { __asyncGenerator, __await, __generator } from \"tslib\";\nimport { isFunction } from './isFunction';\nexport function readableStreamLikeToAsyncGenerator(readableStream) {\n    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {\n        var reader, _a, value, done;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    reader = readableStream.getReader();\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                case 2:\n                    if (!true) return [3, 8];\n                    return [4, __await(reader.read())];\n                case 3:\n                    _a = _b.sent(), value = _a.value, done = _a.done;\n                    if (!done) return [3, 5];\n                    return [4, __await(void 0)];\n                case 4: return [2, _b.sent()];\n                case 5: return [4, __await(value)];\n                case 6: return [4, _b.sent()];\n                case 7:\n                    _b.sent();\n                    return [3, 2];\n                case 8: return [3, 10];\n                case 9:\n                    reader.releaseLock();\n                    return [7];\n                case 10: return [2];\n            }\n        });\n    });\n}\nexport function isReadableStreamLike(obj) {\n    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);\n}\n//# sourceMappingURL=isReadableStreamLike.js.map","import { isFunction } from './isFunction';\nexport function isScheduler(value) {\n    return value && isFunction(value.schedule);\n}\n//# sourceMappingURL=isScheduler.js.map","import { isFunction } from './isFunction';\nexport function hasLift(source) {\n    return isFunction(source === null || source === void 0 ? void 0 : source.lift);\n}\nexport function operate(init) {\n    return function (source) {\n        if (hasLift(source)) {\n            return source.lift(function (liftedSource) {\n                try {\n                    return init(liftedSource, this);\n                }\n                catch (err) {\n                    this.error(err);\n                }\n            });\n        }\n        throw new TypeError('Unable to lift unknown Observable type');\n    };\n}\n//# sourceMappingURL=lift.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { map } from \"../operators/map\";\nvar isArray = Array.isArray;\nfunction callOrApply(fn, args) {\n    return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);\n}\nexport function mapOneOrManyArgs(fn) {\n    return map(function (args) { return callOrApply(fn, args); });\n}\n//# sourceMappingURL=mapOneOrManyArgs.js.map","export function noop() { }\n//# sourceMappingURL=noop.js.map","import { identity } from './identity';\nexport function pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return pipeFromArray(fns);\n}\nexport function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\n//# sourceMappingURL=pipe.js.map","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\nexport function reportUnhandledError(err) {\n    timeoutProvider.setTimeout(function () {\n        var onUnhandledError = config.onUnhandledError;\n        if (onUnhandledError) {\n            onUnhandledError(err);\n        }\n        else {\n            throw err;\n        }\n    });\n}\n//# sourceMappingURL=reportUnhandledError.js.map","export function createInvalidObservableTypeError(input) {\n    return new TypeError(\"You provided \" + (input !== null && typeof input === 'object' ? 'an invalid object' : \"'\" + input + \"'\") + \" where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.\");\n}\n//# sourceMappingURL=throwUnobservableError.js.map","(function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var t;t=\"undefined\"==typeof window?\"undefined\"==typeof global?\"undefined\"==typeof self?this:self:global:window,t.SimplePeer=e()}})(function(){var t=Math.floor,n=Math.abs,r=Math.pow;return function(){function d(s,e,n){function t(o,i){if(!e[o]){if(!s[o]){var l=\"function\"==typeof require&&require;if(!i&&l)return l(o,!0);if(r)return r(o,!0);var c=new Error(\"Cannot find module '\"+o+\"'\");throw c.code=\"MODULE_NOT_FOUND\",c}var a=e[o]={exports:{}};s[o][0].call(a.exports,function(e){var r=s[o][1][e];return t(r||e)},a,a.exports,d,s,e,n)}return e[o].exports}for(var r=\"function\"==typeof require&&require,a=0;a<n.length;a++)t(n[a]);return t}return d}()({1:[function(e,t,n){'use strict';function r(e){var t=e.length;if(0<t%4)throw new Error(\"Invalid string. Length must be a multiple of 4\");var n=e.indexOf(\"=\");-1===n&&(n=t);var r=n===t?0:4-n%4;return[n,r]}function a(e,t,n){return 3*(t+n)/4-n}function o(e){var t,n,o=r(e),d=o[0],s=o[1],l=new p(a(e,d,s)),c=0,f=0<s?d-4:d;for(n=0;n<f;n+=4)t=u[e.charCodeAt(n)]<<18|u[e.charCodeAt(n+1)]<<12|u[e.charCodeAt(n+2)]<<6|u[e.charCodeAt(n+3)],l[c++]=255&t>>16,l[c++]=255&t>>8,l[c++]=255&t;return 2===s&&(t=u[e.charCodeAt(n)]<<2|u[e.charCodeAt(n+1)]>>4,l[c++]=255&t),1===s&&(t=u[e.charCodeAt(n)]<<10|u[e.charCodeAt(n+1)]<<4|u[e.charCodeAt(n+2)]>>2,l[c++]=255&t>>8,l[c++]=255&t),l}function d(e){return c[63&e>>18]+c[63&e>>12]+c[63&e>>6]+c[63&e]}function s(e,t,n){for(var r,a=[],o=t;o<n;o+=3)r=(16711680&e[o]<<16)+(65280&e[o+1]<<8)+(255&e[o+2]),a.push(d(r));return a.join(\"\")}function l(e){for(var t,n=e.length,r=n%3,a=[],o=16383,d=0,l=n-r;d<l;d+=o)a.push(s(e,d,d+o>l?l:d+o));return 1===r?(t=e[n-1],a.push(c[t>>2]+c[63&t<<4]+\"==\")):2===r&&(t=(e[n-2]<<8)+e[n-1],a.push(c[t>>10]+c[63&t>>4]+c[63&t<<2]+\"=\")),a.join(\"\")}n.byteLength=function(e){var t=r(e),n=t[0],a=t[1];return 3*(n+a)/4-a},n.toByteArray=o,n.fromByteArray=l;for(var c=[],u=[],p=\"undefined\"==typeof Uint8Array?Array:Uint8Array,f=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",g=0,_=f.length;g<_;++g)c[g]=f[g],u[f.charCodeAt(g)]=g;u[45]=62,u[95]=63},{}],2:[function(){},{}],3:[function(e,t,n){(function(){(function(){/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */'use strict';var t=String.fromCharCode,o=Math.min;function d(e){if(2147483647<e)throw new RangeError(\"The value \\\"\"+e+\"\\\" is invalid for option \\\"size\\\"\");var t=new Uint8Array(e);return t.__proto__=s.prototype,t}function s(e,t,n){if(\"number\"==typeof e){if(\"string\"==typeof t)throw new TypeError(\"The \\\"string\\\" argument must be of type string. Received type number\");return p(e)}return l(e,t,n)}function l(e,t,n){if(\"string\"==typeof e)return f(e,t);if(ArrayBuffer.isView(e))return g(e);if(null==e)throw TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof e);if(K(e,ArrayBuffer)||e&&K(e.buffer,ArrayBuffer))return _(e,t,n);if(\"number\"==typeof e)throw new TypeError(\"The \\\"value\\\" argument must not be of type number. Received type number\");var r=e.valueOf&&e.valueOf();if(null!=r&&r!==e)return s.from(r,t,n);var a=h(e);if(a)return a;if(\"undefined\"!=typeof Symbol&&null!=Symbol.toPrimitive&&\"function\"==typeof e[Symbol.toPrimitive])return s.from(e[Symbol.toPrimitive](\"string\"),t,n);throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof e)}function c(e){if(\"number\"!=typeof e)throw new TypeError(\"\\\"size\\\" argument must be of type number\");else if(0>e)throw new RangeError(\"The value \\\"\"+e+\"\\\" is invalid for option \\\"size\\\"\")}function u(e,t,n){return c(e),0>=e?d(e):void 0===t?d(e):\"string\"==typeof n?d(e).fill(t,n):d(e).fill(t)}function p(e){return c(e),d(0>e?0:0|m(e))}function f(e,t){if((\"string\"!=typeof t||\"\"===t)&&(t=\"utf8\"),!s.isEncoding(t))throw new TypeError(\"Unknown encoding: \"+t);var n=0|b(e,t),r=d(n),a=r.write(e,t);return a!==n&&(r=r.slice(0,a)),r}function g(e){for(var t=0>e.length?0:0|m(e.length),n=d(t),r=0;r<t;r+=1)n[r]=255&e[r];return n}function _(e,t,n){if(0>t||e.byteLength<t)throw new RangeError(\"\\\"offset\\\" is outside of buffer bounds\");if(e.byteLength<t+(n||0))throw new RangeError(\"\\\"length\\\" is outside of buffer bounds\");var r;return r=void 0===t&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,t):new Uint8Array(e,t,n),r.__proto__=s.prototype,r}function h(e){if(s.isBuffer(e)){var t=0|m(e.length),n=d(t);return 0===n.length?n:(e.copy(n,0,0,t),n)}return void 0===e.length?\"Buffer\"===e.type&&Array.isArray(e.data)?g(e.data):void 0:\"number\"!=typeof e.length||X(e.length)?d(0):g(e)}function m(e){if(e>=2147483647)throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+2147483647 .toString(16)+\" bytes\");return 0|e}function b(e,t){if(s.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||K(e,ArrayBuffer))return e.byteLength;if(\"string\"!=typeof e)throw new TypeError(\"The \\\"string\\\" argument must be one of type string, Buffer, or ArrayBuffer. Received type \"+typeof e);var n=e.length,r=2<arguments.length&&!0===arguments[2];if(!r&&0===n)return 0;for(var a=!1;;)switch(t){case\"ascii\":case\"latin1\":case\"binary\":return n;case\"utf8\":case\"utf-8\":return H(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return 2*n;case\"hex\":return n>>>1;case\"base64\":return z(e).length;default:if(a)return r?-1:H(e).length;t=(\"\"+t).toLowerCase(),a=!0;}}function y(e,t,n){var r=!1;if((void 0===t||0>t)&&(t=0),t>this.length)return\"\";if((void 0===n||n>this.length)&&(n=this.length),0>=n)return\"\";if(n>>>=0,t>>>=0,n<=t)return\"\";for(e||(e=\"utf8\");;)switch(e){case\"hex\":return P(this,t,n);case\"utf8\":case\"utf-8\":return x(this,t,n);case\"ascii\":return D(this,t,n);case\"latin1\":case\"binary\":return I(this,t,n);case\"base64\":return A(this,t,n);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return M(this,t,n);default:if(r)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase(),r=!0;}}function C(e,t,n){var r=e[t];e[t]=e[n],e[n]=r}function R(e,t,n,r,a){if(0===e.length)return-1;if(\"string\"==typeof n?(r=n,n=0):2147483647<n?n=2147483647:-2147483648>n&&(n=-2147483648),n=+n,X(n)&&(n=a?0:e.length-1),0>n&&(n=e.length+n),n>=e.length){if(a)return-1;n=e.length-1}else if(0>n)if(a)n=0;else return-1;if(\"string\"==typeof t&&(t=s.from(t,r)),s.isBuffer(t))return 0===t.length?-1:E(e,t,n,r,a);if(\"number\"==typeof t)return t&=255,\"function\"==typeof Uint8Array.prototype.indexOf?a?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):E(e,[t],n,r,a);throw new TypeError(\"val must be string, number or Buffer\")}function E(e,t,n,r,a){function o(e,t){return 1===d?e[t]:e.readUInt16BE(t*d)}var d=1,s=e.length,l=t.length;if(void 0!==r&&(r=(r+\"\").toLowerCase(),\"ucs2\"===r||\"ucs-2\"===r||\"utf16le\"===r||\"utf-16le\"===r)){if(2>e.length||2>t.length)return-1;d=2,s/=2,l/=2,n/=2}var c;if(a){var u=-1;for(c=n;c<s;c++)if(o(e,c)!==o(t,-1===u?0:c-u))-1!==u&&(c-=c-u),u=-1;else if(-1===u&&(u=c),c-u+1===l)return u*d}else for(n+l>s&&(n=s-l),c=n;0<=c;c--){for(var p=!0,f=0;f<l;f++)if(o(e,c+f)!==o(t,f)){p=!1;break}if(p)return c}return-1}function w(e,t,n,r){n=+n||0;var a=e.length-n;r?(r=+r,r>a&&(r=a)):r=a;var o=t.length;r>o/2&&(r=o/2);for(var d,s=0;s<r;++s){if(d=parseInt(t.substr(2*s,2),16),X(d))return s;e[n+s]=d}return s}function S(e,t,n,r){return G(H(t,e.length-n),e,n,r)}function T(e,t,n,r){return G(Y(t),e,n,r)}function v(e,t,n,r){return T(e,t,n,r)}function k(e,t,n,r){return G(z(t),e,n,r)}function L(e,t,n,r){return G(V(t,e.length-n),e,n,r)}function A(e,t,n){return 0===t&&n===e.length?$.fromByteArray(e):$.fromByteArray(e.slice(t,n))}function x(e,t,n){n=o(e.length,n);for(var r=[],a=t;a<n;){var d=e[a],s=null,l=239<d?4:223<d?3:191<d?2:1;if(a+l<=n){var c,u,p,f;1===l?128>d&&(s=d):2===l?(c=e[a+1],128==(192&c)&&(f=(31&d)<<6|63&c,127<f&&(s=f))):3===l?(c=e[a+1],u=e[a+2],128==(192&c)&&128==(192&u)&&(f=(15&d)<<12|(63&c)<<6|63&u,2047<f&&(55296>f||57343<f)&&(s=f))):4===l?(c=e[a+1],u=e[a+2],p=e[a+3],128==(192&c)&&128==(192&u)&&128==(192&p)&&(f=(15&d)<<18|(63&c)<<12|(63&u)<<6|63&p,65535<f&&1114112>f&&(s=f))):void 0}null===s?(s=65533,l=1):65535<s&&(s-=65536,r.push(55296|1023&s>>>10),s=56320|1023&s),r.push(s),a+=l}return N(r)}function N(e){var n=e.length;if(n<=4096)return t.apply(String,e);for(var r=\"\",a=0;a<n;)r+=t.apply(String,e.slice(a,a+=4096));return r}function D(e,n,r){var a=\"\";r=o(e.length,r);for(var d=n;d<r;++d)a+=t(127&e[d]);return a}function I(e,n,r){var a=\"\";r=o(e.length,r);for(var d=n;d<r;++d)a+=t(e[d]);return a}function P(e,t,n){var r=e.length;(!t||0>t)&&(t=0),(!n||0>n||n>r)&&(n=r);for(var a=\"\",o=t;o<n;++o)a+=W(e[o]);return a}function M(e,n,r){for(var a=e.slice(n,r),o=\"\",d=0;d<a.length;d+=2)o+=t(a[d]+256*a[d+1]);return o}function O(e,t,n){if(0!=e%1||0>e)throw new RangeError(\"offset is not uint\");if(e+t>n)throw new RangeError(\"Trying to access beyond buffer length\")}function F(e,t,n,r,a,o){if(!s.isBuffer(e))throw new TypeError(\"\\\"buffer\\\" argument must be a Buffer instance\");if(t>a||t<o)throw new RangeError(\"\\\"value\\\" argument is out of bounds\");if(n+r>e.length)throw new RangeError(\"Index out of range\")}function B(e,t,n,r){if(n+r>e.length)throw new RangeError(\"Index out of range\");if(0>n)throw new RangeError(\"Index out of range\")}function U(e,t,n,r,a){return t=+t,n>>>=0,a||B(e,t,n,4,34028234663852886e22,-34028234663852886e22),J.write(e,t,n,r,23,4),n+4}function j(e,t,n,r,a){return t=+t,n>>>=0,a||B(e,t,n,8,17976931348623157e292,-17976931348623157e292),J.write(e,t,n,r,52,8),n+8}function q(e){if(e=e.split(\"=\")[0],e=e.trim().replace(Q,\"\"),2>e.length)return\"\";for(;0!=e.length%4;)e+=\"=\";return e}function W(e){return 16>e?\"0\"+e.toString(16):e.toString(16)}function H(e,t){t=t||1/0;for(var n,r=e.length,a=null,o=[],d=0;d<r;++d){if(n=e.charCodeAt(d),55295<n&&57344>n){if(!a){if(56319<n){-1<(t-=3)&&o.push(239,191,189);continue}else if(d+1===r){-1<(t-=3)&&o.push(239,191,189);continue}a=n;continue}if(56320>n){-1<(t-=3)&&o.push(239,191,189),a=n;continue}n=(a-55296<<10|n-56320)+65536}else a&&-1<(t-=3)&&o.push(239,191,189);if(a=null,128>n){if(0>(t-=1))break;o.push(n)}else if(2048>n){if(0>(t-=2))break;o.push(192|n>>6,128|63&n)}else if(65536>n){if(0>(t-=3))break;o.push(224|n>>12,128|63&n>>6,128|63&n)}else if(1114112>n){if(0>(t-=4))break;o.push(240|n>>18,128|63&n>>12,128|63&n>>6,128|63&n)}else throw new Error(\"Invalid code point\")}return o}function Y(e){for(var t=[],n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}function V(e,t){for(var n,r,a,o=[],d=0;d<e.length&&!(0>(t-=2));++d)n=e.charCodeAt(d),r=n>>8,a=n%256,o.push(a),o.push(r);return o}function z(e){return $.toByteArray(q(e))}function G(e,t,n,r){for(var a=0;a<r&&!(a+n>=t.length||a>=e.length);++a)t[a+n]=e[a];return a}function K(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function X(e){return e!==e}var $=e(\"base64-js\"),J=e(\"ieee754\");n.Buffer=s,n.SlowBuffer=function(e){return+e!=e&&(e=0),s.alloc(+e)},n.INSPECT_MAX_BYTES=50;n.kMaxLength=2147483647,s.TYPED_ARRAY_SUPPORT=function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()}catch(t){return!1}}(),s.TYPED_ARRAY_SUPPORT||\"undefined\"==typeof console||\"function\"!=typeof console.error||console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"),Object.defineProperty(s.prototype,\"parent\",{enumerable:!0,get:function(){return s.isBuffer(this)?this.buffer:void 0}}),Object.defineProperty(s.prototype,\"offset\",{enumerable:!0,get:function(){return s.isBuffer(this)?this.byteOffset:void 0}}),\"undefined\"!=typeof Symbol&&null!=Symbol.species&&s[Symbol.species]===s&&Object.defineProperty(s,Symbol.species,{value:null,configurable:!0,enumerable:!1,writable:!1}),s.poolSize=8192,s.from=function(e,t,n){return l(e,t,n)},s.prototype.__proto__=Uint8Array.prototype,s.__proto__=Uint8Array,s.alloc=function(e,t,n){return u(e,t,n)},s.allocUnsafe=function(e){return p(e)},s.allocUnsafeSlow=function(e){return p(e)},s.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==s.prototype},s.compare=function(e,t){if(K(e,Uint8Array)&&(e=s.from(e,e.offset,e.byteLength)),K(t,Uint8Array)&&(t=s.from(t,t.offset,t.byteLength)),!s.isBuffer(e)||!s.isBuffer(t))throw new TypeError(\"The \\\"buf1\\\", \\\"buf2\\\" arguments must be one of type Buffer or Uint8Array\");if(e===t)return 0;for(var n=e.length,r=t.length,d=0,l=o(n,r);d<l;++d)if(e[d]!==t[d]){n=e[d],r=t[d];break}return n<r?-1:r<n?1:0},s.isEncoding=function(e){switch((e+\"\").toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1;}},s.concat=function(e,t){if(!Array.isArray(e))throw new TypeError(\"\\\"list\\\" argument must be an Array of Buffers\");if(0===e.length)return s.alloc(0);var n;if(t===void 0)for(t=0,n=0;n<e.length;++n)t+=e[n].length;var r=s.allocUnsafe(t),a=0;for(n=0;n<e.length;++n){var o=e[n];if(K(o,Uint8Array)&&(o=s.from(o)),!s.isBuffer(o))throw new TypeError(\"\\\"list\\\" argument must be an Array of Buffers\");o.copy(r,a),a+=o.length}return r},s.byteLength=b,s.prototype._isBuffer=!0,s.prototype.swap16=function(){var e=this.length;if(0!=e%2)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(var t=0;t<e;t+=2)C(this,t,t+1);return this},s.prototype.swap32=function(){var e=this.length;if(0!=e%4)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(var t=0;t<e;t+=4)C(this,t,t+3),C(this,t+1,t+2);return this},s.prototype.swap64=function(){var e=this.length;if(0!=e%8)throw new RangeError(\"Buffer size must be a multiple of 64-bits\");for(var t=0;t<e;t+=8)C(this,t,t+7),C(this,t+1,t+6),C(this,t+2,t+5),C(this,t+3,t+4);return this},s.prototype.toString=function(){var e=this.length;return 0===e?\"\":0===arguments.length?x(this,0,e):y.apply(this,arguments)},s.prototype.toLocaleString=s.prototype.toString,s.prototype.equals=function(e){if(!s.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");return this===e||0===s.compare(this,e)},s.prototype.inspect=function(){var e=\"\",t=n.INSPECT_MAX_BYTES;return e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim(),this.length>t&&(e+=\" ... \"),\"<Buffer \"+e+\">\"},s.prototype.compare=function(e,t,n,r,a){if(K(e,Uint8Array)&&(e=s.from(e,e.offset,e.byteLength)),!s.isBuffer(e))throw new TypeError(\"The \\\"target\\\" argument must be one of type Buffer or Uint8Array. Received type \"+typeof e);if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===r&&(r=0),void 0===a&&(a=this.length),0>t||n>e.length||0>r||a>this.length)throw new RangeError(\"out of range index\");if(r>=a&&t>=n)return 0;if(r>=a)return-1;if(t>=n)return 1;if(t>>>=0,n>>>=0,r>>>=0,a>>>=0,this===e)return 0;for(var d=a-r,l=n-t,c=o(d,l),u=this.slice(r,a),p=e.slice(t,n),f=0;f<c;++f)if(u[f]!==p[f]){d=u[f],l=p[f];break}return d<l?-1:l<d?1:0},s.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},s.prototype.indexOf=function(e,t,n){return R(this,e,t,n,!0)},s.prototype.lastIndexOf=function(e,t,n){return R(this,e,t,n,!1)},s.prototype.write=function(e,t,n,r){if(void 0===t)r=\"utf8\",n=this.length,t=0;else if(void 0===n&&\"string\"==typeof t)r=t,n=this.length,t=0;else if(isFinite(t))t>>>=0,isFinite(n)?(n>>>=0,void 0===r&&(r=\"utf8\")):(r=n,n=void 0);else throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");var a=this.length-t;if((void 0===n||n>a)&&(n=a),0<e.length&&(0>n||0>t)||t>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");r||(r=\"utf8\");for(var o=!1;;)switch(r){case\"hex\":return w(this,e,t,n);case\"utf8\":case\"utf-8\":return S(this,e,t,n);case\"ascii\":return T(this,e,t,n);case\"latin1\":case\"binary\":return v(this,e,t,n);case\"base64\":return k(this,e,t,n);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return L(this,e,t,n);default:if(o)throw new TypeError(\"Unknown encoding: \"+r);r=(\"\"+r).toLowerCase(),o=!0;}},s.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};s.prototype.slice=function(e,t){var n=this.length;e=~~e,t=t===void 0?n:~~t,0>e?(e+=n,0>e&&(e=0)):e>n&&(e=n),0>t?(t+=n,0>t&&(t=0)):t>n&&(t=n),t<e&&(t=e);var r=this.subarray(e,t);return r.__proto__=s.prototype,r},s.prototype.readUIntLE=function(e,t,n){e>>>=0,t>>>=0,n||O(e,t,this.length);for(var r=this[e],a=1,o=0;++o<t&&(a*=256);)r+=this[e+o]*a;return r},s.prototype.readUIntBE=function(e,t,n){e>>>=0,t>>>=0,n||O(e,t,this.length);for(var r=this[e+--t],a=1;0<t&&(a*=256);)r+=this[e+--t]*a;return r},s.prototype.readUInt8=function(e,t){return e>>>=0,t||O(e,1,this.length),this[e]},s.prototype.readUInt16LE=function(e,t){return e>>>=0,t||O(e,2,this.length),this[e]|this[e+1]<<8},s.prototype.readUInt16BE=function(e,t){return e>>>=0,t||O(e,2,this.length),this[e]<<8|this[e+1]},s.prototype.readUInt32LE=function(e,t){return e>>>=0,t||O(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},s.prototype.readUInt32BE=function(e,t){return e>>>=0,t||O(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},s.prototype.readIntLE=function(e,t,n){e>>>=0,t>>>=0,n||O(e,t,this.length);for(var a=this[e],o=1,d=0;++d<t&&(o*=256);)a+=this[e+d]*o;return o*=128,a>=o&&(a-=r(2,8*t)),a},s.prototype.readIntBE=function(e,t,n){e>>>=0,t>>>=0,n||O(e,t,this.length);for(var a=t,o=1,d=this[e+--a];0<a&&(o*=256);)d+=this[e+--a]*o;return o*=128,d>=o&&(d-=r(2,8*t)),d},s.prototype.readInt8=function(e,t){return e>>>=0,t||O(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},s.prototype.readInt16LE=function(e,t){e>>>=0,t||O(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},s.prototype.readInt16BE=function(e,t){e>>>=0,t||O(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},s.prototype.readInt32LE=function(e,t){return e>>>=0,t||O(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},s.prototype.readInt32BE=function(e,t){return e>>>=0,t||O(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},s.prototype.readFloatLE=function(e,t){return e>>>=0,t||O(e,4,this.length),J.read(this,e,!0,23,4)},s.prototype.readFloatBE=function(e,t){return e>>>=0,t||O(e,4,this.length),J.read(this,e,!1,23,4)},s.prototype.readDoubleLE=function(e,t){return e>>>=0,t||O(e,8,this.length),J.read(this,e,!0,52,8)},s.prototype.readDoubleBE=function(e,t){return e>>>=0,t||O(e,8,this.length),J.read(this,e,!1,52,8)},s.prototype.writeUIntLE=function(e,t,n,a){if(e=+e,t>>>=0,n>>>=0,!a){var o=r(2,8*n)-1;F(this,e,t,n,o,0)}var d=1,s=0;for(this[t]=255&e;++s<n&&(d*=256);)this[t+s]=255&e/d;return t+n},s.prototype.writeUIntBE=function(e,t,n,a){if(e=+e,t>>>=0,n>>>=0,!a){var o=r(2,8*n)-1;F(this,e,t,n,o,0)}var d=n-1,s=1;for(this[t+d]=255&e;0<=--d&&(s*=256);)this[t+d]=255&e/s;return t+n},s.prototype.writeUInt8=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,1,255,0),this[t]=255&e,t+1},s.prototype.writeUInt16LE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},s.prototype.writeUInt16BE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},s.prototype.writeUInt32LE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},s.prototype.writeUInt32BE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},s.prototype.writeIntLE=function(e,t,n,a){if(e=+e,t>>>=0,!a){var o=r(2,8*n-1);F(this,e,t,n,o-1,-o)}var d=0,s=1,l=0;for(this[t]=255&e;++d<n&&(s*=256);)0>e&&0===l&&0!==this[t+d-1]&&(l=1),this[t+d]=255&(e/s>>0)-l;return t+n},s.prototype.writeIntBE=function(e,t,n,a){if(e=+e,t>>>=0,!a){var o=r(2,8*n-1);F(this,e,t,n,o-1,-o)}var d=n-1,s=1,l=0;for(this[t+d]=255&e;0<=--d&&(s*=256);)0>e&&0===l&&0!==this[t+d+1]&&(l=1),this[t+d]=255&(e/s>>0)-l;return t+n},s.prototype.writeInt8=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,1,127,-128),0>e&&(e=255+e+1),this[t]=255&e,t+1},s.prototype.writeInt16LE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},s.prototype.writeInt16BE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},s.prototype.writeInt32LE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},s.prototype.writeInt32BE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,4,2147483647,-2147483648),0>e&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},s.prototype.writeFloatLE=function(e,t,n){return U(this,e,t,!0,n)},s.prototype.writeFloatBE=function(e,t,n){return U(this,e,t,!1,n)},s.prototype.writeDoubleLE=function(e,t,n){return j(this,e,t,!0,n)},s.prototype.writeDoubleBE=function(e,t,n){return j(this,e,t,!1,n)},s.prototype.copy=function(e,t,n,r){if(!s.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(n||(n=0),r||0===r||(r=this.length),t>=e.length&&(t=e.length),t||(t=0),0<r&&r<n&&(r=n),r===n)return 0;if(0===e.length||0===this.length)return 0;if(0>t)throw new RangeError(\"targetStart out of bounds\");if(0>n||n>=this.length)throw new RangeError(\"Index out of range\");if(0>r)throw new RangeError(\"sourceEnd out of bounds\");r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);var a=r-n;if(this===e&&\"function\"==typeof Uint8Array.prototype.copyWithin)this.copyWithin(t,n,r);else if(this===e&&n<t&&t<r)for(var o=a-1;0<=o;--o)e[o+t]=this[o+n];else Uint8Array.prototype.set.call(e,this.subarray(n,r),t);return a},s.prototype.fill=function(e,t,n,r){if(\"string\"==typeof e){if(\"string\"==typeof t?(r=t,t=0,n=this.length):\"string\"==typeof n&&(r=n,n=this.length),void 0!==r&&\"string\"!=typeof r)throw new TypeError(\"encoding must be a string\");if(\"string\"==typeof r&&!s.isEncoding(r))throw new TypeError(\"Unknown encoding: \"+r);if(1===e.length){var a=e.charCodeAt(0);(\"utf8\"===r&&128>a||\"latin1\"===r)&&(e=a)}}else\"number\"==typeof e&&(e&=255);if(0>t||this.length<t||this.length<n)throw new RangeError(\"Out of range index\");if(n<=t)return this;t>>>=0,n=n===void 0?this.length:n>>>0,e||(e=0);var o;if(\"number\"==typeof e)for(o=t;o<n;++o)this[o]=e;else{var d=s.isBuffer(e)?e:s.from(e,r),l=d.length;if(0===l)throw new TypeError(\"The value \\\"\"+e+\"\\\" is invalid for argument \\\"value\\\"\");for(o=0;o<n-t;++o)this[o+t]=d[o%l]}return this};var Q=/[^+/0-9A-Za-z-_]/g}).call(this)}).call(this,e(\"buffer\").Buffer)},{\"base64-js\":1,buffer:3,ieee754:9}],4:[function(e,t,n){(function(a){(function(){function r(){let e;try{e=n.storage.getItem(\"debug\")}catch(e){}return!e&&\"undefined\"!=typeof a&&\"env\"in a&&(e=a.env.DEBUG),e}n.formatArgs=function(e){if(e[0]=(this.useColors?\"%c\":\"\")+this.namespace+(this.useColors?\" %c\":\" \")+e[0]+(this.useColors?\"%c \":\" \")+\"+\"+t.exports.humanize(this.diff),!this.useColors)return;const n=\"color: \"+this.color;e.splice(1,0,n,\"color: inherit\");let r=0,a=0;e[0].replace(/%[a-zA-Z%]/g,e=>{\"%%\"===e||(r++,\"%c\"===e&&(a=r))}),e.splice(a,0,n)},n.save=function(e){try{e?n.storage.setItem(\"debug\",e):n.storage.removeItem(\"debug\")}catch(e){}},n.load=r,n.useColors=function(){return!!(\"undefined\"!=typeof window&&window.process&&(\"renderer\"===window.process.type||window.process.__nwjs))||!(\"undefined\"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/))&&(\"undefined\"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||\"undefined\"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||\"undefined\"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)&&31<=parseInt(RegExp.$1,10)||\"undefined\"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/))},n.storage=function(){try{return localStorage}catch(e){}}(),n.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"))}})(),n.colors=[\"#0000CC\",\"#0000FF\",\"#0033CC\",\"#0033FF\",\"#0066CC\",\"#0066FF\",\"#0099CC\",\"#0099FF\",\"#00CC00\",\"#00CC33\",\"#00CC66\",\"#00CC99\",\"#00CCCC\",\"#00CCFF\",\"#3300CC\",\"#3300FF\",\"#3333CC\",\"#3333FF\",\"#3366CC\",\"#3366FF\",\"#3399CC\",\"#3399FF\",\"#33CC00\",\"#33CC33\",\"#33CC66\",\"#33CC99\",\"#33CCCC\",\"#33CCFF\",\"#6600CC\",\"#6600FF\",\"#6633CC\",\"#6633FF\",\"#66CC00\",\"#66CC33\",\"#9900CC\",\"#9900FF\",\"#9933CC\",\"#9933FF\",\"#99CC00\",\"#99CC33\",\"#CC0000\",\"#CC0033\",\"#CC0066\",\"#CC0099\",\"#CC00CC\",\"#CC00FF\",\"#CC3300\",\"#CC3333\",\"#CC3366\",\"#CC3399\",\"#CC33CC\",\"#CC33FF\",\"#CC6600\",\"#CC6633\",\"#CC9900\",\"#CC9933\",\"#CCCC00\",\"#CCCC33\",\"#FF0000\",\"#FF0033\",\"#FF0066\",\"#FF0099\",\"#FF00CC\",\"#FF00FF\",\"#FF3300\",\"#FF3333\",\"#FF3366\",\"#FF3399\",\"#FF33CC\",\"#FF33FF\",\"#FF6600\",\"#FF6633\",\"#FF9900\",\"#FF9933\",\"#FFCC00\",\"#FFCC33\"],n.log=console.debug||console.log||(()=>{}),t.exports=e(\"./common\")(n);const{formatters:o}=t.exports;o.j=function(e){try{return JSON.stringify(e)}catch(e){return\"[UnexpectedJSONParseError]: \"+e.message}}}).call(this)}).call(this,e(\"_process\"))},{\"./common\":5,_process:12}],5:[function(e,t){t.exports=function(t){function r(e){function t(...e){if(!t.enabled)return;const a=t,o=+new Date,i=o-(n||o);a.diff=i,a.prev=n,a.curr=o,n=o,e[0]=r.coerce(e[0]),\"string\"!=typeof e[0]&&e.unshift(\"%O\");let d=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,(t,n)=>{if(\"%%\"===t)return\"%\";d++;const o=r.formatters[n];if(\"function\"==typeof o){const n=e[d];t=o.call(a,n),e.splice(d,1),d--}return t}),r.formatArgs.call(a,e);const s=a.log||r.log;s.apply(a,e)}let n,o=null;return t.namespace=e,t.useColors=r.useColors(),t.color=r.selectColor(e),t.extend=a,t.destroy=r.destroy,Object.defineProperty(t,\"enabled\",{enumerable:!0,configurable:!1,get:()=>null===o?r.enabled(e):o,set:e=>{o=e}}),\"function\"==typeof r.init&&r.init(t),t}function a(e,t){const n=r(this.namespace+(\"undefined\"==typeof t?\":\":t)+e);return n.log=this.log,n}function o(e){return e.toString().substring(2,e.toString().length-2).replace(/\\.\\*\\?$/,\"*\")}return r.debug=r,r.default=r,r.coerce=function(e){return e instanceof Error?e.stack||e.message:e},r.disable=function(){const e=[...r.names.map(o),...r.skips.map(o).map(e=>\"-\"+e)].join(\",\");return r.enable(\"\"),e},r.enable=function(e){r.save(e),r.names=[],r.skips=[];let t;const n=(\"string\"==typeof e?e:\"\").split(/[\\s,]+/),a=n.length;for(t=0;t<a;t++)n[t]&&(e=n[t].replace(/\\*/g,\".*?\"),\"-\"===e[0]?r.skips.push(new RegExp(\"^\"+e.substr(1)+\"$\")):r.names.push(new RegExp(\"^\"+e+\"$\")))},r.enabled=function(e){if(\"*\"===e[e.length-1])return!0;let t,n;for(t=0,n=r.skips.length;t<n;t++)if(r.skips[t].test(e))return!1;for(t=0,n=r.names.length;t<n;t++)if(r.names[t].test(e))return!0;return!1},r.humanize=e(\"ms\"),r.destroy=function(){console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\")},Object.keys(t).forEach(e=>{r[e]=t[e]}),r.names=[],r.skips=[],r.formatters={},r.selectColor=function(e){let t=0;for(let n=0;n<e.length;n++)t=(t<<5)-t+e.charCodeAt(n),t|=0;return r.colors[n(t)%r.colors.length]},r.enable(r.load()),r}},{ms:11}],6:[function(e,t){'use strict';function n(e,t){for(const n in t)Object.defineProperty(e,n,{value:t[n],enumerable:!0,configurable:!0});return e}t.exports=function(e,t,r){if(!e||\"string\"==typeof e)throw new TypeError(\"Please pass an Error to err-code\");r||(r={}),\"object\"==typeof t&&(r=t,t=\"\"),t&&(r.code=t);try{return n(e,r)}catch(t){r.message=e.message,r.stack=e.stack;const a=function(){};a.prototype=Object.create(Object.getPrototypeOf(e));const o=n(new a,r);return o}}},{}],7:[function(e,t){'use strict';function n(e){console&&console.warn&&console.warn(e)}function r(){r.init.call(this)}function a(e){if(\"function\"!=typeof e)throw new TypeError(\"The \\\"listener\\\" argument must be of type Function. Received type \"+typeof e)}function o(e){return void 0===e._maxListeners?r.defaultMaxListeners:e._maxListeners}function i(e,t,r,i){var d,s,l;if(a(r),s=e._events,void 0===s?(s=e._events=Object.create(null),e._eventsCount=0):(void 0!==s.newListener&&(e.emit(\"newListener\",t,r.listener?r.listener:r),s=e._events),l=s[t]),void 0===l)l=s[t]=r,++e._eventsCount;else if(\"function\"==typeof l?l=s[t]=i?[r,l]:[l,r]:i?l.unshift(r):l.push(r),d=o(e),0<d&&l.length>d&&!l.warned){l.warned=!0;var c=new Error(\"Possible EventEmitter memory leak detected. \"+l.length+\" \"+(t+\" listeners added. Use emitter.setMaxListeners() to increase limit\"));c.name=\"MaxListenersExceededWarning\",c.emitter=e,c.type=t,c.count=l.length,n(c)}return e}function d(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function s(e,t,n){var r={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},a=d.bind(r);return a.listener=n,r.wrapFn=a,a}function l(e,t,n){var r=e._events;if(r===void 0)return[];var a=r[t];return void 0===a?[]:\"function\"==typeof a?n?[a.listener||a]:[a]:n?f(a):u(a,a.length)}function c(e){var t=this._events;if(t!==void 0){var n=t[e];if(\"function\"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function u(e,t){for(var n=Array(t),r=0;r<t;++r)n[r]=e[r];return n}function p(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}function f(e){for(var t=Array(e.length),n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}function g(e,t,n){\"function\"==typeof e.on&&_(e,\"error\",t,n)}function _(e,t,n,r){if(\"function\"==typeof e.on)r.once?e.once(t,n):e.on(t,n);else if(\"function\"==typeof e.addEventListener)e.addEventListener(t,function a(o){r.once&&e.removeEventListener(t,a),n(o)});else throw new TypeError(\"The \\\"emitter\\\" argument must be of type EventEmitter. Received type \"+typeof e)}var h,m=\"object\"==typeof Reflect?Reflect:null,b=m&&\"function\"==typeof m.apply?m.apply:function(e,t,n){return Function.prototype.apply.call(e,t,n)};h=m&&\"function\"==typeof m.ownKeys?m.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var y=Number.isNaN||function(e){return e!==e};t.exports=r,t.exports.once=function(e,t){return new Promise(function(n,r){function a(n){e.removeListener(t,o),r(n)}function o(){\"function\"==typeof e.removeListener&&e.removeListener(\"error\",a),n([].slice.call(arguments))}_(e,t,o,{once:!0}),\"error\"!==t&&g(e,a,{once:!0})})},r.EventEmitter=r,r.prototype._events=void 0,r.prototype._eventsCount=0,r.prototype._maxListeners=void 0;var C=10;Object.defineProperty(r,\"defaultMaxListeners\",{enumerable:!0,get:function(){return C},set:function(e){if(\"number\"!=typeof e||0>e||y(e))throw new RangeError(\"The value of \\\"defaultMaxListeners\\\" is out of range. It must be a non-negative number. Received \"+e+\".\");C=e}}),r.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},r.prototype.setMaxListeners=function(e){if(\"number\"!=typeof e||0>e||y(e))throw new RangeError(\"The value of \\\"n\\\" is out of range. It must be a non-negative number. Received \"+e+\".\");return this._maxListeners=e,this},r.prototype.getMaxListeners=function(){return o(this)},r.prototype.emit=function(e){for(var t=[],n=1;n<arguments.length;n++)t.push(arguments[n]);var r=\"error\"===e,a=this._events;if(a!==void 0)r=r&&a.error===void 0;else if(!r)return!1;if(r){var o;if(0<t.length&&(o=t[0]),o instanceof Error)throw o;var d=new Error(\"Unhandled error.\"+(o?\" (\"+o.message+\")\":\"\"));throw d.context=o,d}var s=a[e];if(s===void 0)return!1;if(\"function\"==typeof s)b(s,this,t);else for(var l=s.length,c=u(s,l),n=0;n<l;++n)b(c[n],this,t);return!0},r.prototype.addListener=function(e,t){return i(this,e,t,!1)},r.prototype.on=r.prototype.addListener,r.prototype.prependListener=function(e,t){return i(this,e,t,!0)},r.prototype.once=function(e,t){return a(t),this.on(e,s(this,e,t)),this},r.prototype.prependOnceListener=function(e,t){return a(t),this.prependListener(e,s(this,e,t)),this},r.prototype.removeListener=function(e,t){var n,r,o,d,s;if(a(t),r=this._events,void 0===r)return this;if(n=r[e],void 0===n)return this;if(n===t||n.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete r[e],r.removeListener&&this.emit(\"removeListener\",e,n.listener||t));else if(\"function\"!=typeof n){for(o=-1,d=n.length-1;0<=d;d--)if(n[d]===t||n[d].listener===t){s=n[d].listener,o=d;break}if(0>o)return this;0===o?n.shift():p(n,o),1===n.length&&(r[e]=n[0]),void 0!==r.removeListener&&this.emit(\"removeListener\",e,s||t)}return this},r.prototype.off=r.prototype.removeListener,r.prototype.removeAllListeners=function(e){var t,n,r;if(n=this._events,void 0===n)return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete n[e]),this;if(0===arguments.length){var a,o=Object.keys(n);for(r=0;r<o.length;++r)a=o[r],\"removeListener\"!==a&&this.removeAllListeners(a);return this.removeAllListeners(\"removeListener\"),this._events=Object.create(null),this._eventsCount=0,this}if(t=n[e],\"function\"==typeof t)this.removeListener(e,t);else if(void 0!==t)for(r=t.length-1;0<=r;r--)this.removeListener(e,t[r]);return this},r.prototype.listeners=function(e){return l(this,e,!0)},r.prototype.rawListeners=function(e){return l(this,e,!1)},r.listenerCount=function(e,t){return\"function\"==typeof e.listenerCount?e.listenerCount(t):c.call(e,t)},r.prototype.listenerCount=c,r.prototype.eventNames=function(){return 0<this._eventsCount?h(this._events):[]}},{}],8:[function(e,t){t.exports=function(){if(\"undefined\"==typeof globalThis)return null;var e={RTCPeerConnection:globalThis.RTCPeerConnection||globalThis.mozRTCPeerConnection||globalThis.webkitRTCPeerConnection,RTCSessionDescription:globalThis.RTCSessionDescription||globalThis.mozRTCSessionDescription||globalThis.webkitRTCSessionDescription,RTCIceCandidate:globalThis.RTCIceCandidate||globalThis.mozRTCIceCandidate||globalThis.webkitRTCIceCandidate};return e.RTCPeerConnection?e:null}},{}],9:[function(e,a,o){/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */o.read=function(t,n,a,o,l){var c,u,p=8*l-o-1,f=(1<<p)-1,g=f>>1,_=-7,h=a?l-1:0,b=a?-1:1,d=t[n+h];for(h+=b,c=d&(1<<-_)-1,d>>=-_,_+=p;0<_;c=256*c+t[n+h],h+=b,_-=8);for(u=c&(1<<-_)-1,c>>=-_,_+=o;0<_;u=256*u+t[n+h],h+=b,_-=8);if(0===c)c=1-g;else{if(c===f)return u?NaN:(d?-1:1)*(1/0);u+=r(2,o),c-=g}return(d?-1:1)*u*r(2,c-o)},o.write=function(a,o,l,u,p,f){var h,b,y,g=Math.LN2,_=Math.log,C=8*f-p-1,R=(1<<C)-1,E=R>>1,w=23===p?r(2,-24)-r(2,-77):0,S=u?0:f-1,T=u?1:-1,d=0>o||0===o&&0>1/o?1:0;for(o=n(o),isNaN(o)||o===1/0?(b=isNaN(o)?1:0,h=R):(h=t(_(o)/g),1>o*(y=r(2,-h))&&(h--,y*=2),o+=1<=h+E?w/y:w*r(2,1-E),2<=o*y&&(h++,y/=2),h+E>=R?(b=0,h=R):1<=h+E?(b=(o*y-1)*r(2,p),h+=E):(b=o*r(2,E-1)*r(2,p),h=0));8<=p;a[l+S]=255&b,S+=T,b/=256,p-=8);for(h=h<<p|b,C+=p;0<C;a[l+S]=255&h,S+=T,h/=256,C-=8);a[l+S-T]|=128*d}},{}],10:[function(e,t){t.exports=\"function\"==typeof Object.create?function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:function(e,t){if(t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}}},{}],11:[function(e,t){var r=Math.round;function a(e){if(e+=\"\",!(100<e.length)){var t=/^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(t){var r=parseFloat(t[1]),n=(t[2]||\"ms\").toLowerCase();return\"years\"===n||\"year\"===n||\"yrs\"===n||\"yr\"===n||\"y\"===n?31557600000*r:\"weeks\"===n||\"week\"===n||\"w\"===n?604800000*r:\"days\"===n||\"day\"===n||\"d\"===n?86400000*r:\"hours\"===n||\"hour\"===n||\"hrs\"===n||\"hr\"===n||\"h\"===n?3600000*r:\"minutes\"===n||\"minute\"===n||\"mins\"===n||\"min\"===n||\"m\"===n?60000*r:\"seconds\"===n||\"second\"===n||\"secs\"===n||\"sec\"===n||\"s\"===n?1000*r:\"milliseconds\"===n||\"millisecond\"===n||\"msecs\"===n||\"msec\"===n||\"ms\"===n?r:void 0}}}function o(e){var t=n(e);return 86400000<=t?r(e/86400000)+\"d\":3600000<=t?r(e/3600000)+\"h\":60000<=t?r(e/60000)+\"m\":1000<=t?r(e/1000)+\"s\":e+\"ms\"}function i(e){var t=n(e);return 86400000<=t?s(e,t,86400000,\"day\"):3600000<=t?s(e,t,3600000,\"hour\"):60000<=t?s(e,t,60000,\"minute\"):1000<=t?s(e,t,1000,\"second\"):e+\" ms\"}function s(e,t,a,n){return r(e/a)+\" \"+n+(t>=1.5*a?\"s\":\"\")}var l=24*(60*60000);t.exports=function(e,t){t=t||{};var n=typeof e;if(\"string\"==n&&0<e.length)return a(e);if(\"number\"===n&&isFinite(e))return t.long?i(e):o(e);throw new Error(\"val is not a non-empty string or a valid number. val=\"+JSON.stringify(e))}},{}],12:[function(e,t){function n(){throw new Error(\"setTimeout has not been defined\")}function r(){throw new Error(\"clearTimeout has not been defined\")}function a(t){if(c===setTimeout)return setTimeout(t,0);if((c===n||!c)&&setTimeout)return c=setTimeout,setTimeout(t,0);try{return c(t,0)}catch(n){try{return c.call(null,t,0)}catch(n){return c.call(this,t,0)}}}function o(t){if(u===clearTimeout)return clearTimeout(t);if((u===r||!u)&&clearTimeout)return u=clearTimeout,clearTimeout(t);try{return u(t)}catch(n){try{return u.call(null,t)}catch(n){return u.call(this,t)}}}function i(){_&&f&&(_=!1,f.length?g=f.concat(g):h=-1,g.length&&d())}function d(){if(!_){var e=a(i);_=!0;for(var t=g.length;t;){for(f=g,g=[];++h<t;)f&&f[h].run();h=-1,t=g.length}f=null,_=!1,o(e)}}function s(e,t){this.fun=e,this.array=t}function l(){}var c,u,p=t.exports={};(function(){try{c=\"function\"==typeof setTimeout?setTimeout:n}catch(t){c=n}try{u=\"function\"==typeof clearTimeout?clearTimeout:r}catch(t){u=r}})();var f,g=[],_=!1,h=-1;p.nextTick=function(e){var t=Array(arguments.length-1);if(1<arguments.length)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];g.push(new s(e,t)),1!==g.length||_||a(d)},s.prototype.run=function(){this.fun.apply(null,this.array)},p.title=\"browser\",p.browser=!0,p.env={},p.argv=[],p.version=\"\",p.versions={},p.on=l,p.addListener=l,p.once=l,p.off=l,p.removeListener=l,p.removeAllListeners=l,p.emit=l,p.prependListener=l,p.prependOnceListener=l,p.listeners=function(){return[]},p.binding=function(){throw new Error(\"process.binding is not supported\")},p.cwd=function(){return\"/\"},p.chdir=function(){throw new Error(\"process.chdir is not supported\")},p.umask=function(){return 0}},{}],13:[function(e,t){(function(e){(function(){/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */let n;t.exports=\"function\"==typeof queueMicrotask?queueMicrotask.bind(\"undefined\"==typeof window?e:window):e=>(n||(n=Promise.resolve())).then(e).catch(e=>setTimeout(()=>{throw e},0))}).call(this)}).call(this,\"undefined\"==typeof global?\"undefined\"==typeof self?\"undefined\"==typeof window?{}:window:self:global)},{}],14:[function(e,t){(function(n,r){(function(){'use strict';var a=e(\"safe-buffer\").Buffer,o=r.crypto||r.msCrypto;t.exports=o&&o.getRandomValues?function(e,t){if(e>4294967295)throw new RangeError(\"requested too many random bytes\");var r=a.allocUnsafe(e);if(0<e)if(65536<e)for(var i=0;i<e;i+=65536)o.getRandomValues(r.slice(i,i+65536));else o.getRandomValues(r);return\"function\"==typeof t?n.nextTick(function(){t(null,r)}):r}:function(){throw new Error(\"Secure random number generation is not supported by this browser.\\nUse Chrome, Firefox or Internet Explorer 11\")}}).call(this)}).call(this,e(\"_process\"),\"undefined\"==typeof global?\"undefined\"==typeof self?\"undefined\"==typeof window?{}:window:self:global)},{_process:12,\"safe-buffer\":30}],15:[function(e,t){'use strict';function n(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e.__proto__=t}function r(e,t,r){function a(e,n,r){return\"string\"==typeof t?t:t(e,n,r)}r||(r=Error);var o=function(e){function t(t,n,r){return e.call(this,a(t,n,r))||this}return n(t,e),t}(r);o.prototype.name=r.name,o.prototype.code=e,s[e]=o}function a(e,t){if(Array.isArray(e)){var n=e.length;return e=e.map(function(e){return e+\"\"}),2<n?\"one of \".concat(t,\" \").concat(e.slice(0,n-1).join(\", \"),\", or \")+e[n-1]:2===n?\"one of \".concat(t,\" \").concat(e[0],\" or \").concat(e[1]):\"of \".concat(t,\" \").concat(e[0])}return\"of \".concat(t,\" \").concat(e+\"\")}function o(e,t,n){return e.substr(!n||0>n?0:+n,t.length)===t}function i(e,t,n){return(void 0===n||n>e.length)&&(n=e.length),e.substring(n-t.length,n)===t}function d(e,t,n){return\"number\"!=typeof n&&(n=0),!(n+t.length>e.length)&&-1!==e.indexOf(t,n)}var s={};r(\"ERR_INVALID_OPT_VALUE\",function(e,t){return\"The value \\\"\"+t+\"\\\" is invalid for option \\\"\"+e+\"\\\"\"},TypeError),r(\"ERR_INVALID_ARG_TYPE\",function(e,t,n){var r;\"string\"==typeof t&&o(t,\"not \")?(r=\"must not be\",t=t.replace(/^not /,\"\")):r=\"must be\";var s;if(i(e,\" argument\"))s=\"The \".concat(e,\" \").concat(r,\" \").concat(a(t,\"type\"));else{var l=d(e,\".\")?\"property\":\"argument\";s=\"The \\\"\".concat(e,\"\\\" \").concat(l,\" \").concat(r,\" \").concat(a(t,\"type\"))}return s+=\". Received type \".concat(typeof n),s},TypeError),r(\"ERR_STREAM_PUSH_AFTER_EOF\",\"stream.push() after EOF\"),r(\"ERR_METHOD_NOT_IMPLEMENTED\",function(e){return\"The \"+e+\" method is not implemented\"}),r(\"ERR_STREAM_PREMATURE_CLOSE\",\"Premature close\"),r(\"ERR_STREAM_DESTROYED\",function(e){return\"Cannot call \"+e+\" after a stream was destroyed\"}),r(\"ERR_MULTIPLE_CALLBACK\",\"Callback called multiple times\"),r(\"ERR_STREAM_CANNOT_PIPE\",\"Cannot pipe, not readable\"),r(\"ERR_STREAM_WRITE_AFTER_END\",\"write after end\"),r(\"ERR_STREAM_NULL_VALUES\",\"May not write null values to stream\",TypeError),r(\"ERR_UNKNOWN_ENCODING\",function(e){return\"Unknown encoding: \"+e},TypeError),r(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\",\"stream.unshift() after end event\"),t.exports.codes=s},{}],16:[function(e,t){(function(n){(function(){'use strict';function r(e){return this instanceof r?void(d.call(this,e),s.call(this,e),this.allowHalfOpen=!0,e&&(!1===e.readable&&(this.readable=!1),!1===e.writable&&(this.writable=!1),!1===e.allowHalfOpen&&(this.allowHalfOpen=!1,this.once(\"end\",a)))):new r(e)}function a(){this._writableState.ended||n.nextTick(o,this)}function o(e){e.end()}var i=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t};t.exports=r;var d=e(\"./_stream_readable\"),s=e(\"./_stream_writable\");e(\"inherits\")(r,d);for(var l,c=i(s.prototype),u=0;u<c.length;u++)l=c[u],r.prototype[l]||(r.prototype[l]=s.prototype[l]);Object.defineProperty(r.prototype,\"writableHighWaterMark\",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(r.prototype,\"writableBuffer\",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(r.prototype,\"writableLength\",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(r.prototype,\"destroyed\",{enumerable:!1,get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&this._readableState.destroyed&&this._writableState.destroyed},set:function(e){void 0===this._readableState||void 0===this._writableState||(this._readableState.destroyed=e,this._writableState.destroyed=e)}})}).call(this)}).call(this,e(\"_process\"))},{\"./_stream_readable\":18,\"./_stream_writable\":20,_process:12,inherits:10}],17:[function(e,t){'use strict';function n(e){return this instanceof n?void r.call(this,e):new n(e)}t.exports=n;var r=e(\"./_stream_transform\");e(\"inherits\")(n,r),n.prototype._transform=function(e,t,n){n(null,e)}},{\"./_stream_transform\":19,inherits:10}],18:[function(e,t){(function(n,r){(function(){'use strict';function a(e){return P.from(e)}function o(e){return P.isBuffer(e)||e instanceof M}function i(e,t,n){return\"function\"==typeof e.prependListener?e.prependListener(t,n):void(e._events&&e._events[t]?Array.isArray(e._events[t])?e._events[t].unshift(n):e._events[t]=[n,e._events[t]]:e.on(t,n))}function d(t,n,r){A=A||e(\"./_stream_duplex\"),t=t||{},\"boolean\"!=typeof r&&(r=n instanceof A),this.objectMode=!!t.objectMode,r&&(this.objectMode=this.objectMode||!!t.readableObjectMode),this.highWaterMark=H(this,t,\"readableHighWaterMark\",r),this.buffer=new j,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.paused=!0,this.emitClose=!1!==t.emitClose,this.autoDestroy=!!t.autoDestroy,this.destroyed=!1,this.defaultEncoding=t.defaultEncoding||\"utf8\",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,t.encoding&&(!F&&(F=e(\"string_decoder/\").StringDecoder),this.decoder=new F(t.encoding),this.encoding=t.encoding)}function s(t){if(A=A||e(\"./_stream_duplex\"),!(this instanceof s))return new s(t);var n=this instanceof A;this._readableState=new d(t,this,n),this.readable=!0,t&&(\"function\"==typeof t.read&&(this._read=t.read),\"function\"==typeof t.destroy&&(this._destroy=t.destroy)),I.call(this)}function l(e,t,n,r,o){x(\"readableAddChunk\",t);var i=e._readableState;if(null===t)i.reading=!1,g(e,i);else{var d;if(o||(d=u(i,t)),d)X(e,d);else if(!(i.objectMode||t&&0<t.length))r||(i.reading=!1,m(e,i));else if(\"string\"==typeof t||i.objectMode||Object.getPrototypeOf(t)===P.prototype||(t=a(t)),r)i.endEmitted?X(e,new K):c(e,i,t,!0);else if(i.ended)X(e,new z);else{if(i.destroyed)return!1;i.reading=!1,i.decoder&&!n?(t=i.decoder.write(t),i.objectMode||0!==t.length?c(e,i,t,!1):m(e,i)):c(e,i,t,!1)}}return!i.ended&&(i.length<i.highWaterMark||0===i.length)}function c(e,t,n,r){t.flowing&&0===t.length&&!t.sync?(t.awaitDrain=0,e.emit(\"data\",n)):(t.length+=t.objectMode?1:n.length,r?t.buffer.unshift(n):t.buffer.push(n),t.needReadable&&_(e)),m(e,t)}function u(e,t){var n;return o(t)||\"string\"==typeof t||void 0===t||e.objectMode||(n=new V(\"chunk\",[\"string\",\"Buffer\",\"Uint8Array\"],t)),n}function p(e){return 1073741824<=e?e=1073741824:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}function f(e,t){return 0>=e||0===t.length&&t.ended?0:t.objectMode?1:e===e?(e>t.highWaterMark&&(t.highWaterMark=p(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0)):t.flowing&&t.length?t.buffer.head.data.length:t.length}function g(e,t){if(x(\"onEofChunk\"),!t.ended){if(t.decoder){var n=t.decoder.end();n&&n.length&&(t.buffer.push(n),t.length+=t.objectMode?1:n.length)}t.ended=!0,t.sync?_(e):(t.needReadable=!1,!t.emittedReadable&&(t.emittedReadable=!0,h(e)))}}function _(e){var t=e._readableState;x(\"emitReadable\",t.needReadable,t.emittedReadable),t.needReadable=!1,t.emittedReadable||(x(\"emitReadable\",t.flowing),t.emittedReadable=!0,n.nextTick(h,e))}function h(e){var t=e._readableState;x(\"emitReadable_\",t.destroyed,t.length,t.ended),!t.destroyed&&(t.length||t.ended)&&(e.emit(\"readable\"),t.emittedReadable=!1),t.needReadable=!t.flowing&&!t.ended&&t.length<=t.highWaterMark,S(e)}function m(e,t){t.readingMore||(t.readingMore=!0,n.nextTick(b,e,t))}function b(e,t){for(;!t.reading&&!t.ended&&(t.length<t.highWaterMark||t.flowing&&0===t.length);){var n=t.length;if(x(\"maybeReadMore read 0\"),e.read(0),n===t.length)break}t.readingMore=!1}function y(e){return function(){var t=e._readableState;x(\"pipeOnDrain\",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&D(e,\"data\")&&(t.flowing=!0,S(e))}}function C(e){var t=e._readableState;t.readableListening=0<e.listenerCount(\"readable\"),t.resumeScheduled&&!t.paused?t.flowing=!0:0<e.listenerCount(\"data\")&&e.resume()}function R(e){x(\"readable nexttick read 0\"),e.read(0)}function E(e,t){t.resumeScheduled||(t.resumeScheduled=!0,n.nextTick(w,e,t))}function w(e,t){x(\"resume\",t.reading),t.reading||e.read(0),t.resumeScheduled=!1,e.emit(\"resume\"),S(e),t.flowing&&!t.reading&&e.read(0)}function S(e){var t=e._readableState;for(x(\"flow\",t.flowing);t.flowing&&null!==e.read(););}function T(e,t){if(0===t.length)return null;var n;return t.objectMode?n=t.buffer.shift():!e||e>=t.length?(n=t.decoder?t.buffer.join(\"\"):1===t.buffer.length?t.buffer.first():t.buffer.concat(t.length),t.buffer.clear()):n=t.buffer.consume(e,t.decoder),n}function v(e){var t=e._readableState;x(\"endReadable\",t.endEmitted),t.endEmitted||(t.ended=!0,n.nextTick(k,t,e))}function k(e,t){if(x(\"endReadableNT\",e.endEmitted,e.length),!e.endEmitted&&0===e.length&&(e.endEmitted=!0,t.readable=!1,t.emit(\"end\"),e.autoDestroy)){var n=t._writableState;(!n||n.autoDestroy&&n.finished)&&t.destroy()}}function L(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1}t.exports=s;var A;s.ReadableState=d;var x,N=e(\"events\").EventEmitter,D=function(e,t){return e.listeners(t).length},I=e(\"./internal/streams/stream\"),P=e(\"buffer\").Buffer,M=r.Uint8Array||function(){},O=e(\"util\");x=O&&O.debuglog?O.debuglog(\"stream\"):function(){};var F,B,U,j=e(\"./internal/streams/buffer_list\"),q=e(\"./internal/streams/destroy\"),W=e(\"./internal/streams/state\"),H=W.getHighWaterMark,Y=e(\"../errors\").codes,V=Y.ERR_INVALID_ARG_TYPE,z=Y.ERR_STREAM_PUSH_AFTER_EOF,G=Y.ERR_METHOD_NOT_IMPLEMENTED,K=Y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;e(\"inherits\")(s,I);var X=q.errorOrDestroy,$=[\"error\",\"close\",\"destroy\",\"pause\",\"resume\"];Object.defineProperty(s.prototype,\"destroyed\",{enumerable:!1,get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(e){this._readableState&&(this._readableState.destroyed=e)}}),s.prototype.destroy=q.destroy,s.prototype._undestroy=q.undestroy,s.prototype._destroy=function(e,t){t(e)},s.prototype.push=function(e,t){var n,r=this._readableState;return r.objectMode?n=!0:\"string\"==typeof e&&(t=t||r.defaultEncoding,t!==r.encoding&&(e=P.from(e,t),t=\"\"),n=!0),l(this,e,t,!1,n)},s.prototype.unshift=function(e){return l(this,e,null,!0,!1)},s.prototype.isPaused=function(){return!1===this._readableState.flowing},s.prototype.setEncoding=function(t){F||(F=e(\"string_decoder/\").StringDecoder);var n=new F(t);this._readableState.decoder=n,this._readableState.encoding=this._readableState.decoder.encoding;for(var r=this._readableState.buffer.head,a=\"\";null!==r;)a+=n.write(r.data),r=r.next;return this._readableState.buffer.clear(),\"\"!==a&&this._readableState.buffer.push(a),this._readableState.length=a.length,this};s.prototype.read=function(e){x(\"read\",e),e=parseInt(e,10);var t=this._readableState,r=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&((0===t.highWaterMark?0<t.length:t.length>=t.highWaterMark)||t.ended))return x(\"read: emitReadable\",t.length,t.ended),0===t.length&&t.ended?v(this):_(this),null;if(e=f(e,t),0===e&&t.ended)return 0===t.length&&v(this),null;var a=t.needReadable;x(\"need readable\",a),(0===t.length||t.length-e<t.highWaterMark)&&(a=!0,x(\"length less than watermark\",a)),t.ended||t.reading?(a=!1,x(\"reading or ended\",a)):a&&(x(\"do read\"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,!t.reading&&(e=f(r,t)));var o;return o=0<e?T(e,t):null,null===o?(t.needReadable=t.length<=t.highWaterMark,e=0):(t.length-=e,t.awaitDrain=0),0===t.length&&(!t.ended&&(t.needReadable=!0),r!==e&&t.ended&&v(this)),null!==o&&this.emit(\"data\",o),o},s.prototype._read=function(){X(this,new G(\"_read()\"))},s.prototype.pipe=function(e,t){function r(e,t){x(\"onunpipe\"),e===p&&t&&!1===t.hasUnpiped&&(t.hasUnpiped=!0,o())}function a(){x(\"onend\"),e.end()}function o(){x(\"cleanup\"),e.removeListener(\"close\",l),e.removeListener(\"finish\",c),e.removeListener(\"drain\",h),e.removeListener(\"error\",s),e.removeListener(\"unpipe\",r),p.removeListener(\"end\",a),p.removeListener(\"end\",u),p.removeListener(\"data\",d),m=!0,f.awaitDrain&&(!e._writableState||e._writableState.needDrain)&&h()}function d(t){x(\"ondata\");var n=e.write(t);x(\"dest.write\",n),!1===n&&((1===f.pipesCount&&f.pipes===e||1<f.pipesCount&&-1!==L(f.pipes,e))&&!m&&(x(\"false write response, pause\",f.awaitDrain),f.awaitDrain++),p.pause())}function s(t){x(\"onerror\",t),u(),e.removeListener(\"error\",s),0===D(e,\"error\")&&X(e,t)}function l(){e.removeListener(\"finish\",c),u()}function c(){x(\"onfinish\"),e.removeListener(\"close\",l),u()}function u(){x(\"unpipe\"),p.unpipe(e)}var p=this,f=this._readableState;switch(f.pipesCount){case 0:f.pipes=e;break;case 1:f.pipes=[f.pipes,e];break;default:f.pipes.push(e);}f.pipesCount+=1,x(\"pipe count=%d opts=%j\",f.pipesCount,t);var g=(!t||!1!==t.end)&&e!==n.stdout&&e!==n.stderr,_=g?a:u;f.endEmitted?n.nextTick(_):p.once(\"end\",_),e.on(\"unpipe\",r);var h=y(p);e.on(\"drain\",h);var m=!1;return p.on(\"data\",d),i(e,\"error\",s),e.once(\"close\",l),e.once(\"finish\",c),e.emit(\"pipe\",p),f.flowing||(x(\"pipe resume\"),p.resume()),e},s.prototype.unpipe=function(e){var t=this._readableState,n={hasUnpiped:!1};if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes?this:(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit(\"unpipe\",this,n),this);if(!e){var r=t.pipes,a=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var o=0;o<a;o++)r[o].emit(\"unpipe\",this,{hasUnpiped:!1});return this}var d=L(t.pipes,e);return-1===d?this:(t.pipes.splice(d,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit(\"unpipe\",this,n),this)},s.prototype.on=function(e,t){var r=I.prototype.on.call(this,e,t),a=this._readableState;return\"data\"===e?(a.readableListening=0<this.listenerCount(\"readable\"),!1!==a.flowing&&this.resume()):\"readable\"==e&&!a.endEmitted&&!a.readableListening&&(a.readableListening=a.needReadable=!0,a.flowing=!1,a.emittedReadable=!1,x(\"on readable\",a.length,a.reading),a.length?_(this):!a.reading&&n.nextTick(R,this)),r},s.prototype.addListener=s.prototype.on,s.prototype.removeListener=function(e,t){var r=I.prototype.removeListener.call(this,e,t);return\"readable\"===e&&n.nextTick(C,this),r},s.prototype.removeAllListeners=function(e){var t=I.prototype.removeAllListeners.apply(this,arguments);return(\"readable\"===e||void 0===e)&&n.nextTick(C,this),t},s.prototype.resume=function(){var e=this._readableState;return e.flowing||(x(\"resume\"),e.flowing=!e.readableListening,E(this,e)),e.paused=!1,this},s.prototype.pause=function(){return x(\"call pause flowing=%j\",this._readableState.flowing),!1!==this._readableState.flowing&&(x(\"pause\"),this._readableState.flowing=!1,this.emit(\"pause\")),this._readableState.paused=!0,this},s.prototype.wrap=function(e){var t=this,r=this._readableState,a=!1;for(var o in e.on(\"end\",function(){if(x(\"wrapped end\"),r.decoder&&!r.ended){var e=r.decoder.end();e&&e.length&&t.push(e)}t.push(null)}),e.on(\"data\",function(n){if((x(\"wrapped data\"),r.decoder&&(n=r.decoder.write(n)),!(r.objectMode&&(null===n||void 0===n)))&&(r.objectMode||n&&n.length)){var o=t.push(n);o||(a=!0,e.pause())}}),e)void 0===this[o]&&\"function\"==typeof e[o]&&(this[o]=function(t){return function(){return e[t].apply(e,arguments)}}(o));for(var i=0;i<$.length;i++)e.on($[i],this.emit.bind(this,$[i]));return this._read=function(t){x(\"wrapped _read\",t),a&&(a=!1,e.resume())},this},\"function\"==typeof Symbol&&(s.prototype[Symbol.asyncIterator]=function(){return void 0===B&&(B=e(\"./internal/streams/async_iterator\")),B(this)}),Object.defineProperty(s.prototype,\"readableHighWaterMark\",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),Object.defineProperty(s.prototype,\"readableBuffer\",{enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}}),Object.defineProperty(s.prototype,\"readableFlowing\",{enumerable:!1,get:function(){return this._readableState.flowing},set:function(e){this._readableState&&(this._readableState.flowing=e)}}),s._fromList=T,Object.defineProperty(s.prototype,\"readableLength\",{enumerable:!1,get:function(){return this._readableState.length}}),\"function\"==typeof Symbol&&(s.from=function(t,n){return void 0===U&&(U=e(\"./internal/streams/from\")),U(s,t,n)})}).call(this)}).call(this,e(\"_process\"),\"undefined\"==typeof global?\"undefined\"==typeof self?\"undefined\"==typeof window?{}:window:self:global)},{\"../errors\":15,\"./_stream_duplex\":16,\"./internal/streams/async_iterator\":21,\"./internal/streams/buffer_list\":22,\"./internal/streams/destroy\":23,\"./internal/streams/from\":25,\"./internal/streams/state\":27,\"./internal/streams/stream\":28,_process:12,buffer:3,events:7,inherits:10,\"string_decoder/\":31,util:2}],19:[function(e,t){'use strict';function n(e,t){var n=this._transformState;n.transforming=!1;var r=n.writecb;if(null===r)return this.emit(\"error\",new s);n.writechunk=null,n.writecb=null,null!=t&&this.push(t),r(e);var a=this._readableState;a.reading=!1,(a.needReadable||a.length<a.highWaterMark)&&this._read(a.highWaterMark)}function r(e){return this instanceof r?void(u.call(this,e),this._transformState={afterTransform:n.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,e&&(\"function\"==typeof e.transform&&(this._transform=e.transform),\"function\"==typeof e.flush&&(this._flush=e.flush)),this.on(\"prefinish\",a)):new r(e)}function a(){var e=this;\"function\"!=typeof this._flush||this._readableState.destroyed?o(this,null,null):this._flush(function(t,n){o(e,t,n)})}function o(e,t,n){if(t)return e.emit(\"error\",t);if(null!=n&&e.push(n),e._writableState.length)throw new c;if(e._transformState.transforming)throw new l;return e.push(null)}t.exports=r;var i=e(\"../errors\").codes,d=i.ERR_METHOD_NOT_IMPLEMENTED,s=i.ERR_MULTIPLE_CALLBACK,l=i.ERR_TRANSFORM_ALREADY_TRANSFORMING,c=i.ERR_TRANSFORM_WITH_LENGTH_0,u=e(\"./_stream_duplex\");e(\"inherits\")(r,u),r.prototype.push=function(e,t){return this._transformState.needTransform=!1,u.prototype.push.call(this,e,t)},r.prototype._transform=function(e,t,n){n(new d(\"_transform()\"))},r.prototype._write=function(e,t,n){var r=this._transformState;if(r.writecb=n,r.writechunk=e,r.writeencoding=t,!r.transforming){var a=this._readableState;(r.needTransform||a.needReadable||a.length<a.highWaterMark)&&this._read(a.highWaterMark)}},r.prototype._read=function(){var e=this._transformState;null===e.writechunk||e.transforming?e.needTransform=!0:(e.transforming=!0,this._transform(e.writechunk,e.writeencoding,e.afterTransform))},r.prototype._destroy=function(e,t){u.prototype._destroy.call(this,e,function(e){t(e)})}},{\"../errors\":15,\"./_stream_duplex\":16,inherits:10}],20:[function(e,t){(function(n,r){(function(){'use strict';function a(e){var t=this;this.next=null,this.entry=null,this.finish=function(){v(t,e)}}function o(e){return x.from(e)}function i(e){return x.isBuffer(e)||e instanceof N}function d(){}function s(t,n,r){k=k||e(\"./_stream_duplex\"),t=t||{},\"boolean\"!=typeof r&&(r=n instanceof k),this.objectMode=!!t.objectMode,r&&(this.objectMode=this.objectMode||!!t.writableObjectMode),this.highWaterMark=P(this,t,\"writableHighWaterMark\",r),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var o=!1===t.decodeStrings;this.decodeStrings=!o,this.defaultEncoding=t.defaultEncoding||\"utf8\",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){m(n,e)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!1!==t.emitClose,this.autoDestroy=!!t.autoDestroy,this.bufferedRequestCount=0,this.corkedRequestsFree=new a(this)}function l(t){k=k||e(\"./_stream_duplex\");var n=this instanceof k;return n||V.call(l,this)?void(this._writableState=new s(t,this,n),this.writable=!0,t&&(\"function\"==typeof t.write&&(this._write=t.write),\"function\"==typeof t.writev&&(this._writev=t.writev),\"function\"==typeof t.destroy&&(this._destroy=t.destroy),\"function\"==typeof t.final&&(this._final=t.final)),A.call(this)):new l(t)}function c(e,t){var r=new W;Y(e,r),n.nextTick(t,r)}function u(e,t,r,a){var o;return null===r?o=new q:\"string\"!=typeof r&&!t.objectMode&&(o=new O(\"chunk\",[\"string\",\"Buffer\"],r)),!o||(Y(e,o),n.nextTick(a,o),!1)}function p(e,t,n){return e.objectMode||!1===e.decodeStrings||\"string\"!=typeof t||(t=x.from(t,n)),t}function f(e,t,n,r,a,o){if(!n){var i=p(t,r,a);r!==i&&(n=!0,a=\"buffer\",r=i)}var d=t.objectMode?1:r.length;t.length+=d;var s=t.length<t.highWaterMark;if(s||(t.needDrain=!0),t.writing||t.corked){var l=t.lastBufferedRequest;t.lastBufferedRequest={chunk:r,encoding:a,isBuf:n,callback:o,next:null},l?l.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1}else g(e,t,!1,d,r,a,o);return s}function g(e,t,n,r,a,o,i){t.writelen=r,t.writecb=i,t.writing=!0,t.sync=!0,t.destroyed?t.onwrite(new j(\"write\")):n?e._writev(a,t.onwrite):e._write(a,o,t.onwrite),t.sync=!1}function _(e,t,r,a,o){--t.pendingcb,r?(n.nextTick(o,a),n.nextTick(S,e,t),e._writableState.errorEmitted=!0,Y(e,a)):(o(a),e._writableState.errorEmitted=!0,Y(e,a),S(e,t))}function h(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}function m(e,t){var r=e._writableState,a=r.sync,o=r.writecb;if(\"function\"!=typeof o)throw new B;if(h(r),t)_(e,r,a,t,o);else{var i=R(r)||e.destroyed;i||r.corked||r.bufferProcessing||!r.bufferedRequest||C(e,r),a?n.nextTick(b,e,r,i,o):b(e,r,i,o)}}function b(e,t,n,r){n||y(e,t),t.pendingcb--,r(),S(e,t)}function y(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit(\"drain\"))}function C(e,t){t.bufferProcessing=!0;var n=t.bufferedRequest;if(e._writev&&n&&n.next){var r=t.bufferedRequestCount,o=Array(r),i=t.corkedRequestsFree;i.entry=n;for(var d=0,s=!0;n;)o[d]=n,n.isBuf||(s=!1),n=n.next,d+=1;o.allBuffers=s,g(e,t,!0,t.length,o,\"\",i.finish),t.pendingcb++,t.lastBufferedRequest=null,i.next?(t.corkedRequestsFree=i.next,i.next=null):t.corkedRequestsFree=new a(t),t.bufferedRequestCount=0}else{for(;n;){var l=n.chunk,c=n.encoding,u=n.callback,p=t.objectMode?1:l.length;if(g(e,t,!1,p,l,c,u),n=n.next,t.bufferedRequestCount--,t.writing)break}null===n&&(t.lastBufferedRequest=null)}t.bufferedRequest=n,t.bufferProcessing=!1}function R(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function E(e,t){e._final(function(n){t.pendingcb--,n&&Y(e,n),t.prefinished=!0,e.emit(\"prefinish\"),S(e,t)})}function w(e,t){t.prefinished||t.finalCalled||(\"function\"!=typeof e._final||t.destroyed?(t.prefinished=!0,e.emit(\"prefinish\")):(t.pendingcb++,t.finalCalled=!0,n.nextTick(E,e,t)))}function S(e,t){var n=R(t);if(n&&(w(e,t),0===t.pendingcb&&(t.finished=!0,e.emit(\"finish\"),t.autoDestroy))){var r=e._readableState;(!r||r.autoDestroy&&r.endEmitted)&&e.destroy()}return n}function T(e,t,r){t.ending=!0,S(e,t),r&&(t.finished?n.nextTick(r):e.once(\"finish\",r)),t.ended=!0,e.writable=!1}function v(e,t,n){var r=e.entry;for(e.entry=null;r;){var a=r.callback;t.pendingcb--,a(n),r=r.next}t.corkedRequestsFree.next=e}t.exports=l;var k;l.WritableState=s;var L={deprecate:e(\"util-deprecate\")},A=e(\"./internal/streams/stream\"),x=e(\"buffer\").Buffer,N=r.Uint8Array||function(){},D=e(\"./internal/streams/destroy\"),I=e(\"./internal/streams/state\"),P=I.getHighWaterMark,M=e(\"../errors\").codes,O=M.ERR_INVALID_ARG_TYPE,F=M.ERR_METHOD_NOT_IMPLEMENTED,B=M.ERR_MULTIPLE_CALLBACK,U=M.ERR_STREAM_CANNOT_PIPE,j=M.ERR_STREAM_DESTROYED,q=M.ERR_STREAM_NULL_VALUES,W=M.ERR_STREAM_WRITE_AFTER_END,H=M.ERR_UNKNOWN_ENCODING,Y=D.errorOrDestroy;e(\"inherits\")(l,A),s.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},function(){try{Object.defineProperty(s.prototype,\"buffer\",{get:L.deprecate(function(){return this.getBuffer()},\"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.\",\"DEP0003\")})}catch(e){}}();var V;\"function\"==typeof Symbol&&Symbol.hasInstance&&\"function\"==typeof Function.prototype[Symbol.hasInstance]?(V=Function.prototype[Symbol.hasInstance],Object.defineProperty(l,Symbol.hasInstance,{value:function(e){return!!V.call(this,e)||!(this!==l)&&e&&e._writableState instanceof s}})):V=function(e){return e instanceof this},l.prototype.pipe=function(){Y(this,new U)},l.prototype.write=function(e,t,n){var r=this._writableState,a=!1,s=!r.objectMode&&i(e);return s&&!x.isBuffer(e)&&(e=o(e)),\"function\"==typeof t&&(n=t,t=null),s?t=\"buffer\":!t&&(t=r.defaultEncoding),\"function\"!=typeof n&&(n=d),r.ending?c(this,n):(s||u(this,r,e,n))&&(r.pendingcb++,a=f(this,r,s,e,t,n)),a},l.prototype.cork=function(){this._writableState.corked++},l.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,!e.writing&&!e.corked&&!e.bufferProcessing&&e.bufferedRequest&&C(this,e))},l.prototype.setDefaultEncoding=function(e){if(\"string\"==typeof e&&(e=e.toLowerCase()),!(-1<[\"hex\",\"utf8\",\"utf-8\",\"ascii\",\"binary\",\"base64\",\"ucs2\",\"ucs-2\",\"utf16le\",\"utf-16le\",\"raw\"].indexOf((e+\"\").toLowerCase())))throw new H(e);return this._writableState.defaultEncoding=e,this},Object.defineProperty(l.prototype,\"writableBuffer\",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(l.prototype,\"writableHighWaterMark\",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),l.prototype._write=function(e,t,n){n(new F(\"_write()\"))},l.prototype._writev=null,l.prototype.end=function(e,t,n){var r=this._writableState;return\"function\"==typeof e?(n=e,e=null,t=null):\"function\"==typeof t&&(n=t,t=null),null!==e&&void 0!==e&&this.write(e,t),r.corked&&(r.corked=1,this.uncork()),r.ending||T(this,r,n),this},Object.defineProperty(l.prototype,\"writableLength\",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(l.prototype,\"destroyed\",{enumerable:!1,get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(e){this._writableState&&(this._writableState.destroyed=e)}}),l.prototype.destroy=D.destroy,l.prototype._undestroy=D.undestroy,l.prototype._destroy=function(e,t){t(e)}}).call(this)}).call(this,e(\"_process\"),\"undefined\"==typeof global?\"undefined\"==typeof self?\"undefined\"==typeof window?{}:window:self:global)},{\"../errors\":15,\"./_stream_duplex\":16,\"./internal/streams/destroy\":23,\"./internal/streams/state\":27,\"./internal/streams/stream\":28,_process:12,buffer:3,inherits:10,\"util-deprecate\":32}],21:[function(e,t){(function(n){(function(){'use strict';function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){return{value:e,done:t}}function o(e){var t=e[c];if(null!==t){var n=e[h].read();null!==n&&(e[g]=null,e[c]=null,e[u]=null,t(a(n,!1)))}}function i(e){n.nextTick(o,e)}function d(e,t){return function(n,r){e.then(function(){return t[f]?void n(a(void 0,!0)):void t[_](n,r)},r)}}var s,l=e(\"./end-of-stream\"),c=Symbol(\"lastResolve\"),u=Symbol(\"lastReject\"),p=Symbol(\"error\"),f=Symbol(\"ended\"),g=Symbol(\"lastPromise\"),_=Symbol(\"handlePromise\"),h=Symbol(\"stream\"),m=Object.getPrototypeOf(function(){}),b=Object.setPrototypeOf((s={get stream(){return this[h]},next:function(){var e=this,t=this[p];if(null!==t)return Promise.reject(t);if(this[f])return Promise.resolve(a(void 0,!0));if(this[h].destroyed)return new Promise(function(t,r){n.nextTick(function(){e[p]?r(e[p]):t(a(void 0,!0))})});var r,o=this[g];if(o)r=new Promise(d(o,this));else{var i=this[h].read();if(null!==i)return Promise.resolve(a(i,!1));r=new Promise(this[_])}return this[g]=r,r}},r(s,Symbol.asyncIterator,function(){return this}),r(s,\"return\",function(){var e=this;return new Promise(function(t,n){e[h].destroy(null,function(e){return e?void n(e):void t(a(void 0,!0))})})}),s),m);t.exports=function(e){var t,n=Object.create(b,(t={},r(t,h,{value:e,writable:!0}),r(t,c,{value:null,writable:!0}),r(t,u,{value:null,writable:!0}),r(t,p,{value:null,writable:!0}),r(t,f,{value:e._readableState.endEmitted,writable:!0}),r(t,_,{value:function(e,t){var r=n[h].read();r?(n[g]=null,n[c]=null,n[u]=null,e(a(r,!1))):(n[c]=e,n[u]=t)},writable:!0}),t));return n[g]=null,l(e,function(e){if(e&&\"ERR_STREAM_PREMATURE_CLOSE\"!==e.code){var t=n[u];return null!==t&&(n[g]=null,n[c]=null,n[u]=null,t(e)),void(n[p]=e)}var r=n[c];null!==r&&(n[g]=null,n[c]=null,n[u]=null,r(a(void 0,!0))),n[f]=!0}),e.on(\"readable\",i.bind(null,n)),n}}).call(this)}).call(this,e(\"_process\"))},{\"./end-of-stream\":24,_process:12}],22:[function(e,t){'use strict';function n(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function r(e){for(var t,r=1;r<arguments.length;r++)t=null==arguments[r]?{}:arguments[r],r%2?n(Object(t),!0).forEach(function(n){a(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):n(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))});return e}function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function i(e,t){for(var n,r=0;r<t.length;r++)n=t[r],n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}function d(e,t,n){return t&&i(e.prototype,t),n&&i(e,n),e}function s(e,t,n){u.prototype.copy.call(e,t,n)}var l=e(\"buffer\"),u=l.Buffer,p=e(\"util\"),f=p.inspect,g=f&&f.custom||\"inspect\";t.exports=function(){function e(){o(this,e),this.head=null,this.tail=null,this.length=0}return d(e,[{key:\"push\",value:function(e){var t={data:e,next:null};0<this.length?this.tail.next=t:this.head=t,this.tail=t,++this.length}},{key:\"unshift\",value:function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length}},{key:\"shift\",value:function(){if(0!==this.length){var e=this.head.data;return this.head=1===this.length?this.tail=null:this.head.next,--this.length,e}}},{key:\"clear\",value:function(){this.head=this.tail=null,this.length=0}},{key:\"join\",value:function(e){if(0===this.length)return\"\";for(var t=this.head,n=\"\"+t.data;t=t.next;)n+=e+t.data;return n}},{key:\"concat\",value:function(e){if(0===this.length)return u.alloc(0);for(var t=u.allocUnsafe(e>>>0),n=this.head,r=0;n;)s(n.data,t,r),r+=n.data.length,n=n.next;return t}},{key:\"consume\",value:function(e,t){var n;return e<this.head.data.length?(n=this.head.data.slice(0,e),this.head.data=this.head.data.slice(e)):e===this.head.data.length?n=this.shift():n=t?this._getString(e):this._getBuffer(e),n}},{key:\"first\",value:function(){return this.head.data}},{key:\"_getString\",value:function(e){var t=this.head,r=1,a=t.data;for(e-=a.length;t=t.next;){var o=t.data,i=e>o.length?o.length:e;if(a+=i===o.length?o:o.slice(0,e),e-=i,0===e){i===o.length?(++r,this.head=t.next?t.next:this.tail=null):(this.head=t,t.data=o.slice(i));break}++r}return this.length-=r,a}},{key:\"_getBuffer\",value:function(e){var t=u.allocUnsafe(e),r=this.head,a=1;for(r.data.copy(t),e-=r.data.length;r=r.next;){var o=r.data,i=e>o.length?o.length:e;if(o.copy(t,t.length-e,0,i),e-=i,0===e){i===o.length?(++a,this.head=r.next?r.next:this.tail=null):(this.head=r,r.data=o.slice(i));break}++a}return this.length-=a,t}},{key:g,value:function(e,t){return f(this,r({},t,{depth:0,customInspect:!1}))}}]),e}()},{buffer:3,util:2}],23:[function(e,t){(function(e){(function(){'use strict';function n(e,t){a(e,t),r(e)}function r(e){e._writableState&&!e._writableState.emitClose||e._readableState&&!e._readableState.emitClose||e.emit(\"close\")}function a(e,t){e.emit(\"error\",t)}t.exports={destroy:function(t,o){var i=this,d=this._readableState&&this._readableState.destroyed,s=this._writableState&&this._writableState.destroyed;return d||s?(o?o(t):t&&(this._writableState?!this._writableState.errorEmitted&&(this._writableState.errorEmitted=!0,e.nextTick(a,this,t)):e.nextTick(a,this,t)),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(t||null,function(t){!o&&t?i._writableState?i._writableState.errorEmitted?e.nextTick(r,i):(i._writableState.errorEmitted=!0,e.nextTick(n,i,t)):e.nextTick(n,i,t):o?(e.nextTick(r,i),o(t)):e.nextTick(r,i)}),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finalCalled=!1,this._writableState.prefinished=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)},errorOrDestroy:function(e,t){var n=e._readableState,r=e._writableState;n&&n.autoDestroy||r&&r.autoDestroy?e.destroy(t):e.emit(\"error\",t)}}}).call(this)}).call(this,e(\"_process\"))},{_process:12}],24:[function(e,t){'use strict';function n(e){var t=!1;return function(){if(!t){t=!0;for(var n=arguments.length,r=Array(n),a=0;a<n;a++)r[a]=arguments[a];e.apply(this,r)}}}function r(){}function a(e){return e.setHeader&&\"function\"==typeof e.abort}function o(e,t,d){if(\"function\"==typeof t)return o(e,null,t);t||(t={}),d=n(d||r);var s=t.readable||!1!==t.readable&&e.readable,l=t.writable||!1!==t.writable&&e.writable,c=function(){e.writable||p()},u=e._writableState&&e._writableState.finished,p=function(){l=!1,u=!0,s||d.call(e)},f=e._readableState&&e._readableState.endEmitted,g=function(){s=!1,f=!0,l||d.call(e)},_=function(t){d.call(e,t)},h=function(){var t;return s&&!f?(e._readableState&&e._readableState.ended||(t=new i),d.call(e,t)):l&&!u?(e._writableState&&e._writableState.ended||(t=new i),d.call(e,t)):void 0},m=function(){e.req.on(\"finish\",p)};return a(e)?(e.on(\"complete\",p),e.on(\"abort\",h),e.req?m():e.on(\"request\",m)):l&&!e._writableState&&(e.on(\"end\",c),e.on(\"close\",c)),e.on(\"end\",g),e.on(\"finish\",p),!1!==t.error&&e.on(\"error\",_),e.on(\"close\",h),function(){e.removeListener(\"complete\",p),e.removeListener(\"abort\",h),e.removeListener(\"request\",m),e.req&&e.req.removeListener(\"finish\",p),e.removeListener(\"end\",c),e.removeListener(\"close\",c),e.removeListener(\"finish\",p),e.removeListener(\"end\",g),e.removeListener(\"error\",_),e.removeListener(\"close\",h)}}var i=e(\"../../../errors\").codes.ERR_STREAM_PREMATURE_CLOSE;t.exports=o},{\"../../../errors\":15}],25:[function(e,t){t.exports=function(){throw new Error(\"Readable.from is not available in the browser\")}},{}],26:[function(e,t){'use strict';function n(e){var t=!1;return function(){t||(t=!0,e.apply(void 0,arguments))}}function r(e){if(e)throw e}function a(e){return e.setHeader&&\"function\"==typeof e.abort}function o(t,r,o,i){i=n(i);var d=!1;t.on(\"close\",function(){d=!0}),l===void 0&&(l=e(\"./end-of-stream\")),l(t,{readable:r,writable:o},function(e){return e?i(e):void(d=!0,i())});var s=!1;return function(e){if(!d)return s?void 0:(s=!0,a(t)?t.abort():\"function\"==typeof t.destroy?t.destroy():void i(e||new p(\"pipe\")))}}function i(e){e()}function d(e,t){return e.pipe(t)}function s(e){return e.length?\"function\"==typeof e[e.length-1]?e.pop():r:r}var l,c=e(\"../../../errors\").codes,u=c.ERR_MISSING_ARGS,p=c.ERR_STREAM_DESTROYED;t.exports=function(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=s(t);if(Array.isArray(t[0])&&(t=t[0]),2>t.length)throw new u(\"streams\");var a,l=t.map(function(e,n){var d=n<t.length-1;return o(e,d,0<n,function(e){a||(a=e),e&&l.forEach(i),d||(l.forEach(i),r(a))})});return t.reduce(d)}},{\"../../../errors\":15,\"./end-of-stream\":24}],27:[function(e,n){'use strict';function r(e,t,n){return null==e.highWaterMark?t?e[n]:null:e.highWaterMark}var a=e(\"../../../errors\").codes.ERR_INVALID_OPT_VALUE;n.exports={getHighWaterMark:function(e,n,o,i){var d=r(n,i,o);if(null!=d){if(!(isFinite(d)&&t(d)===d)||0>d){var s=i?o:\"highWaterMark\";throw new a(s,d)}return t(d)}return e.objectMode?16:16384}}},{\"../../../errors\":15}],28:[function(e,t){t.exports=e(\"events\").EventEmitter},{events:7}],29:[function(e,t,n){n=t.exports=e(\"./lib/_stream_readable.js\"),n.Stream=n,n.Readable=n,n.Writable=e(\"./lib/_stream_writable.js\"),n.Duplex=e(\"./lib/_stream_duplex.js\"),n.Transform=e(\"./lib/_stream_transform.js\"),n.PassThrough=e(\"./lib/_stream_passthrough.js\"),n.finished=e(\"./lib/internal/streams/end-of-stream.js\"),n.pipeline=e(\"./lib/internal/streams/pipeline.js\")},{\"./lib/_stream_duplex.js\":16,\"./lib/_stream_passthrough.js\":17,\"./lib/_stream_readable.js\":18,\"./lib/_stream_transform.js\":19,\"./lib/_stream_writable.js\":20,\"./lib/internal/streams/end-of-stream.js\":24,\"./lib/internal/streams/pipeline.js\":26}],30:[function(e,t,n){function r(e,t){for(var n in e)t[n]=e[n]}function a(e,t,n){return i(e,t,n)}/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var o=e(\"buffer\"),i=o.Buffer;i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?t.exports=o:(r(o,n),n.Buffer=a),a.prototype=Object.create(i.prototype),r(i,a),a.from=function(e,t,n){if(\"number\"==typeof e)throw new TypeError(\"Argument must not be a number\");return i(e,t,n)},a.alloc=function(e,t,n){if(\"number\"!=typeof e)throw new TypeError(\"Argument must be a number\");var r=i(e);return void 0===t?r.fill(0):\"string\"==typeof n?r.fill(t,n):r.fill(t),r},a.allocUnsafe=function(e){if(\"number\"!=typeof e)throw new TypeError(\"Argument must be a number\");return i(e)},a.allocUnsafeSlow=function(e){if(\"number\"!=typeof e)throw new TypeError(\"Argument must be a number\");return o.SlowBuffer(e)}},{buffer:3}],31:[function(e,t,n){'use strict';function r(e){if(!e)return\"utf8\";for(var t;;)switch(e){case\"utf8\":case\"utf-8\":return\"utf8\";case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return\"utf16le\";case\"latin1\":case\"binary\":return\"latin1\";case\"base64\":case\"ascii\":case\"hex\":return e;default:if(t)return;e=(\"\"+e).toLowerCase(),t=!0;}}function a(e){var t=r(e);if(\"string\"!=typeof t&&(m.isEncoding===b||!b(e)))throw new Error(\"Unknown encoding: \"+e);return t||e}function o(e){this.encoding=a(e);var t;switch(this.encoding){case\"utf16le\":this.text=u,this.end=p,t=4;break;case\"utf8\":this.fillLast=c,t=4;break;case\"base64\":this.text=f,this.end=g,t=3;break;default:return this.write=_,void(this.end=h);}this.lastNeed=0,this.lastTotal=0,this.lastChar=m.allocUnsafe(t)}function d(e){if(127>=e)return 0;return 6==e>>5?2:14==e>>4?3:30==e>>3?4:2==e>>6?-1:-2}function s(e,t,n){var r=t.length-1;if(r<n)return 0;var a=d(t[r]);return 0<=a?(0<a&&(e.lastNeed=a-1),a):--r<n||-2===a?0:(a=d(t[r]),0<=a)?(0<a&&(e.lastNeed=a-2),a):--r<n||-2===a?0:(a=d(t[r]),0<=a?(0<a&&(2===a?a=0:e.lastNeed=a-3),a):0)}function l(e,t){if(128!=(192&t[0]))return e.lastNeed=0,\"\\uFFFD\";if(1<e.lastNeed&&1<t.length){if(128!=(192&t[1]))return e.lastNeed=1,\"\\uFFFD\";if(2<e.lastNeed&&2<t.length&&128!=(192&t[2]))return e.lastNeed=2,\"\\uFFFD\"}}function c(e){var t=this.lastTotal-this.lastNeed,n=l(this,e,t);return void 0===n?this.lastNeed<=e.length?(e.copy(this.lastChar,t,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):void(e.copy(this.lastChar,t,0,e.length),this.lastNeed-=e.length):n}function u(e,t){if(0==(e.length-t)%2){var n=e.toString(\"utf16le\",t);if(n){var r=n.charCodeAt(n.length-1);if(55296<=r&&56319>=r)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1],n.slice(0,-1)}return n}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=e[e.length-1],e.toString(\"utf16le\",t,e.length-1)}function p(e){var t=e&&e.length?this.write(e):\"\";if(this.lastNeed){var n=this.lastTotal-this.lastNeed;return t+this.lastChar.toString(\"utf16le\",0,n)}return t}function f(e,t){var r=(e.length-t)%3;return 0==r?e.toString(\"base64\",t):(this.lastNeed=3-r,this.lastTotal=3,1==r?this.lastChar[0]=e[e.length-1]:(this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1]),e.toString(\"base64\",t,e.length-r))}function g(e){var t=e&&e.length?this.write(e):\"\";return this.lastNeed?t+this.lastChar.toString(\"base64\",0,3-this.lastNeed):t}function _(e){return e.toString(this.encoding)}function h(e){return e&&e.length?this.write(e):\"\"}var m=e(\"safe-buffer\").Buffer,b=m.isEncoding||function(e){switch(e=\"\"+e,e&&e.toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":case\"raw\":return!0;default:return!1;}};n.StringDecoder=o,o.prototype.write=function(e){if(0===e.length)return\"\";var t,n;if(this.lastNeed){if(t=this.fillLast(e),void 0===t)return\"\";n=this.lastNeed,this.lastNeed=0}else n=0;return n<e.length?t?t+this.text(e,n):this.text(e,n):t||\"\"},o.prototype.end=function(e){var t=e&&e.length?this.write(e):\"\";return this.lastNeed?t+\"\\uFFFD\":t},o.prototype.text=function(e,t){var n=s(this,e,t);if(!this.lastNeed)return e.toString(\"utf8\",t);this.lastTotal=n;var r=e.length-(n-this.lastNeed);return e.copy(this.lastChar,0,r),e.toString(\"utf8\",t,r)},o.prototype.fillLast=function(e){return this.lastNeed<=e.length?(e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):void(e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length),this.lastNeed-=e.length)}},{\"safe-buffer\":30}],32:[function(e,t){(function(e){(function(){function n(t){try{if(!e.localStorage)return!1}catch(e){return!1}var n=e.localStorage[t];return null!=n&&\"true\"===(n+\"\").toLowerCase()}t.exports=function(e,t){function r(){if(!a){if(n(\"throwDeprecation\"))throw new Error(t);else n(\"traceDeprecation\")?console.trace(t):console.warn(t);a=!0}return e.apply(this,arguments)}if(n(\"noDeprecation\"))return e;var a=!1;return r}}).call(this)}).call(this,\"undefined\"==typeof global?\"undefined\"==typeof self?\"undefined\"==typeof window?{}:window:self:global)},{}],\"/\":[function(e,t){function n(e){return e.replace(/a=ice-options:trickle\\s\\n/g,\"\")}function r(e){console.warn(e)}/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */const a=e(\"debug\")(\"simple-peer\"),o=e(\"get-browser-rtc\"),i=e(\"randombytes\"),d=e(\"readable-stream\"),s=e(\"queue-microtask\"),l=e(\"err-code\"),{Buffer:c}=e(\"buffer\"),u=65536;class p extends d.Duplex{constructor(e){if(e=Object.assign({allowHalfOpen:!1},e),super(e),this._id=i(4).toString(\"hex\").slice(0,7),this._debug(\"new peer %o\",e),this.channelName=e.initiator?e.channelName||i(20).toString(\"hex\"):null,this.initiator=e.initiator||!1,this.channelConfig=e.channelConfig||p.channelConfig,this.channelNegotiated=this.channelConfig.negotiated,this.config=Object.assign({},p.config,e.config),this.offerOptions=e.offerOptions||{},this.answerOptions=e.answerOptions||{},this.sdpTransform=e.sdpTransform||(e=>e),this.streams=e.streams||(e.stream?[e.stream]:[]),this.trickle=void 0===e.trickle||e.trickle,this.allowHalfTrickle=void 0!==e.allowHalfTrickle&&e.allowHalfTrickle,this.iceCompleteTimeout=e.iceCompleteTimeout||5000,this.destroyed=!1,this.destroying=!1,this._connected=!1,this.remoteAddress=void 0,this.remoteFamily=void 0,this.remotePort=void 0,this.localAddress=void 0,this.localFamily=void 0,this.localPort=void 0,this._wrtc=e.wrtc&&\"object\"==typeof e.wrtc?e.wrtc:o(),!this._wrtc)if(\"undefined\"==typeof window)throw l(new Error(\"No WebRTC support: Specify `opts.wrtc` option in this environment\"),\"ERR_WEBRTC_SUPPORT\");else throw l(new Error(\"No WebRTC support: Not a supported browser\"),\"ERR_WEBRTC_SUPPORT\");this._pcReady=!1,this._channelReady=!1,this._iceComplete=!1,this._iceCompleteTimer=null,this._channel=null,this._pendingCandidates=[],this._isNegotiating=!1,this._firstNegotiation=!0,this._batchedNegotiation=!1,this._queuedNegotiation=!1,this._sendersAwaitingStable=[],this._senderMap=new Map,this._closingInterval=null,this._remoteTracks=[],this._remoteStreams=[],this._chunk=null,this._cb=null,this._interval=null;try{this._pc=new this._wrtc.RTCPeerConnection(this.config)}catch(e){return void this.destroy(l(e,\"ERR_PC_CONSTRUCTOR\"))}this._isReactNativeWebrtc=\"number\"==typeof this._pc._peerConnectionId,this._pc.oniceconnectionstatechange=()=>{this._onIceStateChange()},this._pc.onicegatheringstatechange=()=>{this._onIceStateChange()},this._pc.onconnectionstatechange=()=>{this._onConnectionStateChange()},this._pc.onsignalingstatechange=()=>{this._onSignalingStateChange()},this._pc.onicecandidate=e=>{this._onIceCandidate(e)},\"object\"==typeof this._pc.peerIdentity&&this._pc.peerIdentity.catch(e=>{this.destroy(l(e,\"ERR_PC_PEER_IDENTITY\"))}),this.initiator||this.channelNegotiated?this._setupData({channel:this._pc.createDataChannel(this.channelName,this.channelConfig)}):this._pc.ondatachannel=e=>{this._setupData(e)},this.streams&&this.streams.forEach(e=>{this.addStream(e)}),this._pc.ontrack=e=>{this._onTrack(e)},this._debug(\"initial negotiation\"),this._needsNegotiation(),this._onFinishBound=()=>{this._onFinish()},this.once(\"finish\",this._onFinishBound)}get bufferSize(){return this._channel&&this._channel.bufferedAmount||0}get connected(){return this._connected&&\"open\"===this._channel.readyState}address(){return{port:this.localPort,family:this.localFamily,address:this.localAddress}}signal(e){if(!this.destroying){if(this.destroyed)throw l(new Error(\"cannot signal after peer is destroyed\"),\"ERR_DESTROYED\");if(\"string\"==typeof e)try{e=JSON.parse(e)}catch(t){e={}}this._debug(\"signal()\"),e.renegotiate&&this.initiator&&(this._debug(\"got request to renegotiate\"),this._needsNegotiation()),e.transceiverRequest&&this.initiator&&(this._debug(\"got request for transceiver\"),this.addTransceiver(e.transceiverRequest.kind,e.transceiverRequest.init)),e.candidate&&(this._pc.remoteDescription&&this._pc.remoteDescription.type?this._addIceCandidate(e.candidate):this._pendingCandidates.push(e.candidate)),e.sdp&&this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(e)).then(()=>{this.destroyed||(this._pendingCandidates.forEach(e=>{this._addIceCandidate(e)}),this._pendingCandidates=[],\"offer\"===this._pc.remoteDescription.type&&this._createAnswer())}).catch(e=>{this.destroy(l(e,\"ERR_SET_REMOTE_DESCRIPTION\"))}),e.sdp||e.candidate||e.renegotiate||e.transceiverRequest||this.destroy(l(new Error(\"signal() called with invalid signal data\"),\"ERR_SIGNALING\"))}}_addIceCandidate(e){const t=new this._wrtc.RTCIceCandidate(e);this._pc.addIceCandidate(t).catch(e=>{!t.address||t.address.endsWith(\".local\")?r(\"Ignoring unsupported ICE candidate.\"):this.destroy(l(e,\"ERR_ADD_ICE_CANDIDATE\"))})}send(e){if(!this.destroying){if(this.destroyed)throw l(new Error(\"cannot send after peer is destroyed\"),\"ERR_DESTROYED\");this._channel.send(e)}}addTransceiver(e,t){if(!this.destroying){if(this.destroyed)throw l(new Error(\"cannot addTransceiver after peer is destroyed\"),\"ERR_DESTROYED\");if(this._debug(\"addTransceiver()\"),this.initiator)try{this._pc.addTransceiver(e,t),this._needsNegotiation()}catch(e){this.destroy(l(e,\"ERR_ADD_TRANSCEIVER\"))}else this.emit(\"signal\",{type:\"transceiverRequest\",transceiverRequest:{kind:e,init:t}})}}addStream(e){if(!this.destroying){if(this.destroyed)throw l(new Error(\"cannot addStream after peer is destroyed\"),\"ERR_DESTROYED\");this._debug(\"addStream()\"),e.getTracks().forEach(t=>{this.addTrack(t,e)})}}addTrack(e,t){if(this.destroying)return;if(this.destroyed)throw l(new Error(\"cannot addTrack after peer is destroyed\"),\"ERR_DESTROYED\");this._debug(\"addTrack()\");const n=this._senderMap.get(e)||new Map;let r=n.get(t);if(!r)r=this._pc.addTrack(e,t),n.set(t,r),this._senderMap.set(e,n),this._needsNegotiation();else if(r.removed)throw l(new Error(\"Track has been removed. You should enable/disable tracks that you want to re-add.\"),\"ERR_SENDER_REMOVED\");else throw l(new Error(\"Track has already been added to that stream.\"),\"ERR_SENDER_ALREADY_ADDED\")}replaceTrack(e,t,n){if(this.destroying)return;if(this.destroyed)throw l(new Error(\"cannot replaceTrack after peer is destroyed\"),\"ERR_DESTROYED\");this._debug(\"replaceTrack()\");const r=this._senderMap.get(e),a=r?r.get(n):null;if(!a)throw l(new Error(\"Cannot replace track that was never added.\"),\"ERR_TRACK_NOT_ADDED\");t&&this._senderMap.set(t,r),null==a.replaceTrack?this.destroy(l(new Error(\"replaceTrack is not supported in this browser\"),\"ERR_UNSUPPORTED_REPLACETRACK\")):a.replaceTrack(t)}removeTrack(e,t){if(this.destroying)return;if(this.destroyed)throw l(new Error(\"cannot removeTrack after peer is destroyed\"),\"ERR_DESTROYED\");this._debug(\"removeSender()\");const n=this._senderMap.get(e),r=n?n.get(t):null;if(!r)throw l(new Error(\"Cannot remove track that was never added.\"),\"ERR_TRACK_NOT_ADDED\");try{r.removed=!0,this._pc.removeTrack(r)}catch(e){\"NS_ERROR_UNEXPECTED\"===e.name?this._sendersAwaitingStable.push(r):this.destroy(l(e,\"ERR_REMOVE_TRACK\"))}this._needsNegotiation()}removeStream(e){if(!this.destroying){if(this.destroyed)throw l(new Error(\"cannot removeStream after peer is destroyed\"),\"ERR_DESTROYED\");this._debug(\"removeSenders()\"),e.getTracks().forEach(t=>{this.removeTrack(t,e)})}}_needsNegotiation(){this._debug(\"_needsNegotiation\"),this._batchedNegotiation||(this._batchedNegotiation=!0,s(()=>{this._batchedNegotiation=!1,this.initiator||!this._firstNegotiation?(this._debug(\"starting batched negotiation\"),this.negotiate()):this._debug(\"non-initiator initial negotiation request discarded\"),this._firstNegotiation=!1}))}negotiate(){if(!this.destroying){if(this.destroyed)throw l(new Error(\"cannot negotiate after peer is destroyed\"),\"ERR_DESTROYED\");this.initiator?this._isNegotiating?(this._queuedNegotiation=!0,this._debug(\"already negotiating, queueing\")):(this._debug(\"start negotiation\"),setTimeout(()=>{this._createOffer()},0)):this._isNegotiating?(this._queuedNegotiation=!0,this._debug(\"already negotiating, queueing\")):(this._debug(\"requesting negotiation from initiator\"),this.emit(\"signal\",{type:\"renegotiate\",renegotiate:!0})),this._isNegotiating=!0}}destroy(e){this._destroy(e,()=>{})}_destroy(e,t){this.destroyed||this.destroying||(this.destroying=!0,this._debug(\"destroying (error: %s)\",e&&(e.message||e)),s(()=>{if(this.destroyed=!0,this.destroying=!1,this._debug(\"destroy (error: %s)\",e&&(e.message||e)),this.readable=this.writable=!1,this._readableState.ended||this.push(null),this._writableState.finished||this.end(),this._connected=!1,this._pcReady=!1,this._channelReady=!1,this._remoteTracks=null,this._remoteStreams=null,this._senderMap=null,clearInterval(this._closingInterval),this._closingInterval=null,clearInterval(this._interval),this._interval=null,this._chunk=null,this._cb=null,this._onFinishBound&&this.removeListener(\"finish\",this._onFinishBound),this._onFinishBound=null,this._channel){try{this._channel.close()}catch(e){}this._channel.onmessage=null,this._channel.onopen=null,this._channel.onclose=null,this._channel.onerror=null}if(this._pc){try{this._pc.close()}catch(e){}this._pc.oniceconnectionstatechange=null,this._pc.onicegatheringstatechange=null,this._pc.onsignalingstatechange=null,this._pc.onicecandidate=null,this._pc.ontrack=null,this._pc.ondatachannel=null}this._pc=null,this._channel=null,e&&this.emit(\"error\",e),this.emit(\"close\"),t()}))}_setupData(e){if(!e.channel)return this.destroy(l(new Error(\"Data channel event is missing `channel` property\"),\"ERR_DATA_CHANNEL\"));this._channel=e.channel,this._channel.binaryType=\"arraybuffer\",\"number\"==typeof this._channel.bufferedAmountLowThreshold&&(this._channel.bufferedAmountLowThreshold=u),this.channelName=this._channel.label,this._channel.onmessage=e=>{this._onChannelMessage(e)},this._channel.onbufferedamountlow=()=>{this._onChannelBufferedAmountLow()},this._channel.onopen=()=>{this._onChannelOpen()},this._channel.onclose=()=>{this._onChannelClose()},this._channel.onerror=e=>{const t=e.error instanceof Error?e.error:new Error(`Datachannel error: ${e.message} ${e.filename}:${e.lineno}:${e.colno}`);this.destroy(l(t,\"ERR_DATA_CHANNEL\"))};let t=!1;this._closingInterval=setInterval(()=>{this._channel&&\"closing\"===this._channel.readyState?(t&&this._onChannelClose(),t=!0):t=!1},5000)}_read(){}_write(e,t,n){if(this.destroyed)return n(l(new Error(\"cannot write after peer is destroyed\"),\"ERR_DATA_CHANNEL\"));if(this._connected){try{this.send(e)}catch(e){return this.destroy(l(e,\"ERR_DATA_CHANNEL\"))}this._channel.bufferedAmount>u?(this._debug(\"start backpressure: bufferedAmount %d\",this._channel.bufferedAmount),this._cb=n):n(null)}else this._debug(\"write before connect\"),this._chunk=e,this._cb=n}_onFinish(){if(!this.destroyed){const e=()=>{setTimeout(()=>this.destroy(),1e3)};this._connected?e():this.once(\"connect\",e)}}_startIceCompleteTimeout(){this.destroyed||this._iceCompleteTimer||(this._debug(\"started iceComplete timeout\"),this._iceCompleteTimer=setTimeout(()=>{this._iceComplete||(this._iceComplete=!0,this._debug(\"iceComplete timeout completed\"),this.emit(\"iceTimeout\"),this.emit(\"_iceComplete\"))},this.iceCompleteTimeout))}_createOffer(){this.destroyed||this._pc.createOffer(this.offerOptions).then(e=>{if(this.destroyed)return;this.trickle||this.allowHalfTrickle||(e.sdp=n(e.sdp)),e.sdp=this.sdpTransform(e.sdp);const t=()=>{if(!this.destroyed){const t=this._pc.localDescription||e;this._debug(\"signal\"),this.emit(\"signal\",{type:t.type,sdp:t.sdp})}};this._pc.setLocalDescription(e).then(()=>{this._debug(\"createOffer success\"),this.destroyed||(this.trickle||this._iceComplete?t():this.once(\"_iceComplete\",t))}).catch(e=>{this.destroy(l(e,\"ERR_SET_LOCAL_DESCRIPTION\"))})}).catch(e=>{this.destroy(l(e,\"ERR_CREATE_OFFER\"))})}_requestMissingTransceivers(){this._pc.getTransceivers&&this._pc.getTransceivers().forEach(e=>{e.mid||!e.sender.track||e.requested||(e.requested=!0,this.addTransceiver(e.sender.track.kind))})}_createAnswer(){this.destroyed||this._pc.createAnswer(this.answerOptions).then(e=>{if(this.destroyed)return;this.trickle||this.allowHalfTrickle||(e.sdp=n(e.sdp)),e.sdp=this.sdpTransform(e.sdp);const t=()=>{if(!this.destroyed){const t=this._pc.localDescription||e;this._debug(\"signal\"),this.emit(\"signal\",{type:t.type,sdp:t.sdp}),this.initiator||this._requestMissingTransceivers()}};this._pc.setLocalDescription(e).then(()=>{this.destroyed||(this.trickle||this._iceComplete?t():this.once(\"_iceComplete\",t))}).catch(e=>{this.destroy(l(e,\"ERR_SET_LOCAL_DESCRIPTION\"))})}).catch(e=>{this.destroy(l(e,\"ERR_CREATE_ANSWER\"))})}_onConnectionStateChange(){this.destroyed||\"failed\"===this._pc.connectionState&&this.destroy(l(new Error(\"Connection failed.\"),\"ERR_CONNECTION_FAILURE\"))}_onIceStateChange(){if(this.destroyed)return;const e=this._pc.iceConnectionState,t=this._pc.iceGatheringState;this._debug(\"iceStateChange (connection: %s) (gathering: %s)\",e,t),this.emit(\"iceStateChange\",e,t),(\"connected\"===e||\"completed\"===e)&&(this._pcReady=!0,this._maybeReady()),\"failed\"===e&&this.destroy(l(new Error(\"Ice connection failed.\"),\"ERR_ICE_CONNECTION_FAILURE\")),\"closed\"===e&&this.destroy(l(new Error(\"Ice connection closed.\"),\"ERR_ICE_CONNECTION_CLOSED\"))}getStats(e){const t=e=>(\"[object Array]\"===Object.prototype.toString.call(e.values)&&e.values.forEach(t=>{Object.assign(e,t)}),e);0===this._pc.getStats.length||this._isReactNativeWebrtc?this._pc.getStats().then(n=>{const r=[];n.forEach(e=>{r.push(t(e))}),e(null,r)},t=>e(t)):0<this._pc.getStats.length?this._pc.getStats(n=>{if(this.destroyed)return;const r=[];n.result().forEach(e=>{const n={};e.names().forEach(t=>{n[t]=e.stat(t)}),n.id=e.id,n.type=e.type,n.timestamp=e.timestamp,r.push(t(n))}),e(null,r)},t=>e(t)):e(null,[])}_maybeReady(){if(this._debug(\"maybeReady pc %s channel %s\",this._pcReady,this._channelReady),this._connected||this._connecting||!this._pcReady||!this._channelReady)return;this._connecting=!0;const e=()=>{this.destroyed||this.getStats((t,n)=>{if(this.destroyed)return;t&&(n=[]);const r={},a={},o={};let i=!1;n.forEach(e=>{(\"remotecandidate\"===e.type||\"remote-candidate\"===e.type)&&(r[e.id]=e),(\"localcandidate\"===e.type||\"local-candidate\"===e.type)&&(a[e.id]=e),(\"candidatepair\"===e.type||\"candidate-pair\"===e.type)&&(o[e.id]=e)});const d=e=>{i=!0;let t=a[e.localCandidateId];t&&(t.ip||t.address)?(this.localAddress=t.ip||t.address,this.localPort=+t.port):t&&t.ipAddress?(this.localAddress=t.ipAddress,this.localPort=+t.portNumber):\"string\"==typeof e.googLocalAddress&&(t=e.googLocalAddress.split(\":\"),this.localAddress=t[0],this.localPort=+t[1]),this.localAddress&&(this.localFamily=this.localAddress.includes(\":\")?\"IPv6\":\"IPv4\");let n=r[e.remoteCandidateId];n&&(n.ip||n.address)?(this.remoteAddress=n.ip||n.address,this.remotePort=+n.port):n&&n.ipAddress?(this.remoteAddress=n.ipAddress,this.remotePort=+n.portNumber):\"string\"==typeof e.googRemoteAddress&&(n=e.googRemoteAddress.split(\":\"),this.remoteAddress=n[0],this.remotePort=+n[1]),this.remoteAddress&&(this.remoteFamily=this.remoteAddress.includes(\":\")?\"IPv6\":\"IPv4\"),this._debug(\"connect local: %s:%s remote: %s:%s\",this.localAddress,this.localPort,this.remoteAddress,this.remotePort)};if(n.forEach(e=>{\"transport\"===e.type&&e.selectedCandidatePairId&&d(o[e.selectedCandidatePairId]),(\"googCandidatePair\"===e.type&&\"true\"===e.googActiveConnection||(\"candidatepair\"===e.type||\"candidate-pair\"===e.type)&&e.selected)&&d(e)}),!i&&(!Object.keys(o).length||Object.keys(a).length))return void setTimeout(e,100);if(this._connecting=!1,this._connected=!0,this._chunk){try{this.send(this._chunk)}catch(e){return this.destroy(l(e,\"ERR_DATA_CHANNEL\"))}this._chunk=null,this._debug(\"sent chunk from \\\"write before connect\\\"\");const e=this._cb;this._cb=null,e(null)}\"number\"!=typeof this._channel.bufferedAmountLowThreshold&&(this._interval=setInterval(()=>this._onInterval(),150),this._interval.unref&&this._interval.unref()),this._debug(\"connect\"),this.emit(\"connect\")})};e()}_onInterval(){this._cb&&this._channel&&!(this._channel.bufferedAmount>u)&&this._onChannelBufferedAmountLow()}_onSignalingStateChange(){this.destroyed||(\"stable\"===this._pc.signalingState&&(this._isNegotiating=!1,this._debug(\"flushing sender queue\",this._sendersAwaitingStable),this._sendersAwaitingStable.forEach(e=>{this._pc.removeTrack(e),this._queuedNegotiation=!0}),this._sendersAwaitingStable=[],this._queuedNegotiation?(this._debug(\"flushing negotiation queue\"),this._queuedNegotiation=!1,this._needsNegotiation()):(this._debug(\"negotiated\"),this.emit(\"negotiated\"))),this._debug(\"signalingStateChange %s\",this._pc.signalingState),this.emit(\"signalingStateChange\",this._pc.signalingState))}_onIceCandidate(e){this.destroyed||(e.candidate&&this.trickle?this.emit(\"signal\",{type:\"candidate\",candidate:{candidate:e.candidate.candidate,sdpMLineIndex:e.candidate.sdpMLineIndex,sdpMid:e.candidate.sdpMid}}):!e.candidate&&!this._iceComplete&&(this._iceComplete=!0,this.emit(\"_iceComplete\")),e.candidate&&this._startIceCompleteTimeout())}_onChannelMessage(e){if(this.destroyed)return;let t=e.data;t instanceof ArrayBuffer&&(t=c.from(t)),this.push(t)}_onChannelBufferedAmountLow(){if(!this.destroyed&&this._cb){this._debug(\"ending backpressure: bufferedAmount %d\",this._channel.bufferedAmount);const e=this._cb;this._cb=null,e(null)}}_onChannelOpen(){this._connected||this.destroyed||(this._debug(\"on channel open\"),this._channelReady=!0,this._maybeReady())}_onChannelClose(){this.destroyed||(this._debug(\"on channel close\"),this.destroy())}_onTrack(e){this.destroyed||e.streams.forEach(t=>{this._debug(\"on track\"),this.emit(\"track\",e.track,t),this._remoteTracks.push({track:e.track,stream:t}),this._remoteStreams.some(e=>e.id===t.id)||(this._remoteStreams.push(t),s(()=>{this._debug(\"on stream\"),this.emit(\"stream\",t)}))})}_debug(){const e=[].slice.call(arguments);e[0]=\"[\"+this._id+\"] \"+e[0],a.apply(null,e)}}p.WEBRTC_SUPPORT=!!o(),p.config={iceServers:[{urls:[\"stun:stun.l.google.com:19302\",\"stun:global.stun.twilio.com:3478\"]}],sdpSemantics:\"unified-plan\"},p.channelConfig={},t.exports=p},{buffer:3,debug:4,\"err-code\":6,\"get-browser-rtc\":8,\"queue-microtask\":13,randombytes:14,\"readable-stream\":29}]},{},[])(\"/\")});","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","/* global WorkerGlobalScope */\n\nexport function addBrowser(fn) {\n  if (typeof WorkerGlobalScope === 'function' && self instanceof WorkerGlobalScope) {\n    /**\n     * Because killing a worker does directly stop the excution\n     * of the code, our only chance is to overwrite the close function\n     * which could work some times.\n     * @link https://stackoverflow.com/q/72903255/3443137\n     */\n    var oldClose = self.close.bind(self);\n    self.close = function () {\n      fn();\n      return oldClose();\n    };\n  } else {\n    /**\n     * if we are on react-native, there is no window.addEventListener\n     * @link https://github.com/pubkey/unload/issues/6\n     */\n    if (typeof window.addEventListener !== 'function') {\n      return;\n    }\n\n    /**\n     * for normal browser-windows, we use the beforeunload-event\n     */\n    window.addEventListener('beforeunload', function () {\n      fn();\n    }, true);\n\n    /**\n     * for iframes, we have to use the unload-event\n     * @link https://stackoverflow.com/q/47533670/3443137\n     */\n    window.addEventListener('unload', function () {\n      fn();\n    }, true);\n  }\n\n  /**\n   * TODO add fallback for safari-mobile\n   * @link https://stackoverflow.com/a/26193516/3443137\n   */\n}","import { addBrowser } from './browser.js';\nimport { addNode } from './node.js';\n\n/**\n * Use the code directly to prevent import problems\n * with the detect-node package.\n * @link https://github.com/iliakan/detect-node/blob/master/index.js\n */\nvar isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\nvar USE_METHOD = isNode ? addNode : addBrowser;\nvar LISTENERS = new Set();\nvar startedListening = false;\nfunction startListening() {\n  if (startedListening) {\n    return;\n  }\n  startedListening = true;\n  USE_METHOD(runAll);\n}\nexport function add(fn) {\n  startListening();\n  if (typeof fn !== 'function') {\n    throw new Error('Listener is no function');\n  }\n  LISTENERS.add(fn);\n  var addReturn = {\n    remove: function remove() {\n      return LISTENERS[\"delete\"](fn);\n    },\n    run: function run() {\n      LISTENERS[\"delete\"](fn);\n      return fn();\n    }\n  };\n  return addReturn;\n}\nexport function runAll() {\n  var promises = [];\n  LISTENERS.forEach(function (fn) {\n    promises.push(fn());\n    LISTENERS[\"delete\"](fn);\n  });\n  return Promise.all(promises);\n}\nexport function removeAll() {\n  LISTENERS.clear();\n}\nexport function getSize() {\n  return LISTENERS.size;\n}","export function addNode(fn) {\n  process.on('exit', function () {\n    return fn();\n  });\n\n  /**\n   * on the following events,\n   * the process will not end if there are\n   * event-handlers attached,\n   * therefore we have to call process.exit()\n   */\n  process.on('beforeExit', function () {\n    return fn().then(function () {\n      return process.exit();\n    });\n  });\n  // catches ctrl+c event\n  process.on('SIGINT', function () {\n    return fn().then(function () {\n      return process.exit();\n    });\n  });\n  // catches uncaught exceptions\n  process.on('uncaughtException', function (err) {\n    return fn().then(function () {\n      console.trace(err);\n      process.exit(101);\n    });\n  });\n}","// @ts-check\r\nconst RXDB_SETUP_VER = \"0.0.1\";\r\nwindow[\"logConsoleHereIs\"](`here is rxdb-setup.js, module, ${RXDB_SETUP_VER}`);\r\nconst styleLog = \"background:red; color:white; font-size:20px; padding:5px;\";\r\nconsole.log(`%chere is rxdb-setup.js`, styleLog);\r\nif (document.currentScript) { throw \"rxdb-setup.js is not loaded as module\"; }\r\n\r\nexport function getVersion() { return `rxdb-setup.js ${RXDB_SETUP_VER}`; }\r\n\r\n// const modCore = await import( 'rxdb/plugins/core');\r\n// console.log({modCore});\r\n\r\n\r\nimport { addRxPlugin, createRxDatabase } from 'rxdb/plugins/core';\r\n// import { createRxDatabase } from 'rxdb/plugins/core';\r\nimport { RxDBDevModePlugin } from 'rxdb/plugins/dev-mode';\r\nimport { getRxStorageDexie } from 'rxdb/plugins/storage-dexie';\r\nimport { wrappedValidateAjvStorage } from 'rxdb/plugins/validate-ajv';\r\naddRxPlugin(RxDBDevModePlugin); // FIX-ME: remove in production\r\nimport Ajv from 'ajv';\r\nimport addFormats from 'ajv-formats';\r\n\r\n\r\n\r\n// Create an AJV instance and add formats\r\ndebugger;\r\nconst ajv = new Ajv({\r\n    strict: false,\r\n    allErrors: true,\r\n    formats: { 'date-time': true },\r\n}); // Disable strict mode\r\naddFormats(ajv); // Adds support for \"date-time\" and other formats\r\n\r\n// create a database\r\n// Wrap Dexie storage with AJV schema validation\r\nconst storage = wrappedValidateAjvStorage({\r\n    storage: getRxStorageDexie(),\r\n});\r\nconst ourDB = await createRxDatabase({\r\n    name: 'mm4i', // the name of the database\r\n    // storage: getRxStorageDexie()\r\n    storage,\r\n});\r\nconsole.log(`%cAfter createRxDatabase`, styleLog, ourDB);\r\n\r\nexport function getDB() { return ourDB; }\r\n\r\nconst mm4iSchema = {\r\n    // title: 'mm4i schema',\r\n    title: 'mm4i',\r\n    version: 0,\r\n    type: 'object',\r\n    primaryKey: 'id',\r\n    properties: {\r\n        // id: { type: 'string', maxLength: 100 },\r\n        id: { type: 'string', maxLength: 100 },\r\n        text: { type: 'string' },\r\n        isCompleted: { type: 'boolean' },\r\n        createdAt: { type: 'string', format: 'date-time' },\r\n        updatedAt: { type: 'string', format: 'date-time' },\r\n        deletedAt: { type: ['string', 'null'], format: 'date-time' },\r\n    },\r\n    required: ['id', 'text', 'isCompleted', 'createdAt', 'updatedAt']\r\n};\r\n\r\n// Compile the schema\r\nconst validate = ajv.compile(mm4iSchema);\r\nif (!validate) {\r\n    console.log({ validate });\r\n    debugger;\r\n}\r\n\r\n// Test validation\r\n// const validData = { createdAt: new Date().toISOString() }; // ISO date string\r\nconst validData = {\r\n    id: '123', // Required primary key\r\n    text: 'Sample task',\r\n    isCompleted: false,\r\n    createdAt: new Date().toISOString(),\r\n    updatedAt: new Date().toISOString(),\r\n};\r\nconst invalidData = { createdAt: 'invalid-date' };\r\n\r\nconst boolValid = validate(validData); // true\r\nconsole.log(boolValid, validate.errors); // true\r\n\r\nconsole.log(validate(invalidData)); // false\r\n\r\nawait ourDB.addCollections({\r\n    mindmaps: {\r\n        /*\r\n        id: {\r\n            type: 'string',\r\n            maxLength: 100,\r\n            primary: true,\r\n        },\r\n        version: 0,\r\n        schema: {\r\n            version: 0,\r\n            type: 'object',\r\n            primaryKey: 'id',\r\n            properties: {\r\n                id: { type: 'string', maxLength: 100 },\r\n                content: { type: 'string' },\r\n                createdAt: { type: 'string', format: 'date-time' },\r\n                updatedAt: { type: 'string', format: 'date-time' }\r\n            },\r\n            required: ['id', 'content', 'createdAt', 'updatedAt']\r\n        },\r\n        */\r\n        schema: mm4iSchema,\r\n    }\r\n});\r\n// debugger;\r\n\r\nimport {\r\n    replicateWebRTC,\r\n    getConnectionHandlerSimplePeer\r\n} from 'rxdb/plugins/replication-webrtc';\r\n\r\n\r\n/**\r\n * \r\n * @param {string} room \r\n * @param {string} secret \r\n * @returns {Promise<ReplicationState>}\r\n */\r\nexport async function replicateMindmaps(room, secret) {\r\n    const tofRoom = typeof room;\r\n    if (tofRoom !== \"string\") {\r\n        throw new Error(`room must be string, but has type \"${tofRoom}\"`);\r\n    }\r\n    const tofSecret = typeof secret;\r\n    if (tofSecret !== \"string\") {\r\n        throw new Error(`secret must be string, but has type \"${tofSecret}\"`);\r\n    }\r\n\r\n    try {\r\n        const replication = await replicateWebRTC({\r\n            collection: ourDB.mindmaps,\r\n            topic: room, // <- set any app-specific room id here.\r\n            secret: secret, // Removed as it is not a valid property\r\n            connectionHandlerCreator: getConnectionHandlerSimplePeer({}),\r\n            pull: {},\r\n            push: {}\r\n        });\r\n        return replication\r\n    } catch (err) {\r\n        console.error(\"Replication error:\", err);\r\n        return null;\r\n    }\r\n}\r\n\r\n/*\r\nreplicateWebRTC({\r\n    collection: ourDB.mindmaps,\r\n    connectionHandlerCreator: getConnectionHandlerSimplePeer({}),\r\n    topic: '', // <- set any app-specific room id here.\r\n    secret: 'mXs8ya', // Removed as it is not a valid property\r\n    pull: {},\r\n    push: {}\r\n})\r\n*/\r\n\r\n\r\n\r\n// Skipped: Browser implementation of process.nextTick() -- from Claude\r\n\r\n// From RxDB docs\r\n// @ts-ignore\r\nwindow.process = {\r\n    nextTick: (fn, ...args) => setTimeout(() => fn(...args)),\r\n};\r\n\r\n\r\n\r\n// ICE servers\r\n// https://www.metered.ca/blog/list-of-webrtc-ice-servers/\r\nconst iceServers = [\r\n    { urls: \"stun:stun.l.google.com:19302\" },\r\n    { urls: \"stun:stun.l.google.com:5349\" },\r\n    { urls: \"stun:stun1.l.google.com:3478\" },\r\n    { urls: \"stun:stun1.l.google.com:5349\" },\r\n    { urls: \"stun:stun2.l.google.com:19302\" },\r\n    { urls: \"stun:stun2.l.google.com:5349\" },\r\n    { urls: \"stun:stun3.l.google.com:3478\" },\r\n    { urls: \"stun:stun3.l.google.com:5349\" },\r\n    { urls: \"stun:stun4.l.google.com:19302\" },\r\n    { urls: \"stun:stun4.l.google.com:5349\" }\r\n];\r\n// FIX-ME: export for testing purposes now\r\nexport function getOurICEServer() {\r\n    const n = 3; // just pick one from the list\r\n    const rec = iceServers[n];\r\n    return rec;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && queue.d < 1) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = -1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && queue.d < 0 && (queue.d = 0);\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".rxdb-setup-webpack.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\nvar installChunk = (data) => {\n\tvar {__webpack_ids__, __webpack_modules__, __webpack_runtime__} = data;\n\t// add \"modules\" to the modules object,\n\t// then flag all \"ids\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tfor(moduleId in __webpack_modules__) {\n\t\tif(__webpack_require__.o(__webpack_modules__, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = __webpack_modules__[moduleId];\n\t\t}\n\t}\n\tif(__webpack_runtime__) __webpack_runtime__(__webpack_require__);\n\tfor(;i < __webpack_ids__.length; i++) {\n\t\tchunkId = __webpack_ids__[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[__webpack_ids__[i]] = 0;\n\t}\n\n}\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// import() chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[1]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = import(\"./\" + __webpack_require__.u(chunkId)).then(installChunk, (e) => {\n\t\t\t\t\t\tif(installedChunks[chunkId] !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t});\n\t\t\t\t\tvar promise = Promise.race([promise, new Promise((resolve) => (installedChunkData = installedChunks[chunkId] = [resolve]))])\n\t\t\t\t\tpromises.push(installedChunkData[1] = promise);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no external install chunk\n\n// no on chunks loaded","","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./rxdb-setup.js\");\n",""],"names":[],"sourceRoot":""}
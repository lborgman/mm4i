// @ts-check
const UNDO_REDO_TREE_VERSION = "0.0.001";
window["logConsoleHereIs"](`here is undo-redo-tree.js, module ${UNDO_REDO_TREE_VERSION}`);
console.warn(`here is undo-redo-tree.js, module ${UNDO_REDO_TREE_VERSION}`);
if (document.currentScript) throw Error("import .currentScript"); // is module

if (typeof window["diff_match_patch"] !== "function") {
  throw Error("Google diff_match_patch is not loaded, please import it before this module");
}

// FIX-ME:
const eventRecordActionName = "undoredo-tree-recordAction";
export function getRecordEventName() { return eventRecordActionName; }
// document.addEventListener(eventRecordActionName, evt => { console.log("%cTEST document event", "font-size:24px;color:red;", evt); })

export function getUndoRedoTreeVersion() { return UNDO_REDO_TREE_VERSION; }
const logClassStyle = "background:white; color:blue; padding:2px; border-radius:2px;";
const logClassImportantStyle = logClassStyle + " font-size:18px;";
function logClass(what, ...msg) { console.warn(`%c${what}`, logClassStyle, ...msg); }
function logClassImportant(what, ...msg) { console.warn(`%c${what}`, logClassImportantStyle, ...msg); }





const histories = {};

////////////////////////////////////////////
//// START: Code suggestions for tree from Google Gemini AI (heavily modified):
export class HistoryTreeNode {
  /**
   * @param {UndoRedoTreeWithDiff} objUndoRedo 
   * @param {HistoryTreeNode|null} parent 
   * @param {Object} patchesToReachThisNode 
   * @param {Object} patchesToUndoThisNode 
   * @param {Object} fullState
   * @param {string} actionTopic 
   */
  constructor(objUndoRedo, parent, patchesToReachThisNode, patchesToUndoThisNode, actionTopic, fullState) {
    this.objUndoRedo = objUndoRedo; // Reference to the UndoRedoTreeWithDiff instance
    this.parent = parent; // Reference to the parent node
    this.children = [];   // Array of child nodes (branches)

    // Patches generated by diff_match_patch
    this.patchesToReach = patchesToReachThisNode; // Patches to apply to PARENT's state to get THIS node's state
    this.patchesToUndo = patchesToUndoThisNode;   // Patches to apply to THIS node's state to get PARENT's state

    this.fullState = fullState;

    if (typeof actionTopic !== "string") {
      throw Error(`Invalid action type: ${typeof actionTopic}, expected "string" or null`);
    }
    this.actionTopic = actionTopic; // Optional: Description of the action
    this.id = Date.now() + Math.random().toString(36).substring(2); // A simple unique ID for debugging or advanced navigation
  }

  /**
   * @type {any}
   */
  fullStateSnapshot = undefined; // FIX-ME: ??

  /**
   * Adds a child node to this node, representing a new action in the history.
   * @param {Object[]} patchesToReach - Patches to apply to the parent node's state to reach this new child node's state.
   * @param {Object[]} patchesToUndo - Patches to apply to this child node's state to undo back to the parent node's state.
   * @param {string} actionTopic - Description of the action that led to this new child node.
   * @param {Object} fullState - Copy of full state
   * @returns {HistoryTreeNode} The newly created child node.
   */
  addChild(patchesToReach, patchesToUndo, actionTopic, fullState) {
    if (fullState == undefined) {
      const msg = "addChild, fullState == undefined";
      console.error(msg);
      debugger; // eslint-disable-line no-debugger
      throw Error(msg);
    }
    if (!this.objUndoRedo.isTreeStructured) {
      this.children.length = 0; // Clear existing children if linear
    }
    const newNode = new HistoryTreeNode(this.objUndoRedo, this, patchesToReach, patchesToUndo, actionTopic, fullState);
    this.children.push(newNode);
    this.currentBranchIndex = this.children.length - 1; // Update current branch index to the new child
    return newNode;
  }
}

function _OLDjsonStringifySorted(obj) {
  return JSON.stringify(Object.keys(obj).sort().reduce((acc, key) => { acc[key] = obj[key]; return acc; }, {}));
}

/**
 * A recursive version (from Grok)
 * 
 * @param {any} obj 
 * @returns {string}
 */
function jsonStringifySorted(obj) {
  // Handle undefined explicitly
  if (obj === undefined) {
    // return '"__undefined__"';
    // FIX-ME: This will be a restriction. Keep an eye on it!
    return JSON.stringify(null);
  }

  // Handle non-object types (strings, numbers, booleans, null, etc.)
  if (obj === null || typeof obj !== 'object') {
    return JSON.stringify(obj);
  }

  // Handle arrays
  if (Array.isArray(obj)) {
    return '[' + obj.map(item => jsonStringifySorted(item)).join(',') + ']';
  }

  // Handle objects: sort keys and recursively process values
  return '{' + Object.keys(obj)
    .sort()
    .map(key => {
      const value = jsonStringifySorted(obj[key]);
      return `${JSON.stringify(key)}:${value}`;
    })
    .join(',') + '}';
}



const diff_match_patch = window["diff_match_patch"];
export class UndoRedoTreeWithDiff {
  #treeStructured = false;
  #stateType;
  #historyKey;
  #historyRecordFun;
  #checkStateType(state) {
    const tofState = typeof state;
    if (tofState !== this.#stateType) {
      throw Error(`type of state: "${tofState}", expected "${this.#stateType}"`);
    }
    if (tofState === "object") {
      try {
        const strJson = jsonStringifySorted(state); // Check if state can be serialized
        const objJson = JSON.parse(strJson); // Check if state can be deserialized
        // window["strJson"] = strJson;
        // window["objJson"] = objJson;
        const str = JSON.stringify(objJson);
        if (str !== strJson) {
          debugger; // eslint-disable-line no-debugger
          throw Error(`state is not a JSON object`);
        }
      } catch (e) {
        throw Error(`Invalid initialState object: ${e.message}`);
      }
    }
  }
  /**
   * @param {any} initialState - string or json object representing the initial state of the application.
   * @param {(defaultBranch: number, arrBranches: string[]) => number | null} [funBranch]
   * @param {any} historyKey
   * @param {function|undefined} historyRecordFun
   */
  constructor(initialState, funBranch = undefined, historyKey = undefined, historyRecordFun = undefined) {
    const tofState = typeof initialState;
    const arrAllowedTypes = ["string", "object"];
    if (!arrAllowedTypes.includes(tofState)) {
      throw Error(`Invalid initialState type: ${tofState}, expected one of ${arrAllowedTypes.join(", ")}`);
    }
    this.#stateType = tofState;
    this.#checkStateType(initialState); // Validate the initial state type

    let txtLinOrTree = "ERROR";
    if (funBranch == null) {
      this.#treeStructured = false;
      txtLinOrTree = "**LINEAR**";
      // logClassImportant("UndoRedoTreeWithDiff", "Using linear undo/redo structure");
    } else {
      this.#treeStructured = true;
      txtLinOrTree = "**BRANCH**";
      // logClassImportant("UndoRedoTreeWithDiff", "Using tree undo/redo structure");
      this.funBranch = funBranch; // Function to handle branching logic
      const tofFunBranch = typeof funBranch;
      if (tofFunBranch !== "function") {
        throw Error(`Invalid funBranch type: ${tofFunBranch}, expected "function"`);
      }
      if (funBranch.constructor.name !== "AsyncFunction") {
        throw Error(`funBranch is not async`);
      }
      const lenFunBranch = funBranch.length;
      if (lenFunBranch !== 2) {
        throw Error(`Invalid funBranch length: ${lenFunBranch}, expected 2`);
      }
    }
    this.#historyKey = historyKey;
    this.#historyRecordFun = historyRecordFun;
    if (historyRecordFun) {
      if (this.#historyKey == undefined) throw Error("historyKey must be given if historyRecordFun is given");
      const tofHistoryFun = typeof historyRecordFun;
      if (tofHistoryFun != "function") throw Error(`historyRecordFun must be function: "${tofHistoryFun}`);
      const len = historyRecordFun.length;
      if (len != 1) {
        throw Error(`historyRecordFun should take 1 parameter but takes ${len}`);
      }
    }
    logClassImportant("UndoRedoTreeWithDiff", txtLinOrTree, initialState);
    this.dmp = new diff_match_patch();

    // The root node stores the full initial state directly, as it has no parent/patches.
    const fullStateSnapshot = this._deepCopy(initialState);
    this.rootNode = new HistoryTreeNode(this, null, null, null, "Initial State", fullStateSnapshot);
    // We'll store the actual state on the root node because it's the base.
    this.rootNode.fullStateSnapshot = fullStateSnapshot;

    this.currentNode = this.rootNode;
    // This holds the fully rehydrated state of `this.currentNode`.
    this.currentFullState = this._deepCopy(initialState);
  }

  setHistoryKey(key) {
    if (this.#historyRecordFun != undefined) {
      const msg = `#historyKey is already set to "${this.#historyRecordFun}", can't change it to "${key}"`;
      console.error(msg);
      debugger; // eslint-disable-line no-debugger
      throw Error(msg);
    }
    this.#historyRecordFun = key;
  }

  OLDlogTreeStructure() {
    const linearOrTree = this.isTreeStructured ? "Tree" : "Linear";
    const h = this;
    logClassImportant(`Current tree structure (${linearOrTree}):`, { h });
    const current = this.currentNode;
    const traverse = (node, depth = 0) => {
      const markCurrent = (node === current) ? ">" : "";
      const styleCurrent = (node === current) ? "background:darkblue;color:white;" : "background:black;color:lightgray;";
      console.log("%c" + "  ".repeat(depth) + `${markCurrent}Node: ${node.actionTopic || "N/A"} `, styleCurrent);
      if (node.children.length > 0) {
        node.children.forEach(child => traverse(child, depth + 1));
      }
    }
    traverse(this.rootNode);
  }
  logTreeStructure() {
    const linearOrTree = this.isTreeStructured ? "Tree" : "Linear";
    const h = this;
    logClassImportant(`New current tree structure (${linearOrTree}):`, { h });
    const fun = (node, depth, current) => {
      const markCurrent = (node === current) ? ">" : "";
      const style = (node === current) ? "background:darkblue;color:white;" : "background:black;color:lightgray;";
      console.log("%c" + "  ".repeat(depth) + `${markCurrent}Node: ${node.actionTopic || "N/A"} `, style);
    }
    this.startWalkSubtree(this.rootNode, fun);
  }
  startWalkSubtree(node, fun) {
    const current = this.currentNode;
    walkSubtree(node, 0);
    function walkSubtree(node, depth) {
      fun(node, depth, current);
      const actionTopic = node.actionTopic;
      const numChildren = node.children.length;
      if (numChildren > 0) {
        // console.log("walkSubtree", actionTopic, numChildren);
        node.children.forEach(child => walkSubtree(child, depth + 1));
      }

    }
  }
  startWalkTree(fun) {
    this.startWalkSubtree(this.rootNode, fun);
  }

  _serialize(state) {
    // Ensure consistent serialization, e.g., by sorting keys
    // return jsonStringifySorted(state);
    const strJson = jsonStringifySorted(state);
    const obj = JSON.parse(strJson);
    // console.log({ obj });
    const strJson2 = jsonStringifySorted(obj);
    if (strJson != strJson2) {
      debugger; // eslint-disable-line no-debugger
      throw Error("strJson != strJson2");
    }
    return strJson;
  }

  _deserialize(stateString) {
    try {
      return JSON.parse(stateString);
    } catch (e) {
      console.error("Error deserializing state:", e, stateString);
      debugger; // eslint-disable-line no-debugger
      // Graceful error handling: return null or throw, depending on application needs
      throw Error(`Error deserializing state: ${e}`);
      return null;
    }
  }

  _deepCopy(obj) {
    return JSON.parse(jsonStringifySorted(obj));
  }

  get isTreeStructured() {
    return this.#treeStructured;
  }

  /**
   * 
   * @param {any} newFullState -- string or json object representing the new state of the application.
   * @param {string} actionTopic 
   * @returns 
   */
  recordAction(newFullState, actionTopic) {
    logClass("recordAction()", actionTopic, newFullState);
    this.#checkStateType(newFullState); // Validate the new state type
    const oldStateText = this._serialize(this.currentFullState);
    const newStateText = this._serialize(newFullState);

    if (oldStateText === newStateText) {
      console.log("No change in state, not recording.");
      return; // Nothing to record
    }

    // Create patches to go from old state to new state
    const patchesToReachNew = this.dmp.patch_make(oldStateText, newStateText);
    // Create patches to go from new state back to old state (for undo)
    const patchesToUndoNew = this.dmp.patch_make(newStateText, oldStateText);

    // If the current node has children, performing a new action might mean
    // abandoning other branches for the default redo path.
    // For now, we'll just add a new child.
    // Pruning or managing 'active' redo branches can be added if needed.
    // Example: this.currentNode.children = []; // If new action prunes old redo branches

    const fullState = this._deepCopy(newFullState); // Update the materialized state
    const newNode = this.currentNode.addChild(patchesToReachNew, patchesToUndoNew, actionTopic, fullState);
    this.currentNode = newNode;
    this.currentFullState = fullState;

    if (this.#historyRecordFun == undefined) {
      const evtRecordAction = new CustomEvent(eventRecordActionName, { detail: { key: this.#historyKey } });
      console.log("document.dispatchEvent(evtRecordAction)", evtRecordAction);
      document.dispatchEvent(evtRecordAction);
    } else {
      console.log(`Callihng #historyRecordFun(${this.#historyKey})`);
      this.#historyRecordFun(this.#historyKey);
    }
  }

  canUndo() {
    if (!this.currentNode.parent) return undefined; // No parent means no undo possible
    // return this.currentNode.parent.actionTopic || null; // Return the action topic of the parent node
    return this.currentNode.actionTopic; // Return the action topic of current node
  }
  /**
   * Undo the last action, returning the previous state.
   * @returns {any} The state after undoing
   */
  undo() {
    logClass("undo()");
    if (!this.canUndo()) {
      console.log("Already at root. Nothing to undo.");
      debugger; // eslint-disable-line no-debugger
      return null;
    }
    if (!this.currentNode.parent) {
      debugger; // eslint-disable-line no-debugger
      throw Error("undo but no .parent");
    }

    const patchesToApplyForUndo = this.currentNode.patchesToUndo;
    if (!patchesToApplyForUndo) {
      console.error("Error: Current node is missing 'patchesToUndo'.");
      debugger; // eslint-disable-line no-debugger
      return null;
    }

    const currentStateText = this._serialize(this.currentFullState);
    const [parentStateText, patchResults] = this.dmp.patch_apply(patchesToApplyForUndo, currentStateText);

    if (patchResults.some(applied => !applied)) {
      console.error("Undo patch application failed. Results:", patchResults);
      // State might be inconsistent. You might want to try to recover or log.
      debugger; // eslint-disable-line no-debugger
      return null;
    }

    this.currentNode = this.currentNode.parent;
    this.currentFullState = this._deserialize(parentStateText);
    return this.currentFullState;
  }

  canRedo() {
    const children = this.currentNode.children;
    const num = children.length;
    if (num == 0) return false;
    if (num > 1) return num;
    const child0 = children[0];
    // debugger; // eslint-disable-line no-debugger
    const actionTopic = child0.actionTopic;
    return actionTopic;
  }
  /**
   * Redo the last undone action, returning the new state.
   * @returns {Promise<any>} The state after redoing
   */
  async redo() {
    logClass("redo()");
    const currentNode = this.currentNode;
    if (!this.canRedo()) {
      throw Error("Nothing to redo.");
      return null;
    }

    const defaultBranchIndex = this.currentNode.currentBranchIndex || 0;
    let branchIndex = defaultBranchIndex;
    if (this.funBranch) {
      const arrChildTopics = this.currentNode.children.map(c => c.actionTopic);
      const idxFun = await this.funBranch(defaultBranchIndex, arrChildTopics);
      if (!Number.isInteger(idxFun)) {
        throw Error(`funBranch returned non-integer: ${idxFun}`);
      }
      // @ts-ignore -- ts bug
      if (idxFun < 0 || idxFun >= this.currentNode.children.length) {
        throw Error(`Invalid branch index returned by funBranch: ${idxFun}`);
      }
      branchIndex = (typeof idxFun === "number" && idxFun !== null) ? idxFun : defaultBranchIndex;
    }
    const childNodeToRedoTo = currentNode.children[branchIndex];
    const patchesToApplyForRedo = childNodeToRedoTo.patchesToReach;

    if (!patchesToApplyForRedo) {
      console.error("Error: Target child node is missing 'patchesToReach'.");
      return null;
    }

    const currentStateText = this._serialize(this.currentFullState);
    const [nextStateText, patchResults] = this.dmp.patch_apply(patchesToApplyForRedo, currentStateText);

    if (patchResults.some(applied => !applied)) {
      console.error("Redo patch application failed. Results:", patchResults);
      return null;
    }

    this.currentNode = childNodeToRedoTo;
    this.currentFullState = this._deserialize(nextStateText);
    return this.currentFullState;
  }

  // To get the state of an arbitrary node (can be expensive for deep trees)
  // This reconstructs the state by applying patches from the root.
  getStateOfNode(targetNode) {
    if (!targetNode) return null;
    if (targetNode === this.rootNode) {
      return this._deepCopy(this.rootNode.fullStateSnapshot);
    }
    return targetNode.fullState; // FIX-ME: this bypasses dmp, test better later

    const path = [];
    let temp = targetNode;
    while (temp && temp.parent) { // Go up to root
      path.unshift(temp); // Add to front to get path from root
      temp = temp.parent;
    }

    if (temp !== this.rootNode) {
      console.error("Target node is not part of this tree or tree is corrupted.");
      return null;
    }

    let reconstructedState = this._deepCopy(this.rootNode.fullStateSnapshot);

    for (const nodeOnPath of path) {
      const patches = nodeOnPath.patchesToReach;
      if (!patches) {
        console.error("Node on path is missing patchesToReach:", nodeOnPath.id);
        return null; // Or throw error
      }
      const currentStateText = this._serialize(reconstructedState);
      const [nextStateText, results] = this.dmp.patch_apply(patches, currentStateText);
      if (results.some(r => !r)) {
        console.error("Patch application failed during state reconstruction for node:", nodeOnPath.id, results);
        return null; // Or throw error
      }
      reconstructedState = this._deserialize(nextStateText);
      if (reconstructedState === null) { // Deserialization failed
        console.error("Deserialization failed during state reconstruction for node:", nodeOnPath.id);
        return null;
      }
    }
    return reconstructedState;
  }

  // Utility to jump to a specific node if you have its reference
  navigateToNode(historyNode) {
    const state = this.getStateOfNode(historyNode);
    if (state !== null) {
      this.currentNode = historyNode;
      this.currentFullState = state;
      return this.currentFullState;
    }
    console.error("Could not navigate to node.");
    throw Error("Could not navigate to node.");
    return null;
  }

  /*
   * Get a list of possible redo actions from the current node.
   * @return {Array<{action: string, branchIndex: number, nodeId: string}>}
   */
  /*
  getPossibleRedoActions() {
    return this.currentNode.children.map((child, index) => ({
      action: child.action,
      branchIndex: index,
      nodeId: child.id
    }));
  }
  */
}
//// END: Code suggestions for tree from Google Gemini AI
////////////////////////////////////////////



export function addUndoRedo(key, appState, funBranch, funHistory) {
  // debugger; // eslint-disable-line no-debugger
  logClass("addHistoryKey()", key);
  histories[key] = new UndoRedoTreeWithDiff(appState, funBranch, key, funHistory);
}
export function hasUndoRedo(key) {
  const history = histories[key];
  return !!history;
}

export function resetHistory(key) {
  // FIX-ME: free up old history???
  delete histories[key];
}

export function getHistory(key) {
  const history = histories[key];
  if (!history) {
    throw Error(`No history found for key: ${key}`);
  }
  return history;
}

export function logHistoryTree(key) {
  const history = getHistory(key);
  history.logTreeStructure();
}
export function mapHistoryTree(key, fun) {
  const tofFun = typeof fun;
  if (tofFun != "function") throw Error(`parameter fun should be "function", was "${tofFun}"`);
  const funLen = fun.length;
  if (funLen != 3) throw Error(`Parameter function fun should take 3 args, but takes ${funLen} args`);
  const history = getHistory(key);
  history.startWalkTree(fun);
}

/**
 * 
 * @param {string} key 
 * @param {Object} newFullState 
 * @param {string} actionTopic 
 * @returns 
 */
export async function actionRecordAction(key, newFullState, actionTopic) {
  const history = getHistory(key);
  return history.recordAction(newFullState, actionTopic);
}

/**
 * @param {string} key
 * @return {undefined|string} - action topic of the current node
 */
export function canUndo(key) {
  const history = getHistory(key);
  return history.canUndo();
}
export function actionUndo(key) {
  const history = getHistory(key);
  const undoRedoState = history.undo();
  if (!undoRedoState) {
    console.error("undoRedoState is null");
    debugger; // eslint-disable-line no-debugger
  }
  return undoRedoState;
}

/**
 * @param {string} key
 * @return {boolean}
 */
export function canRedo(key) {
  const history = getHistory(key);
  return history.canRedo();
}
export async function actionRedo(key) {
  // debugger; // eslint-disable-line no-debugger
  const history = getHistory(key);
  return history.redo();
}

////////////////////////////////////////////
// Basic tests

_doSomeTests();
async function _doSomeTests() {
  ////// All tests passed in version "0.0.001"
  // await _basicTest({}); // linear
  // await _basicTest({ ourUndoRedo: true }); // linear
  // await _basicTest({ funBranch: _ourFunBranch }); // branched
  // await _basicTest({ funBranch: _ourFunBranch, ourUndoRedo: true }); // branched

  /**
   * @param {number} defaultBranch 
   * @param {string[]} arrBrancheTopics 
   * @returns {Promise<number>}
   */
  async function _ourFunBranch(defaultBranch, arrBrancheTopics) {
    // debugger; // eslint-disable-line no-debugger
    if (!Number.isInteger(defaultBranch) || defaultBranch < 0) { throw Error(`Invalid defaultBranch "${defaultBranch}"`); }
    console.log(`  ourFunBranch called with defaultBranch: ${defaultBranch}, arrBranches:`, arrBrancheTopics);
    const importFc4i = window["importFc4i"];
    const modTools = await importFc4i("toolsJs");
    await modTools.waitSeconds(0.5); // Simulate some delay
    const branch = defaultBranch;
    const topic = arrBrancheTopics[branch];
    if (!topic) {
      debugger; // eslint-disable-line no-debugger
      throw Error(`No topic found for branch ${branch}`);
    }
    console.log(`  will redo "${topic}", branch: ${branch}`);
    return branch; // Always return the default branch for now
  }



  async function _basicTest(opts) {
    console.log("%c_basicTest", "font-size:20px; color:white; background:blue; padding:2px; border-radius:2px;");

    const tofOpts = typeof opts;
    if (tofOpts !== "object") {
      throw Error(`Invalid opts type: ${tofOpts}, expected "object"`);
    }
    if (Array.isArray(opts)) {
      throw Error(`Invalid opts type: Array, expected "object"`);
    }
    if (opts === null) {
      throw Error(`Invalid opts type: null, expected "object"`);
    }
    const validKeys = ["funBranch", "ourUndoRedo"];
    for (const key in opts) {
      if (!validKeys.includes(key)) {
        throw Error(`Invalid key in opts: ${key}, expected one of ${validKeys.join(", ")}`);
      }
    }

    const funBranch = opts.funBranch || undefined;
    const ourUndoRedo = opts.ourUndoRedo || false;

    let alreayCalledLogTreeStructure = false;
    let appState = { message: "state0" };

    let history;
    // history = new UndoRedoTreeWithDiff(appState, funBranch);
    doCreateHistory();
    updateMyAppUI(appState);
    const state0 = deepCopy4test(appState);

    // Action 1
    appState.message = "state1";
    // history.recordAction(appState, "Action 1");
    doRecordAction(appState, "Action 1");
    updateMyAppUI(appState);
    const state1 = deepCopy4test(appState);
    assertObjectEqual("After Action 1", appState, state1);

    // Action 2
    appState.message = "state2";
    // history.recordAction(appState, "Action 2");
    doRecordAction(appState, "Action 2");
    updateMyAppUI(appState);
    const state2 = deepCopy4test(appState);
    assertObjectEqual("After Action 2", appState, state2);

    // Undo Action 2
    // appState = history.undo();
    appState = doUndo();
    if (appState) updateMyAppUI(appState);
    assertObjectEqual("After undo Action 2", appState, state1);

    // Undo Action 1
    // appState = history.undo();
    appState = doUndo();
    if (appState) updateMyAppUI(appState);
    assertObjectEqual("After undo Action 1", appState, state0);


    // Redo Action 1
    appState = await doRedo();
    if (appState) updateMyAppUI(appState);
    assertObjectEqual("After redo Action 1", appState, state1);

    // Now, let's create a new node from here
    let branchedState = JSON.parse(jsonStringifySorted(appState)); // Important to copy
    // branchedState.message = history.isTreeStructured ? "New Branch!" : "New Linear!";
    branchedState.message = doIsTreeStructured() ? "New Branch!" : "New Linear!";

    // debugger; // eslint-disable-line no-debugger
    // history.recordAction(branchedState, "new node from state 1");
    doRecordAction(branchedState, "new node from state 1");
    appState = branchedState; // Update our main appState variable
    updateMyAppUI(appState);
    const stateB0 = deepCopy4test(appState);
    assertObjectEqual("After new node from state 1", appState, stateB0);

    // If we undo now:
    // appState = history.undo();
    appState = doUndo();
    if (appState) updateMyAppUI(appState);
    assertObjectEqual("After if we undo now", appState, state1);

    // redo, add a new node:
    // debugger; // eslint-disable-line no-debugger
    appState = await doRedo();
    if (appState) updateMyAppUI(appState);
    if (doIsTreeStructured()) {
      assertObjectEqual("After redo, add a new node", appState, stateB0);
    } else {
      assertObjectEqual("After redo, add a new node", appState, stateB0);
    }

    // To access the old Action 2 (counter: 15):
    // 1. Undo twice to get to root.
    // 2. Redo to state after Action 1.
    // 3. Now, the node for "Action 1" would have two children.
    //    You would need to call redo with the correct branchIndex.
    // console.log("Parent of current:", history.currentNode.parent);
    // console.log("Available redo branches from previous state:", history.currentNode.parent.children.map(c => c.action));

    // Example of checking branches (after undoing to the fork point):
    // history.undo(); // appState is now { counter: 10, message: "First action" }
    // const branches = history.getPossibleRedoActions();
    // console.log("Possible redo actions:", branches);
    // /* This would show something like:
    // [
    //   { action: "Incremented counter again", branchIndex: 0, nodeId: ... },
    //   { action: "Created a new branch from state 1", branchIndex: 1, nodeId: ... }
    // ]
    // */
    // // To go down the first original branch:
    // // appState = history.redo(0);
    // // updateMyAppUI(appState); // { counter: 15, message: "First action" }





    function assertObjectEqual(where, actual, expected) {
      if (JSON.stringify(actual) !== JSON.stringify(expected)) {
        console.error("%cNot equal", "color:white; background:red; padding:2px; font-size:1.2em", `${where}: ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
      } else {
        console.log("%cequal:", "color:white; background:green; padding:2px; font-size:1.2em", `${where}: ${JSON.stringify(actual)}`);
        return;
        if (alreayCalledLogTreeStructure) return;
        alreayCalledLogTreeStructure = true;
        setTimeout(() => {
          const history = doHistory();
          history.logTreeStructure();
        }, 1000);
      }
    }

    function deepCopy4test(obj) { return JSON.parse(JSON.stringify(obj)); }
    function updateMyAppUI(_state) {
      // console.log("UI Updated:", JSON.stringify(state));
    }



    function doKey() {
      Object.keys(histories).join(", "); // Just testing...
      return "the-do-key";
    }
    function doHistory() {
      // if (history) { throw Error("history was set in doHistory"); }
      if (ourUndoRedo) {
        const key = doKey();
        const ourHistory = histories[key];
        if (!ourHistory) { throw Error(`No history found for key: ${key}`); }
        return ourHistory;
      }
      return history;
    }
    function doCreateHistory() {
      if (ourUndoRedo) {
        const key = doKey();
        addUndoRedo(key, appState, funBranch);
        doHistory(); // Just check it is created
        return;
      }
      history = new UndoRedoTreeWithDiff(appState, funBranch);
    }
    function doUndo() {
      if (ourUndoRedo) {
        return actionUndo(doKey());
      }
      return history.undo();
    }
    async function doRedo() {
      if (ourUndoRedo) {
        return actionRedo(doKey());
      }
      return history.redo();
    }
    function doRecordAction(state, action) {
      if (ourUndoRedo) {
        actionRecordAction(doKey(), state, action);
        return;
      }
      history.recordAction(state, action);
    }
    function doIsTreeStructured() {
      if (ourUndoRedo) {
        return getHistory(doKey()).isTreeStructured;
      }
      return history.isTreeStructured;
    }

  }
}

// @ts-check
const UNDO_REDO_TREE_VERSION = "0.0.00";
window["logConsoleHereIs"](`here is db-mindmaps.js, module ${UNDO_REDO_TREE_VERSION}`);
if (document.currentScript) throw Error("import .currentScript"); // is module

if ("function" !== typeof diff_match_patch) {
  throw Error("Google diff_match_patch is not loaded, please import it before this module");
}


////////////////////////////////////////////
//// Code suggestions from Google Gemini AI:
export class HistoryNode {
  constructor(parent, patchesToReachThisNode, patchesToUndoThisNode, action = null) {
    this.parent = parent; // Reference to the parent node
    this.children = [];   // Array of child nodes (branches)

    // Patches generated by diff_match_patch
    this.patchesToReach = patchesToReachThisNode; // Patches to apply to PARENT's state to get THIS node's state
    this.patchesToUndo = patchesToUndoThisNode;   // Patches to apply to THIS node's state to get PARENT's state

    this.action = action; // Optional: Description of the action
    this.id = Date.now() + Math.random().toString(36).substring(2); // A simple unique ID for debugging or advanced navigation
  }

  addChild(patchesToReach, patchesToUndo, action) {
    const newNode = new HistoryNode(this, patchesToReach, patchesToUndo, action);
    this.children.push(newNode);
    return newNode;
  }
}

export class UndoRedoTreeWithDiff {
  constructor(initialState) {
    this.dmp = new diff_match_patch();

    // The root node stores the full initial state directly, as it has no parent/patches.
    this.rootNode = new HistoryNode(null, null, null, "Initial State");
    // We'll store the actual state on the root node because it's the base.
    this.rootNode.fullStateSnapshot = this._deepCopy(initialState);

    this.currentNode = this.rootNode;
    // This holds the fully rehydrated state of `this.currentNode`.
    this.currentFullState = this._deepCopy(initialState);
  }

  _serialize(state) {
    // Ensure consistent serialization, e.g., by sorting keys if order doesn't matter
    // but can affect diffs. For simple JSON, stringify is usually enough.
    return JSON.stringify(state);
  }

  _deserialize(stateString) {
    try {
      return JSON.parse(stateString);
    } catch (e) {
      console.error("Error deserializing state:", e, stateString);
      // Graceful error handling: return null or throw, depending on application needs
      return null;
    }
  }

  _deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  recordAction(newFullState, actionDetails = null) {
    const oldStateText = this._serialize(this.currentFullState);
    const newStateText = this._serialize(newFullState);

    if (oldStateText === newStateText) {
      console.log("No change in state, not recording.");
      return; // Nothing to record
    }

    // Create patches to go from old state to new state
    const patchesToReachNew = this.dmp.patch_make(oldStateText, newStateText);
    // Create patches to go from new state back to old state (for undo)
    const patchesToUndoNew = this.dmp.patch_make(newStateText, oldStateText);

    // If the current node has children, performing a new action might mean
    // abandoning other branches for the default redo path.
    // For now, we'll just add a new child.
    // Pruning or managing 'active' redo branches can be added if needed.
    // Example: this.currentNode.children = []; // If new action prunes old redo branches

    const newNode = this.currentNode.addChild(patchesToReachNew, patchesToUndoNew, actionDetails);
    this.currentNode = newNode;
    this.currentFullState = this._deepCopy(newFullState); // Update the materialized state
  }

  undo() {
    if (!this.currentNode.parent) {
      console.log("Already at root. Nothing to undo.");
      return null;
    }

    const patchesToApplyForUndo = this.currentNode.patchesToUndo;
    if (!patchesToApplyForUndo) {
      console.error("Error: Current node is missing 'patchesToUndo'.");
      return null;
    }

    const currentStateText = this._serialize(this.currentFullState);
    const [parentStateText, patchResults] = this.dmp.patch_apply(patchesToApplyForUndo, currentStateText);

    if (patchResults.some(applied => !applied)) {
      console.error("Undo patch application failed. Results:", patchResults);
      // State might be inconsistent. You might want to try to recover or log.
      return null;
    }

    this.currentNode = this.currentNode.parent;
    this.currentFullState = this._deserialize(parentStateText);
    return this.currentFullState;
  }

  redo(branchIndex = 0) { // Default to the first child (most common redo path)
    if (this.currentNode.children.length === 0 || !this.currentNode.children[branchIndex]) {
      console.log("No child to redo to on this branch or invalid branch index.");
      return null;
    }

    const childNodeToRedoTo = this.currentNode.children[branchIndex];
    const patchesToApplyForRedo = childNodeToRedoTo.patchesToReach;

    if (!patchesToApplyForRedo) {
      console.error("Error: Target child node is missing 'patchesToReach'.");
      return null;
    }

    const currentStateText = this._serialize(this.currentFullState);
    const [nextStateText, patchResults] = this.dmp.patch_apply(patchesToApplyForRedo, currentStateText);

    if (patchResults.some(applied => !applied)) {
      console.error("Redo patch application failed. Results:", patchResults);
      return null;
    }

    this.currentNode = childNodeToRedoTo;
    this.currentFullState = this._deserialize(nextStateText);
    return this.currentFullState;
  }

  // To get the state of an arbitrary node (can be expensive for deep trees)
  // This reconstructs the state by applying patches from the root.
  getStateOfNode(targetNode) {
    if (!targetNode) return null;
    if (targetNode === this.rootNode) {
      return this._deepCopy(this.rootNode.fullStateSnapshot);
    }

    const path = [];
    let temp = targetNode;
    while (temp && temp.parent) { // Go up to root
      path.unshift(temp); // Add to front to get path from root
      temp = temp.parent;
    }

    if (temp !== this.rootNode) {
      console.error("Target node is not part of this tree or tree is corrupted.");
      return null;
    }

    let reconstructedState = this._deepCopy(this.rootNode.fullStateSnapshot);

    for (const nodeOnPath of path) {
      const patches = nodeOnPath.patchesToReach;
      if (!patches) {
        console.error("Node on path is missing patchesToReach:", nodeOnPath.id);
        return null; // Or throw error
      }
      const currentStateText = this._serialize(reconstructedState);
      const [nextStateText, results] = this.dmp.patch_apply(patches, currentStateText);
      if (results.some(r => !r)) {
        console.error("Patch application failed during state reconstruction for node:", nodeOnPath.id, results);
        return null; // Or throw error
      }
      reconstructedState = this._deserialize(nextStateText);
      if (reconstructedState === null) { // Deserialization failed
        console.error("Deserialization failed during state reconstruction for node:", nodeOnPath.id);
        return null;
      }
    }
    return reconstructedState;
  }

  // Utility to jump to a specific node if you have its reference
  navigateToNode(node) {
    const state = this.getStateOfNode(node);
    if (state !== null) {
      this.currentNode = node;
      this.currentFullState = state;
      return this.currentFullState;
    }
    console.warn("Could not navigate to node.");
    return null;
  }

  getPossibleRedoActions() {
    return this.currentNode.children.map((child, index) => ({
      action: child.action,
      branchIndex: index,
      nodeId: child.id
    }));
  }
}

export function getUndoRedoTreeVersion() {
  return UNDO_REDO_TREE_VERSION;
}

////////////////////////////////////////////
// Basic tests from AI
function _basicTestAI() {
  // --- Assuming HistoryNode and UndoRedoTreeWithDiff classes are defined above ---
  // --- And diff_match_patch.js is loaded and `dmp` is available or instantiated in the class ---
  let appState = { counter: 0, message: "Start" };

  function updateMyAppUI(state) {
    console.log("UI Updated:", JSON.stringify(state));
    // In a real app, you'd update your DOM or framework components here
  }

  const history = new UndoRedoTreeWithDiff(appState);
  updateMyAppUI(appState);

  // Action 1
  appState.counter = 10;
  appState.message = "First action";
  history.recordAction(appState, "Incremented counter, changed message");
  updateMyAppUI(appState);

  // Action 2
  appState.counter = 15;
  history.recordAction(appState, "Incremented counter again");
  updateMyAppUI(appState);

  // Undo Action 2
  appState = history.undo();
  if (appState) updateMyAppUI(appState); // Back to: { counter: 10, message: "First action" }

  // Undo Action 1
  appState = history.undo();
  if (appState) updateMyAppUI(appState); // Back to: { counter: 0, message: "Start" }

  // Redo Action 1
  appState = history.redo(); // Assuming redo follows the main branch (branchIndex 0)
  if (appState) updateMyAppUI(appState); // Back to: { counter: 10, message: "First action" }

  // Now, let's create a new branch from here
  let branchedState = JSON.parse(JSON.stringify(appState)); // Important to copy
  branchedState.message = "New Branch!";
  branchedState.user = "BranchUser";
  history.recordAction(branchedState, "Created a new branch from state 1");
  appState = branchedState; // Update our main appState variable
  updateMyAppUI(appState);
  // At this point, the old "Action 2" (counter: 15) is on a different, now dormant, branch.

  // If we undo now:
  appState = history.undo();
  if (appState) updateMyAppUI(appState); // Back to: { counter: 10, message: "First action" }

  // If we redo, we go along the new branch:
  appState = history.redo();
  if (appState) updateMyAppUI(appState); // Back to: { counter: 10, message: "New Branch!", user: "BranchUser" }

  // To access the old Action 2 (counter: 15):
  // 1. Undo twice to get to root.
  // 2. Redo to state after Action 1.
  // 3. Now, the node for "Action 1" would have two children.
  //    You would need to call redo with the correct branchIndex.
  // console.log("Parent of current:", history.currentNode.parent);
  // console.log("Available redo branches from previous state:", history.currentNode.parent.children.map(c => c.action));

  // Example of checking branches (after undoing to the fork point):
  // history.undo(); // appState is now { counter: 10, message: "First action" }
  // const branches = history.getPossibleRedoActions();
  // console.log("Possible redo actions:", branches);
  // /* This would show something like:
  // [
  //   { action: "Incremented counter again", branchIndex: 0, nodeId: ... },
  //   { action: "Created a new branch from state 1", branchIndex: 1, nodeId: ... }
  // ]
  // */
  // // To go down the first original branch:
  // // appState = history.redo(0);
  // // updateMyAppUI(appState); // { counter: 15, message: "First action" }
}
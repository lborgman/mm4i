// @ts-check
const UNDO_REDO_TREE_VERSION = "0.0.001";
window["logConsoleHereIs"](`here is undo-redo-tree.js, module ${UNDO_REDO_TREE_VERSION}`);
console.warn(`here is undo-redo-tree.js, module ${UNDO_REDO_TREE_VERSION}`);
if (document.currentScript) throw Error("import .currentScript"); // is module

if (typeof window["diff_match_patch"] !== "function") {
  throw Error("Google diff_match_patch is not loaded, please import it before this module");
}

export function getUndoRedoTreeVersion() { return UNDO_REDO_TREE_VERSION; }
const logClassStyle = "background:white; color:blue; padding:2px; border-radius:2px;";
const logClassImportantStyle = logClassStyle + " font-size:18px;";
function logClass(what, ...msg) { console.log(`%c${what}`, logClassStyle, ...msg); }
function logClassImportant(what, ...msg) { console.log(`%c${what}`, logClassImportantStyle, ...msg); }





const histories = {};

////////////////////////////////////////////
//// START: Code suggestions for tree from Google Gemini AI (heavily modified):
export class HistoryTreeNode {
  /**
   * @param {UndoRedoTreeWithDiff} objUndoRedo 
   * @param {HistoryTreeNode|null} parent 
   * @param {Object} patchesToReachThisNode 
   * @param {Object} patchesToUndoThisNode 
   * @param {string} actionTopic 
   */
  constructor(objUndoRedo, parent, patchesToReachThisNode, patchesToUndoThisNode, actionTopic) {
    this.objUndoRedo = objUndoRedo; // Reference to the UndoRedoTreeWithDiff instance
    this.parent = parent; // Reference to the parent node
    this.children = [];   // Array of child nodes (branches)

    // Patches generated by diff_match_patch
    this.patchesToReach = patchesToReachThisNode; // Patches to apply to PARENT's state to get THIS node's state
    this.patchesToUndo = patchesToUndoThisNode;   // Patches to apply to THIS node's state to get PARENT's state

    if (typeof actionTopic !== "string") {
      throw Error(`Invalid action type: ${typeof actionTopic}, expected "string" or null`);
    }
    this.actionTopic = actionTopic; // Optional: Description of the action
    this.id = Date.now() + Math.random().toString(36).substring(2); // A simple unique ID for debugging or advanced navigation
  }

  /**
   * @type {any}
   */
  fullStateSnapshot = undefined; // FIX-ME: ??

  /**
   * Adds a child node to this node, representing a new action in the history.
   * @param {Object[]} patchesToReach - Patches to apply to the parent node's state to reach this new child node's state.
   * @param {Object[]} patchesToUndo - Patches to apply to this child node's state to undo back to the parent node's state.
   * @param {string} actionTopic - Description of the action that led to this new child node.
   * @returns {HistoryTreeNode} The newly created child node.
   */
  addChild(patchesToReach, patchesToUndo, actionTopic) {
    if (!this.objUndoRedo.isTreeStructured) {
      this.children.length = 0; // Clear existing children if linear
    }
    const newNode = new HistoryTreeNode(this.objUndoRedo, this, patchesToReach, patchesToUndo, actionTopic);
    this.children.push(newNode);
    this.currentBranchIndex = this.children.length - 1; // Update current branch index to the new child
    return newNode;
  }
}

const diff_match_patch = window["diff_match_patch"];
export class UndoRedoTreeWithDiff {
  #treeStructured = false;
  /**
   * @param {any} initialState - string or json object representing the initial state of the application.
   * @param {(defaultBranch: number, arrBranches: string[]) => number | null} [funBranch]
   */
  constructor(initialState, funBranch = undefined) {
    let txtLinOrTree = "ERROR";
    if (funBranch == null) {
      this.#treeStructured = false;
      txtLinOrTree = "**LINEAR**";
      // logClassImportant("UndoRedoTreeWithDiff", "Using linear undo/redo structure");
    } else {
      this.#treeStructured = true;
      txtLinOrTree = "**BRANCH**";
      // logClassImportant("UndoRedoTreeWithDiff", "Using tree undo/redo structure");
      this.funBranch = funBranch; // Function to handle branching logic
      const tofFunBranch = typeof funBranch;
      if (tofFunBranch !== "function") {
        throw Error(`Invalid funBranch type: ${tofFunBranch}, expected "function"`);
      }
      if (funBranch.constructor.name !== "AsyncFunction") {
        throw Error(`funBranch is not async`);
      }
      const lenFunBranch = funBranch.length;
      if (lenFunBranch !== 2) {
        throw Error(`Invalid funBranch length: ${lenFunBranch}, expected 2`);
      }
    }
    logClassImportant("UndoRedoTreeWithDiff", txtLinOrTree, initialState);
    this.dmp = new diff_match_patch();

    // The root node stores the full initial state directly, as it has no parent/patches.
    this.rootNode = new HistoryTreeNode(this, null, null, null, "Initial State");
    // We'll store the actual state on the root node because it's the base.
    this.rootNode.fullStateSnapshot = this._deepCopy(initialState);

    this.currentNode = this.rootNode;
    // This holds the fully rehydrated state of `this.currentNode`.
    this.currentFullState = this._deepCopy(initialState);
  }

  _logTreeStructure() {
    const linearOrTree = this.isTreeStructured ? "Tree" : "Linear";
    logClass(`Current tree structure (${linearOrTree}):`);
    // debugger; // eslint-disable-line no-debugger
    const current = this.currentNode;
    const traverse = (node, depth = 0) => {
      const markCurrent = (node === current) ? "> " : "";
      const styleCurrent = (node === current) ? "background:darkblue;color:white;" : "";
      console.log("%c" + "  ".repeat(depth) + `${markCurrent}Node ID: ${node.id}, Action: ${node.action || "N/A"} `, styleCurrent);
      if (node.children.length > 0) {
        node.children.forEach(child => traverse(child, depth + 1));
      }
    }
    traverse(this.rootNode);
  }

  _serialize(state) {
    // Ensure consistent serialization, e.g., by sorting keys if order doesn't matter
    // but can affect diffs. For simple JSON, stringify is usually enough.
    return JSON.stringify(state);
  }

  _deserialize(stateString) {
    try {
      return JSON.parse(stateString);
    } catch (e) {
      console.error("Error deserializing state:", e, stateString);
      // Graceful error handling: return null or throw, depending on application needs
      return null;
    }
  }

  _deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  get isTreeStructured() {
    return this.#treeStructured;
  }

  /**
   * 
   * @param {any} newFullState -- string or json object representing the new state of the application.
   * @param {string} actionTopic 
   * @returns 
   */
  recordAction(newFullState, actionTopic) {
    logClass("recordAction()", newFullState, actionTopic);
    const oldStateText = this._serialize(this.currentFullState);
    const newStateText = this._serialize(newFullState);

    if (oldStateText === newStateText) {
      console.log("No change in state, not recording.");
      return; // Nothing to record
    }

    // Create patches to go from old state to new state
    const patchesToReachNew = this.dmp.patch_make(oldStateText, newStateText);
    // Create patches to go from new state back to old state (for undo)
    const patchesToUndoNew = this.dmp.patch_make(newStateText, oldStateText);

    // If the current node has children, performing a new action might mean
    // abandoning other branches for the default redo path.
    // For now, we'll just add a new child.
    // Pruning or managing 'active' redo branches can be added if needed.
    // Example: this.currentNode.children = []; // If new action prunes old redo branches

    const newNode = this.currentNode.addChild(patchesToReachNew, patchesToUndoNew, actionTopic);
    this.currentNode = newNode;
    this.currentFullState = this._deepCopy(newFullState); // Update the materialized state
  }

  canUndo() { return !!this.currentNode.parent; }
  /**
   * Undo the last action, returning the previous state.
   * @returns {any} The state after undoing
   */
  undo() {
    logClass("undo()");
    if (!this.canUndo()) {
      console.log("Already at root. Nothing to undo.");
      return null;
    }

    const patchesToApplyForUndo = this.currentNode.patchesToUndo;
    if (!patchesToApplyForUndo) {
      console.error("Error: Current node is missing 'patchesToUndo'.");
      return null;
    }

    const currentStateText = this._serialize(this.currentFullState);
    const [parentStateText, patchResults] = this.dmp.patch_apply(patchesToApplyForUndo, currentStateText);

    if (patchResults.some(applied => !applied)) {
      console.error("Undo patch application failed. Results:", patchResults);
      // State might be inconsistent. You might want to try to recover or log.
      return null;
    }

    this.currentNode = this.currentNode.parent;
    this.currentFullState = this._deserialize(parentStateText);
    return this.currentFullState;
  }

  async canRedo() { return this.currentNode.children.length > 0; }
  /**
   * Redo the last undone action, returning the new state.
   * @returns {Promise<any>} The state after redoing
   */
  async redo() {
    logClass("redo()");
    const currentNode = this.currentNode;
    if (!this.canRedo()) {
      throw Error("Nothing to redo.");
      return null;
    }

    const defaultBranchIndex = this.currentNode.currentBranchIndex || 0;
    let branchIndex = defaultBranchIndex;
    if (this.funBranch) {
      const arrChildTopics = this.currentNode.children.map(c => c.actionTopic);
      const idxFun = await this.funBranch(defaultBranchIndex, arrChildTopics);
      if (!Number.isInteger(idxFun)) {
        throw Error(`funBranch returned non-integer: ${idxFun}`);
      }
      // @ts-ignore -- ts bug
      if (idxFun < 0 || idxFun >= this.currentNode.children.length) {
        throw Error(`Invalid branch index returned by funBranch: ${idxFun}`);
      }
      branchIndex = (typeof idxFun === "number" && idxFun !== null) ? idxFun : defaultBranchIndex;
    }
    const childNodeToRedoTo = currentNode.children[branchIndex];
    const patchesToApplyForRedo = childNodeToRedoTo.patchesToReach;

    if (!patchesToApplyForRedo) {
      console.error("Error: Target child node is missing 'patchesToReach'.");
      return null;
    }

    const currentStateText = this._serialize(this.currentFullState);
    const [nextStateText, patchResults] = this.dmp.patch_apply(patchesToApplyForRedo, currentStateText);

    if (patchResults.some(applied => !applied)) {
      console.error("Redo patch application failed. Results:", patchResults);
      return null;
    }

    this.currentNode = childNodeToRedoTo;
    this.currentFullState = this._deserialize(nextStateText);
    return this.currentFullState;
  }

  // To get the state of an arbitrary node (can be expensive for deep trees)
  // This reconstructs the state by applying patches from the root.
  getStateOfNode(targetNode) {
    if (!targetNode) return null;
    if (targetNode === this.rootNode) {
      return this._deepCopy(this.rootNode.fullStateSnapshot);
    }

    const path = [];
    let temp = targetNode;
    while (temp && temp.parent) { // Go up to root
      path.unshift(temp); // Add to front to get path from root
      temp = temp.parent;
    }

    if (temp !== this.rootNode) {
      console.error("Target node is not part of this tree or tree is corrupted.");
      return null;
    }

    let reconstructedState = this._deepCopy(this.rootNode.fullStateSnapshot);

    for (const nodeOnPath of path) {
      const patches = nodeOnPath.patchesToReach;
      if (!patches) {
        console.error("Node on path is missing patchesToReach:", nodeOnPath.id);
        return null; // Or throw error
      }
      const currentStateText = this._serialize(reconstructedState);
      const [nextStateText, results] = this.dmp.patch_apply(patches, currentStateText);
      if (results.some(r => !r)) {
        console.error("Patch application failed during state reconstruction for node:", nodeOnPath.id, results);
        return null; // Or throw error
      }
      reconstructedState = this._deserialize(nextStateText);
      if (reconstructedState === null) { // Deserialization failed
        console.error("Deserialization failed during state reconstruction for node:", nodeOnPath.id);
        return null;
      }
    }
    return reconstructedState;
  }

  // Utility to jump to a specific node if you have its reference
  navigateToNode(node) {
    const state = this.getStateOfNode(node);
    if (state !== null) {
      this.currentNode = node;
      this.currentFullState = state;
      return this.currentFullState;
    }
    console.warn("Could not navigate to node.");
    return null;
  }

  /*
   * Get a list of possible redo actions from the current node.
   * @return {Array<{action: string, branchIndex: number, nodeId: string}>}
   */
  /*
  getPossibleRedoActions() {
    return this.currentNode.children.map((child, index) => ({
      action: child.action,
      branchIndex: index,
      nodeId: child.id
    }));
  }
  */
}
//// END: Code suggestions for tree from Google Gemini AI
////////////////////////////////////////////


// export function actionAdd(_key, _initialValue, _actionDetails) { }
// export function actionRemove(_key) { }

export function addUndoRedo(_key, appState, funBranch) {
  // debugger; // eslint-disable-line no-debugger
  logClass("addHistoryKey()", _key);
  histories[_key] = new UndoRedoTreeWithDiff(appState, funBranch);
}
export function hasUndoRedo(_key) {
  const history = histories[_key];
  return !!history;
}

function getHistory(_key) {
  const history = histories[_key];
  if (!history) {
    throw Error(`No history found for key: ${_key}`);
  }
  return history;
}

/**
 * 
 * @param {string} key 
 * @param {Object} newFullState 
 * @param {string} actionTopic 
 * @returns 
 */
export async function actionRecordAction(key, newFullState, actionTopic) {
  const history = getHistory(key);
  return history.recordAction(newFullState, actionTopic);
}

/**
 * @param {string} key
 * @return {boolean}
 */
export function canUndo(key) {
  const history = getHistory(key);
  return history.canUndo();
}
export function actionUndo(key) {
  const history = getHistory(key);
  return history.undo();
}
export async function actionRedo(_key) {
  // debugger; // eslint-disable-line no-debugger
  const history = getHistory(_key);
  return history.redo();
}

////////////////////////////////////////////
// Basic tests

_doSomeTests();
async function _doSomeTests() {
  ////// All tests passed in version "0.0.001"
  // await _basicTest({}); // linear
  // await _basicTest({ ourUndoRedo: true }); // linear
  await _basicTest({ funBranch: _ourFunBranch }); // branched
  // await _basicTest({ funBranch: _ourFunBranch, ourUndoRedo: true }); // branched

  /**
   * @param {number} defaultBranch 
   * @param {string[]} arrBrancheTopics 
   * @returns {Promise<number>}
   */
  async function _ourFunBranch(defaultBranch, arrBrancheTopics) {
    // debugger;
    if (!Number.isInteger(defaultBranch) || defaultBranch < 0) { throw Error(`Invalid defaultBranch "${defaultBranch}"`); }
    console.log(`  ourFunBranch called with defaultBranch: ${defaultBranch}, arrBranches:`, arrBrancheTopics);
    const importFc4i = window["importFc4i"];
    const modTools = await importFc4i("toolsJs");
    await modTools.waitSeconds(0.5); // Simulate some delay
    const branch = defaultBranch;
    const topic = arrBrancheTopics[branch];
    if (!topic) {
      debugger;
      throw Error(`No topic found for branch ${branch}`);
    }
    console.log(`  will redo "${topic}", branch: ${branch}`);
    return branch; // Always return the default branch for now
  }



  async function _basicTest(opts) {
    console.log("%c_basicTest", "font-size:20px; color:white; background:blue; padding:2px; border-radius:2px;");

    const tofOpts = typeof opts;
    if (tofOpts !== "object") {
      throw Error(`Invalid opts type: ${tofOpts}, expected "object"`);
    }
    if (Array.isArray(opts)) {
      throw Error(`Invalid opts type: Array, expected "object"`);
    }
    if (opts === null) {
      throw Error(`Invalid opts type: null, expected "object"`);
    }
    const validKeys = ["funBranch", "ourUndoRedo"];
    for (const key in opts) {
      if (!validKeys.includes(key)) {
        throw Error(`Invalid key in opts: ${key}, expected one of ${validKeys.join(", ")}`);
      }
    }

    const funBranch = opts.funBranch || undefined;
    const ourUndoRedo = opts.ourUndoRedo || false;

    let alreayCalledLogTreeStructure = false;
    let appState = { message: "state0" };

    let history;
    // history = new UndoRedoTreeWithDiff(appState, funBranch);
    doCreateHistory();
    updateMyAppUI(appState);
    const state0 = deepCopy4test(appState);

    // Action 1
    appState.message = "state1";
    // history.recordAction(appState, "Action 1");
    doRecordAction(appState, "Action 1");
    updateMyAppUI(appState);
    const state1 = deepCopy4test(appState);
    assertObjectEqual("After Action 1", appState, state1);

    // Action 2
    appState.message = "state2";
    // history.recordAction(appState, "Action 2");
    doRecordAction(appState, "Action 2");
    updateMyAppUI(appState);
    const state2 = deepCopy4test(appState);
    assertObjectEqual("After Action 2", appState, state2);

    // Undo Action 2
    // appState = history.undo();
    appState = doUndo();
    if (appState) updateMyAppUI(appState);
    assertObjectEqual("After undo Action 2", appState, state1);

    // Undo Action 1
    // appState = history.undo();
    appState = doUndo();
    if (appState) updateMyAppUI(appState);
    assertObjectEqual("After undo Action 1", appState, state0);


    // Redo Action 1
    appState = await doRedo();
    if (appState) updateMyAppUI(appState);
    assertObjectEqual("After redo Action 1", appState, state1);

    // Now, let's create a new node from here
    let branchedState = JSON.parse(JSON.stringify(appState)); // Important to copy
    // branchedState.message = history.isTreeStructured ? "New Branch!" : "New Linear!";
    branchedState.message = doIsTreeStructured() ? "New Branch!" : "New Linear!";

    // debugger; // eslint-disable-line no-debugger
    // history.recordAction(branchedState, "new node from state 1");
    doRecordAction(branchedState, "new node from state 1");
    appState = branchedState; // Update our main appState variable
    updateMyAppUI(appState);
    const stateB0 = deepCopy4test(appState);
    assertObjectEqual("After new node from state 1", appState, stateB0);

    // If we undo now:
    // appState = history.undo();
    appState = doUndo();
    if (appState) updateMyAppUI(appState);
    assertObjectEqual("After if we undo now", appState, state1);

    // redo, add a new node:
    // debugger; // eslint-disable-line no-debugger
    appState = await doRedo();
    if (appState) updateMyAppUI(appState);
    if (doIsTreeStructured()) {
      assertObjectEqual("After redo, add a new node", appState, stateB0);
    } else {
      assertObjectEqual("After redo, add a new node", appState, stateB0);
    }

    // To access the old Action 2 (counter: 15):
    // 1. Undo twice to get to root.
    // 2. Redo to state after Action 1.
    // 3. Now, the node for "Action 1" would have two children.
    //    You would need to call redo with the correct branchIndex.
    // console.log("Parent of current:", history.currentNode.parent);
    // console.log("Available redo branches from previous state:", history.currentNode.parent.children.map(c => c.action));

    // Example of checking branches (after undoing to the fork point):
    // history.undo(); // appState is now { counter: 10, message: "First action" }
    // const branches = history.getPossibleRedoActions();
    // console.log("Possible redo actions:", branches);
    // /* This would show something like:
    // [
    //   { action: "Incremented counter again", branchIndex: 0, nodeId: ... },
    //   { action: "Created a new branch from state 1", branchIndex: 1, nodeId: ... }
    // ]
    // */
    // // To go down the first original branch:
    // // appState = history.redo(0);
    // // updateMyAppUI(appState); // { counter: 15, message: "First action" }





    function assertObjectEqual(where, actual, expected) {
      if (JSON.stringify(actual) !== JSON.stringify(expected)) {
        console.error("%cNot equal", "color:white; background:red; padding:2px; font-size:1.2em", `${where}: ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
      } else {
        console.log("%cequal:", "color:white; background:green; padding:2px; font-size:1.2em", `${where}: ${JSON.stringify(actual)}`);
        if (alreayCalledLogTreeStructure) return;
        alreayCalledLogTreeStructure = true;
        setTimeout(() => {
          const history = doHistory();
          history._logTreeStructure();
        }, 1000);
      }
    }

    function deepCopy4test(obj) { return JSON.parse(JSON.stringify(obj)); }
    function updateMyAppUI(_state) {
      // console.log("UI Updated:", JSON.stringify(state));
    }



    function doKey() {
      Object.keys(histories).join(", ");
    }
    function doHistory() {
      // if (history) { throw Error("history was set in doHistory"); }
      if (ourUndoRedo) {
        const key = doKey();
        const ourHistory = histories[key];
        if (!ourHistory) { throw Error(`No history found for key: ${_key}`); }
        return ourHistory;
      }
      return history;
    }
    function doCreateHistory() {
      if (ourUndoRedo) {
        const key = doKey();
        addUndoRedo(key, appState, funBranch);
        doHistory(); // Just check it is created
        return;
      }
      history = new UndoRedoTreeWithDiff(appState, funBranch);
    }
    function doUndo() {
      if (ourUndoRedo) {
        return actionUndo(doKey());
      }
      return history.undo();
    }
    async function doRedo() {
      if (ourUndoRedo) {
        return actionRedo(doKey());
      }
      return history.redo();
    }
    function doRecordAction(state, action) {
      if (ourUndoRedo) {
        actionRecordAction(doKey(), state, action);
        return;
      }
      history.recordAction(state, action);
    }
    function doIsTreeStructured() {
      if (ourUndoRedo) {
        return getHistory(doKey()).isTreeStructured;
      }
      return history.isTreeStructured;
    }

  }
}

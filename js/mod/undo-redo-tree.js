// @ts-check
const UNDO_REDO_TREE_VERSION = "0.0.00";
window["logConsoleHereIs"](`here is db-mindmaps.js, module ${UNDO_REDO_TREE_VERSION}`);
console.warn(`here is db-mindmaps.js, module ${UNDO_REDO_TREE_VERSION}`);
if (document.currentScript) throw Error("import .currentScript"); // is module

if (typeof window["diff_match_patch"] !== "function") {
  throw Error("Google diff_match_patch is not loaded, please import it before this module");
}

export function getUndoRedoTreeVersion() { return UNDO_REDO_TREE_VERSION; }
const logClassStyle = "background:white; color:blue; padding:2px; border-radius:2px;";
const logClassImportantStyle = logClassStyle + " font-size:18px;";
function logClass(what, ...msg) { console.log(`%c${what}`, logClassStyle, ...msg); }
function logClassImportant(what, ...msg) { console.log(`%c${what}`, logClassImportantStyle, ...msg); }





// const undoRedos = {};

////////////////////////////////////////////
//// START: Code suggestions for tree from Google Gemini AI (modified):
export class HistoryTreeNode {
  /**
   * @param {UndoRedoTreeWithDiff} objUndoRedo 
   * @param {HistoryTreeNode|null} parent 
   * @param {Object} patchesToReachThisNode 
   * @param {Object} patchesToUndoThisNode 
   * @param {string|null} action 
   */
  constructor(objUndoRedo, parent, patchesToReachThisNode, patchesToUndoThisNode, action = null) {
    this.objUndoRedo = objUndoRedo; // Reference to the UndoRedoTreeWithDiff instance
    this.parent = parent; // Reference to the parent node
    this.children = [];   // Array of child nodes (branches)

    // Patches generated by diff_match_patch
    this.patchesToReach = patchesToReachThisNode; // Patches to apply to PARENT's state to get THIS node's state
    this.patchesToUndo = patchesToUndoThisNode;   // Patches to apply to THIS node's state to get PARENT's state

    this.action = action; // Optional: Description of the action
    this.id = Date.now() + Math.random().toString(36).substring(2); // A simple unique ID for debugging or advanced navigation
  }

  addChild(patchesToReach, patchesToUndo, action) {
    if (!this.objUndoRedo.isTreeStructured) {
      this.children.length = 0; // Clear existing children if linear
    }
    const newNode = new HistoryTreeNode(this.objUndoRedo, this, patchesToReach, patchesToUndo, action);
    this.children.push(newNode);
    this.currentBranchIndex = this.children.length - 1; // Update current branch index to the new child
    return newNode;
  }
}

const diff_match_patch = window["diff_match_patch"];
export class UndoRedoTreeWithDiff {
  #treeStructured = false;
  /**
   * @param {any} initialState - string or json object representing the initial state of the application.
   * @param {(defaultBranch: number, arrBranches: string[]) => number | null} [funBranch]
   */
  constructor(initialState, funBranch = undefined) {
    let txtLinOrTree = "ERROR";
    if (funBranch == null) {
      this.#treeStructured = false;
      txtLinOrTree = "**LINEAR**";
      // logClassImportant("UndoRedoTreeWithDiff", "Using linear undo/redo structure");
    } else {
      this.#treeStructured = true;
      txtLinOrTree = "**BRANCH**";
      // logClassImportant("UndoRedoTreeWithDiff", "Using tree undo/redo structure");
      this.funBranch = funBranch; // Function to handle branching logic
      const tofFunBranch = typeof funBranch;
      if (tofFunBranch !== "function") {
        throw Error(`Invalid funBranch type: ${tofFunBranch}, expected "function"`);
      }
      const lenFunBranch = funBranch.length;
      if (lenFunBranch !== 2) {
        throw Error(`Invalid funBranch length: ${lenFunBranch}, expected 2`);
      }
    }
    logClassImportant("UndoRedoTreeWithDiff", txtLinOrTree, initialState);
    this.dmp = new diff_match_patch();

    // The root node stores the full initial state directly, as it has no parent/patches.
    this.rootNode = new HistoryTreeNode(this, null, null, null, "Initial State");
    // We'll store the actual state on the root node because it's the base.
    this.rootNode.fullStateSnapshot = this._deepCopy(initialState);

    this.currentNode = this.rootNode;
    // This holds the fully rehydrated state of `this.currentNode`.
    this.currentFullState = this._deepCopy(initialState);
  }

  _logTreeStructure() {
    const linearOrTree = this.isTreeStructured ? "Tree" : "Linear";
    logClass(`Current tree structure (${linearOrTree}):`);
  // debugger; // eslint-disable-line no-debugger
    const current = this.currentNode;
    const traverse = (node, depth = 0) => {
      const markCurrent = (node === current) ? "> " : "";
      const styleCurrent = (node === current) ? "background:darkblue;color:white;" : "";
      console.log("%c" + "  ".repeat(depth) + `${markCurrent}Node ID: ${node.id}, Action: ${node.action || "N/A"} `, styleCurrent);
      if (node.children.length > 0) {
        node.children.forEach(child => traverse(child, depth + 1));
      }
    }
    traverse(this.rootNode);
  }

  _serialize(state) {
    // Ensure consistent serialization, e.g., by sorting keys if order doesn't matter
    // but can affect diffs. For simple JSON, stringify is usually enough.
    return JSON.stringify(state);
  }

  _deserialize(stateString) {
    try {
      return JSON.parse(stateString);
    } catch (e) {
      console.error("Error deserializing state:", e, stateString);
      // Graceful error handling: return null or throw, depending on application needs
      return null;
    }
  }

  _deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  get isTreeStructured() {
    return this.#treeStructured;
  }

  /**
   * 
   * @param {any} newFullState -- string or json object representing the new state of the application.
   * @param {string} actionDetails 
   * @returns 
   */
  recordAction(newFullState, actionDetails) {
    logClass("recordAction()", newFullState, actionDetails);
    const oldStateText = this._serialize(this.currentFullState);
    const newStateText = this._serialize(newFullState);

    if (oldStateText === newStateText) {
      console.log("No change in state, not recording.");
      return; // Nothing to record
    }

    // Create patches to go from old state to new state
    const patchesToReachNew = this.dmp.patch_make(oldStateText, newStateText);
    // Create patches to go from new state back to old state (for undo)
    const patchesToUndoNew = this.dmp.patch_make(newStateText, oldStateText);

    // If the current node has children, performing a new action might mean
    // abandoning other branches for the default redo path.
    // For now, we'll just add a new child.
    // Pruning or managing 'active' redo branches can be added if needed.
    // Example: this.currentNode.children = []; // If new action prunes old redo branches

    const newNode = this.currentNode.addChild(patchesToReachNew, patchesToUndoNew, actionDetails);
    this.currentNode = newNode;
    this.currentFullState = this._deepCopy(newFullState); // Update the materialized state
  }

  undo() {
    logClass("undo()");
    if (!this.currentNode.parent) {
      console.log("Already at root. Nothing to undo.");
      return null;
    }

    const patchesToApplyForUndo = this.currentNode.patchesToUndo;
    if (!patchesToApplyForUndo) {
      console.error("Error: Current node is missing 'patchesToUndo'.");
      return null;
    }

    const currentStateText = this._serialize(this.currentFullState);
    const [parentStateText, patchResults] = this.dmp.patch_apply(patchesToApplyForUndo, currentStateText);

    if (patchResults.some(applied => !applied)) {
      console.error("Undo patch application failed. Results:", patchResults);
      // State might be inconsistent. You might want to try to recover or log.
      return null;
    }

    this.currentNode = this.currentNode.parent;
    this.currentFullState = this._deserialize(parentStateText);
    return this.currentFullState;
  }

  // redo(branchIndex = 0) {
  redo() {
  // debugger; // eslint-disable-line no-debugger
    /*
    if (!Number.isInteger(branchIndex) || branchIndex < 0) {
      throw Error(`Invalid branch index "${branchIndex} for redo. Must be a non-negative integer.`);
    }
    logClass(`redo(${branchIndex})`);
    */
    logClass("redo()");
    const currentNode = this.currentNode;
    if (currentNode.children.length === 0) {
      console.log("Nothing to redo.");
      return null;
    }

    const defaultBranchIndex = this.currentNode.currentBranchIndex || 0;
    let branchIndex = defaultBranchIndex;
    if (this.funBranch) {
      const arrChildren = this.currentNode.children.map(c => c.action);
      branchIndex = this.funBranch(defaultBranchIndex, arrChildren);
    }
    const childNodeToRedoTo = currentNode.children[branchIndex];
    const patchesToApplyForRedo = childNodeToRedoTo.patchesToReach;

    if (!patchesToApplyForRedo) {
      console.error("Error: Target child node is missing 'patchesToReach'.");
      return null;
    }

    const currentStateText = this._serialize(this.currentFullState);
    const [nextStateText, patchResults] = this.dmp.patch_apply(patchesToApplyForRedo, currentStateText);

    if (patchResults.some(applied => !applied)) {
      console.error("Redo patch application failed. Results:", patchResults);
      return null;
    }

    this.currentNode = childNodeToRedoTo;
    this.currentFullState = this._deserialize(nextStateText);
    return this.currentFullState;
  }

  // To get the state of an arbitrary node (can be expensive for deep trees)
  // This reconstructs the state by applying patches from the root.
  getStateOfNode(targetNode) {
    if (!targetNode) return null;
    if (targetNode === this.rootNode) {
      return this._deepCopy(this.rootNode.fullStateSnapshot);
    }

    const path = [];
    let temp = targetNode;
    while (temp && temp.parent) { // Go up to root
      path.unshift(temp); // Add to front to get path from root
      temp = temp.parent;
    }

    if (temp !== this.rootNode) {
      console.error("Target node is not part of this tree or tree is corrupted.");
      return null;
    }

    let reconstructedState = this._deepCopy(this.rootNode.fullStateSnapshot);

    for (const nodeOnPath of path) {
      const patches = nodeOnPath.patchesToReach;
      if (!patches) {
        console.error("Node on path is missing patchesToReach:", nodeOnPath.id);
        return null; // Or throw error
      }
      const currentStateText = this._serialize(reconstructedState);
      const [nextStateText, results] = this.dmp.patch_apply(patches, currentStateText);
      if (results.some(r => !r)) {
        console.error("Patch application failed during state reconstruction for node:", nodeOnPath.id, results);
        return null; // Or throw error
      }
      reconstructedState = this._deserialize(nextStateText);
      if (reconstructedState === null) { // Deserialization failed
        console.error("Deserialization failed during state reconstruction for node:", nodeOnPath.id);
        return null;
      }
    }
    return reconstructedState;
  }

  // Utility to jump to a specific node if you have its reference
  navigateToNode(node) {
    const state = this.getStateOfNode(node);
    if (state !== null) {
      this.currentNode = node;
      this.currentFullState = state;
      return this.currentFullState;
    }
    console.warn("Could not navigate to node.");
    return null;
  }

  getPossibleRedoActions() {
    return this.currentNode.children.map((child, index) => ({
      action: child.action,
      branchIndex: index,
      nodeId: child.id
    }));
  }
}
//// END: Code suggestions for tree from Google Gemini AI:
////////////////////////////////////////////


export function actionAdd(_key, _initialValue, _actionDetails) {
  debugger; // eslint-disable-line no-debugger
}
export function actionRemove(_key) {
}

export function actionUndo(_key) {
  debugger; // eslint-disable-line no-debugger
}
export function actionRedo(_key) {
  debugger; // eslint-disable-line no-debugger
}

////////////////////////////////////////////
// Basic tests from AI

_basicTest(); // linear

/**
 * 
 * @param {number} defaultBranch 
 * @param {string[]} arrBranches 
 * @returns 
 */
const ourFunBranch = (defaultBranch, arrBranches) => {
  if (!Number.isInteger(defaultBranch) || defaultBranch < 0) {
    throw Error(`Invalid defaultBranch "${defaultBranch}" for ourFunBranch. Must be a non-negative integer.`);
  }
  console.log({arrBranches});
  // This function can be used to determine how to branch based on the actionDetails
  return defaultBranch; // Always return the default branch for now
}
_basicTest(ourFunBranch); // branched

function _basicTest(funBranch) {
  console.log("%c_basicTest", "font-size:20px; color:white; background:blue; padding:2px; border-radius:2px;");

  function deepCopy4test(obj) { return JSON.parse(JSON.stringify(obj)); }
  function updateMyAppUI(_state) {
    // console.log("UI Updated:", JSON.stringify(state));
  }

  let alreayCalledLogTreeStructure = false;
  let appState = { message: "state0" };

  const history = new UndoRedoTreeWithDiff(appState, funBranch);
  updateMyAppUI(appState);
  const state0 = deepCopy4test(appState);

  // Action 1
  appState.message = "state1";
  history.recordAction(appState, "Action 1");
  updateMyAppUI(appState);
  const state1 = deepCopy4test(appState);
  assertObjectEqual("After Action 1", appState, state1);

  // Action 2
  appState.message = "state2";
  history.recordAction(appState, "Action 2");
  updateMyAppUI(appState);
  const state2 = deepCopy4test(appState);
  assertObjectEqual("After Action 2", appState, state2);

  // Undo Action 2
  appState = history.undo();
  if (appState) updateMyAppUI(appState);
  assertObjectEqual("After undo Action 2", appState, state1);

  // Undo Action 1
  appState = history.undo();
  if (appState) updateMyAppUI(appState);
  assertObjectEqual("After undo Action 1", appState, state0);


  // Redo Action 1
  appState = history.redo(); // Assuming redo follows the main branch (branchIndex 0)
  if (appState) updateMyAppUI(appState);
  assertObjectEqual("After redo Action 1", appState, state1);

  // Now, let's create a new node from here
  let branchedState = JSON.parse(JSON.stringify(appState)); // Important to copy
  branchedState.message = history.isTreeStructured ? "New Branch!" : "New Linear!";

  // debugger; // eslint-disable-line no-debugger
  history.recordAction(branchedState, "new node from state 1");
  appState = branchedState; // Update our main appState variable
  updateMyAppUI(appState);
  const stateB0 = deepCopy4test(appState);
  assertObjectEqual("After new node from state 1", appState, stateB0);

  // If we undo now:
  appState = history.undo();
  if (appState) updateMyAppUI(appState);
  assertObjectEqual("After if we undo now", appState, state1);

  // redo, add a new node:
  // debugger; // eslint-disable-line no-debugger
  appState = history.redo();
  if (appState) updateMyAppUI(appState);
  if (history.isTreeStructured) {
    assertObjectEqual("After redo, add a new node", appState, stateB0);
  } else {
    assertObjectEqual("After redo, add a new node", appState, stateB0);
  }

  // To access the old Action 2 (counter: 15):
  // 1. Undo twice to get to root.
  // 2. Redo to state after Action 1.
  // 3. Now, the node for "Action 1" would have two children.
  //    You would need to call redo with the correct branchIndex.
  // console.log("Parent of current:", history.currentNode.parent);
  // console.log("Available redo branches from previous state:", history.currentNode.parent.children.map(c => c.action));

  // Example of checking branches (after undoing to the fork point):
  // history.undo(); // appState is now { counter: 10, message: "First action" }
  // const branches = history.getPossibleRedoActions();
  // console.log("Possible redo actions:", branches);
  // /* This would show something like:
  // [
  //   { action: "Incremented counter again", branchIndex: 0, nodeId: ... },
  //   { action: "Created a new branch from state 1", branchIndex: 1, nodeId: ... }
  // ]
  // */
  // // To go down the first original branch:
  // // appState = history.redo(0);
  // // updateMyAppUI(appState); // { counter: 15, message: "First action" }





  function assertObjectEqual(where, actual, expected) {
    if (JSON.stringify(actual) !== JSON.stringify(expected)) {
      console.error("%cNot equal", "color:white; background:red; padding:2px; font-size:1.2em", `${where}: ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
    } else {
      console.log("%cequal:", "color:white; background:green; padding:2px; font-size:1.2em", `${where}: ${JSON.stringify(actual)}`);
      if (alreayCalledLogTreeStructure) return;
      alreayCalledLogTreeStructure = true;
      setTimeout(() => { history._logTreeStructure(); }, 1000);
    }
  }
}
